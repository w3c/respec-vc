/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _digitalbazaar_bbs_2023_cryptosuite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/bbs-2023-cryptosuite */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/index.js\");\n/* harmony import */ var _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/bls12-381-multikey */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/ecdsa-multikey */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ecdsa_rdfc_2019_cryptosuite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @digitalbazaar/ecdsa-rdfc-2019-cryptosuite */ \"./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ecdsa_sd_2023_cryptosuite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @digitalbazaar/ecdsa-sd-2023-cryptosuite */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ed25519_multikey__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @digitalbazaar/ed25519-multikey */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_credentials_examples_context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @digitalbazaar/credentials-examples-context */ \"./node_modules/@digitalbazaar/credentials-examples-context/js/index.js\");\n/* harmony import */ var _digitalbazaar_credentials_examples_context__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_digitalbazaar_credentials_examples_context__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var jose__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jose */ \"./node_modules/jose/dist/browser/index.js\");\n/* harmony import */ var _digitalbazaar_odrl_context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @digitalbazaar/odrl-context */ \"./node_modules/@digitalbazaar/odrl-context/js/index.js\");\n/* harmony import */ var _digitalbazaar_odrl_context__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_digitalbazaar_odrl_context__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @digitalbazaar/vc */ \"./node_modules/@digitalbazaar/vc/lib/index.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(jsonld_signatures__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _digitalbazaar_data_integrity__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @digitalbazaar/data-integrity */ \"./node_modules/@digitalbazaar/data-integrity/lib/index.js\");\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/* harmony import */ var _digitalbazaar_ed25519_signature_2020__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @digitalbazaar/ed25519-signature-2020 */ \"./node_modules/@digitalbazaar/ed25519-signature-2020/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @digitalbazaar/ed25519-verification-key-2020 */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/index.js\");\n/* harmony import */ var _digitalbazaar_eddsa_rdfc_2022_cryptosuite__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @digitalbazaar/eddsa-rdfc-2022-cryptosuite */ \"./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/index.js\");\n/* harmony import */ var multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! multiformats/hashes/hasher */ \"./node_modules/multiformats/dist/src/hashes/hasher.js\");\n/* harmony import */ var multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! multiformats/bases/base64 */ \"./node_modules/multiformats/dist/src/bases/base64.js\");\n/* harmony import */ var multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! multiformats/bases/base58 */ \"./node_modules/multiformats/dist/src/bases/base58.js\");\n/* harmony import */ var multiformats_bases_base16__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! multiformats/bases/base16 */ \"./node_modules/multiformats/dist/src/bases/base16.js\");\n/* harmony import */ var _contexts_credentials_examples_v2__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./contexts/credentials/examples/v2 */ \"./contexts/credentials/examples/v2.json\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"./node_modules/@noble/hashes/esm/sha3.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// default types\nconst TAB_TYPES = [\n  'ecdsa-rdfc-2019',\n  'eddsa-rdfc-2022',\n  'ecdsa-sd-2023',\n  'bbs-2023',\n  'vc-jwt'\n];\n// additional types: Ed25519Signature2020\n\n// purposes used below\nconst {AssertionProofPurpose} = jsonld_signatures__WEBPACK_IMPORTED_MODULE_10__.purposes;\n\n// setup contexts used by respec-vc\nconst contexts = {};\nfor(const item of [_digitalbazaar_odrl_context__WEBPACK_IMPORTED_MODULE_8__, ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_12__[\"default\"], _digitalbazaar_credentials_examples_context__WEBPACK_IMPORTED_MODULE_6__]) {\n  for(const [url, context] of item.contexts) {\n    contexts[url] = context;\n  }\n}\ncontexts['https://www.w3.org/ns/credentials/examples/v2'] = _contexts_credentials_examples_v2__WEBPACK_IMPORTED_MODULE_20__;\n\n// setup static document loader\nconst documentLoader = (0,jsonld_signatures__WEBPACK_IMPORTED_MODULE_10__.extendContextLoader)(async function documentLoader(url) {\n  const context = contexts[url];\n  if(context !== undefined) {\n    return {\n      contextUrl: null,\n      documentUrl: url,\n      document: context\n    };\n  }\n  return (0,_digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_9__.defaultDocumentLoader)(url);\n});\n\nasync function createBBSExampleProof() {\n  const key = await _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_1__.generateBbsKeyPair({\n    algorithm: _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_1__.ALGORITHMS.BBS_BLS12381_SHA256\n  });\n\n  const proof = new _digitalbazaar_data_integrity__WEBPACK_IMPORTED_MODULE_11__.DataIntegrityProof({\n    signer: key.signer(),\n    cryptosuite: _digitalbazaar_bbs_2023_cryptosuite__WEBPACK_IMPORTED_MODULE_0__.createSignCryptosuite({\n      mandatoryPointers: ['/issuer']\n    })\n  });\n\n  return {\n    proof,\n    key,\n    label: 'bbs'\n  };\n}\n\nasync function createEcdsaRdfc2019ExampleProof() {\n  const key = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_2__.generate({curve: 'P-256'});\n\n  // ecdsa-rdfc-2019\n  const {cryptosuite: rdfcCryptosuite} = _digitalbazaar_ecdsa_rdfc_2019_cryptosuite__WEBPACK_IMPORTED_MODULE_3__;\n  const proof = new _digitalbazaar_data_integrity__WEBPACK_IMPORTED_MODULE_11__.DataIntegrityProof({\n    signer: key.signer(),\n    cryptosuite: rdfcCryptosuite\n  });\n\n  return {\n    proof,\n    key,\n    label: 'ecdsa'\n  };\n}\n\nasync function createEcdsaSd2023ExampleProof() {\n  const key = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_2__.generate({curve: 'P-256'});\n\n  // ecdsa-sd-2023\n  const {createSignCryptosuite} = _digitalbazaar_ecdsa_sd_2023_cryptosuite__WEBPACK_IMPORTED_MODULE_4__;\n  const proof = new _digitalbazaar_data_integrity__WEBPACK_IMPORTED_MODULE_11__.DataIntegrityProof({\n    signer: key.signer(),\n    cryptosuite: createSignCryptosuite({\n      mandatoryPointers: ['/issuer']\n    })\n  });\n\n  return {\n    proof,\n    key,\n    label: 'ecdsa-sd'\n  };\n}\n\nasync function createEddsaRdfc2022ExampleProof() {\n  // Ed25519Signature2020\n  const keyPairEd25519VerificationKey2020 = await _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_14__.Ed25519VerificationKey2020\n    .generate();\n\n  const key = await _digitalbazaar_ed25519_multikey__WEBPACK_IMPORTED_MODULE_5__.from(keyPairEd25519VerificationKey2020);\n\n  // eddsa-rdfc-2022\n  const proof = new _digitalbazaar_data_integrity__WEBPACK_IMPORTED_MODULE_11__.DataIntegrityProof({\n    signer: key.signer(),\n    cryptosuite: _digitalbazaar_eddsa_rdfc_2022_cryptosuite__WEBPACK_IMPORTED_MODULE_15__.cryptosuite\n  });\n\n  return {\n    proof,\n    key,\n    label: 'eddsa'\n  };\n}\n\n// convert an XML Schema v1.` Datetime value to a UNIX timestamp\nfunction xmlDateTimeToUnixTimestamp(xmlDateTime) {\n  if(!xmlDateTime) {\n    return undefined;\n  }\n\n  return Date.parse(xmlDateTime) / 1000;\n}\n\n// transform the input credential to a JWT\nasync function transformToJwt({credential, kid, jwk}) {\n  const header = {alg: 'ES256', typ: 'JWT', kid};\n  const payload = {\n    vc: credential\n  };\n  if(credential.expirationDate) {\n    payload.exp = xmlDateTimeToUnixTimestamp(credential.expirationDate);\n  }\n  if(credential.issuer) {\n    payload.iss = credential.issuer;\n  }\n  if(credential.issuanceDate) {\n    payload.nbf = xmlDateTimeToUnixTimestamp(credential.issuanceDate);\n  }\n  if(credential.id) {\n    payload.jti = credential.id;\n  }\n  if(credential.credentialSubject.id) {\n    payload.sub = credential.credentialSubject.id;\n  }\n\n  // create the JWT description\n  let description = '---------------- JWT header ---------------\\n' +\n    JSON.stringify(header, null, 2);\n  description += '\\n\\n--------------- JWT payload ---------------\\n' +\n    '// NOTE: The example below uses a valid VC-JWT serialization\\n' +\n    '//       that duplicates the iss, nbf, jti, and sub fields in the\\n' +\n    '//       Verifiable Credential (vc) field.\\n\\n' +\n    JSON.stringify(payload, null, 2);\n  const jwt = await new jose__WEBPACK_IMPORTED_MODULE_7__.SignJWT(payload)\n    .setProtectedHeader(header)\n    .sign(jwk.privateKey);\n\n  return description + '\\n\\n--------------- JWT ---------------\\n\\n' + jwt;\n}\n\nasync function attachProof({credential, suite}) {\n  const credentialCopy = JSON.parse(JSON.stringify(credential));\n  const options = {credential: credentialCopy, suite, documentLoader};\n  options.purposes = new AssertionProofPurpose();\n  return (0,_digitalbazaar_vc__WEBPACK_IMPORTED_MODULE_9__.issue)(options);\n}\n\nfunction addVcExampleStyles() {\n  const exampleStyles = document.createElement('style');\n\n  const radioLabels = [...Array(TAB_TYPES.length + 1).keys()]\n    .map(i => {\n      const j = i + 1;\n      return `.vc-tabbed [type=\"radio\"]:nth-of-type(${j}):checked ~ .vc-tabs .vc-tab:nth-of-type(${j}) label`;\n    });\n  const radioSelector = [...Array(TAB_TYPES.length + 1).keys()]\n    .map(i => {\n      const j = i + 1;\n      return `.vc-tabbed [type=\"radio\"]:nth-of-type(${j}):checked ~ .vc-tab-content:nth-of-type(${j})`;\n    });\n\n  exampleStyles.innerHTML += `\n  .vc-tabbed {\n    overflow-x: hidden;\n    margin: 0 0;\n  }\n\n  .vc-tabbed [type=\"radio\"] {\n    display: none;\n  }\n\n  .vc-tabs {\n    display: flex;\n    align-items: stretch;\n    list-style: none;\n    padding: 0;\n    border-bottom: 1px solid #ccc;\n  }\n\n  li.vc-tab {\n    margin: unset;\n  }\n\n  .vc-tab > label {\n    display: block;\n    margin-bottom: -1px;\n    padding: .4em .5em;\n    border: 1px solid #ccc;\n    border-top-right-radius: .4em;\n    border-top-left-radius: .4em;\n    background: #eee;\n    color: #666;\n    cursor: pointer;\n    transition: all 0.3s;\n  }\n  .vc-tab:hover label {\n    border-left-color: #333;\n    border-top-color: #333;\n    border-right-color: #333;\n    color: #333;\n  }\n\n  .vc-tab-content {\n    display: none;\n  }\n\n  ${radioLabels.join(',\\n  ')} {\n    border-bottom-color: #fff;\n    background: #fff;\n    color: #222;\n  }\n\n  ${radioSelector.join(',\\n  ')} {\n    display: block;\n  }`;\n\n  document.getElementsByTagName('head')[0].appendChild(exampleStyles);\n}\n\nfunction addContext(url, context) {\n  contexts[url] = context;\n}\n\nasync function createVcExamples() {\n  // process all 'vc-hash' entries\n  const sha2256Hasher = multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_16__.from({\n    name: 'sha2-256',\n    code: 0x12,\n    encode: (input) => (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_21__.sha256)(input)\n  });\n  const sha2384Hasher = multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_16__.from({\n    name: 'sha2-384',\n    code: 0x20,\n    encode: (input) => (0,_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_22__.sha384)(input)\n  });\n  const sha3256Hasher = multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_16__.from({\n    name: 'sha3-256',\n    code: 0x16,\n    encode: (input) => (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_23__.sha3_256)(input)\n  });\n  const sha3384Hasher = multiformats_hashes_hasher__WEBPACK_IMPORTED_MODULE_16__.from({\n    name: 'sha3-384',\n    code: 0x15,\n    encode: (input) => (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_23__.sha3_384)(input)\n  });\n\n  const vcHashEntries = document.querySelectorAll('.vc-hash');\n  let vcHashEntryIndex = 0;\n  for(const hashEntry of vcHashEntries) {\n    vcHashEntryIndex++;\n\n    // get the hash requirements\n    const hashUrl = hashEntry.dataset?.hashUrl || 'INVALID_URL';\n    const hashFormat = hashEntry.dataset?.hashFormat?.split(/(\\s+)/) || [];\n    let encodedHash = null;\n\n    // select the base encoder (default: base64-url with no padding)\n    let baseEncoder;\n    if(hashFormat.includes('sri')) {\n      baseEncoder = multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_17__.base64pad;\n    } else if(hashFormat.includes('base16')) {\n      baseEncoder = multiformats_bases_base16__WEBPACK_IMPORTED_MODULE_19__.base16;\n    } else if(hashFormat.includes('base58btc')) {\n      baseEncoder = multiformats_bases_base58__WEBPACK_IMPORTED_MODULE_18__.base58btc;\n    } else {\n      baseEncoder = multiformats_bases_base64__WEBPACK_IMPORTED_MODULE_17__.base64url;\n    }\n\n    // retrieve the file and generate the hash\n    try {\n      const response = await fetch(hashUrl);\n\n      // ensure retrieval succeeded\n      if(response.status !== 200) {\n        throw new Error('Failed to retrieve '+ hashUrl);\n      }\n      const hashData = new Uint8Array(await response.arrayBuffer());\n\n      // determine the hash algorithm to use and produce the output accordingly\n      if(hashFormat.includes('openssl') && hashFormat.includes('-sha256') ) {\n        const mfHash = await sha2256Hasher.digest(hashData);\n        encodedHash = Array.prototype.map.call(mfHash.digest, (byte) => {\n          return ('0' + (byte & 0xFF).toString(16)).slice(-2);\n        }).join('');\n      } else if(hashFormat.includes('sri')) {\n        if(hashFormat.includes('sha2-256')) {\n          const mfHash = await sha2256Hasher.digest(hashData);\n          encodedHash = 'sha256-' + baseEncoder.encode(mfHash.digest);\n        } else if(hashFormat.includes('sha2-384')) {\n          const mfHash = await sha2384Hasher.digest(hashData);\n          encodedHash = 'sha384-' + baseEncoder.encode(mfHash.digest);\n        }\n      } else if(hashFormat.includes('multihash')) {\n        if(hashFormat.includes('sha2-256')) {\n          const mfHash = await sha2256Hasher.digest(hashData).bytes;\n          encodedHash = baseEncoder.encode(mfHash);\n        } else if(hashFormat.includes('sha2-384')) {\n          const mfHash = await sha2384Hasher.digest(hashData).bytes;\n          encodedHash = baseEncoder.encode(mfHash);\n        } else if(hashFormat.includes('sha3-256')) {\n          const mfHash = await sha3256Hasher.digest(hashData).bytes;\n          encodedHash = baseEncoder.encode(mfHash);\n        } else if(hashFormat.includes('sha3-384')) {\n          const mfHash = await sha3384Hasher.digest(hashData).bytes;\n          encodedHash = baseEncoder.encode(mfHash);\n        }\n      }\n\n      // set the encodedHash value\n      hashEntry.innerText = encodedHash || 'Unsupported hash format: \\'' +\n        hashEntry.dataset?.hashFormat + '\\'';\n    } catch(e) {\n      console.error('respec-vc error: Failed to create cryptographic hash.',\n        e, hashEntry);\n      hashEntry.innerText = 'Error generating cryptographic hash for ' +\n        hashUrl;\n      continue;\n    }\n  }\n\n  // process all 'vc' entries\n  const exampleProofs = [];\n\n  // ecdsa-rdfc-2019\n  const ecdsaRdfc2019 = await createEcdsaRdfc2019ExampleProof();\n  exampleProofs.push(ecdsaRdfc2019);\n\n  // Ed25519Signature2020\n  const keyPairEd25519VerificationKey2020 = await _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_14__.Ed25519VerificationKey2020\n    .generate();\n  const suiteEd25519Signature2020 = new _digitalbazaar_ed25519_signature_2020__WEBPACK_IMPORTED_MODULE_13__.Ed25519Signature2020({\n    key: keyPairEd25519VerificationKey2020\n  });\n\n  // eddsa-rdfc-2022\n  const eddsaRdfc2022 = await createEddsaRdfc2022ExampleProof();\n  exampleProofs.push(eddsaRdfc2022);\n\n  // ecdsa-sd-2023\n  const ecdsaSd2023 = await createEcdsaSd2023ExampleProof();\n  exampleProofs.push(ecdsaSd2023);\n\n  // bbs-2023\n  const bbs2023 = await createBBSExampleProof();\n  exampleProofs.push(bbs2023);\n\n  // vc-jwt\n  const jwk = await jose__WEBPACK_IMPORTED_MODULE_7__.generateKeyPair('ES256');\n\n  // add styles for examples\n  addVcExampleStyles();\n\n  // process every example that needs a vc-proof\n  const vcProofExamples = document.querySelectorAll('.vc');\n  let vcProofExampleIndex = 0;\n  for(const example of vcProofExamples) {\n    vcProofExampleIndex++;\n\n    const verificationMethod = example.dataset?.vcVm ||\n      'did:key:' + keyPairEd25519VerificationKey2020.publicKeyMultibase;\n\n    const tabTypes = example.dataset?.vcTabs || TAB_TYPES;\n\n    // extract and parse the example as JSON\n    let credential = {};\n    try {\n      let exampleText = example.innerText;\n      exampleText = exampleText.replace(/\\/\\/ .*$/gm, '');\n      credential = JSON.parse(exampleText);\n    } catch(e) {\n      console.error('respec-vc error: Failed to create Verifiable Credential.',\n        e, example.innerText);\n      continue;\n    }\n\n    // set up the tabbed content\n    const tabbedContent = document.createElement('div');\n    tabbedContent.setAttribute('class', 'vc-tabbed');\n\n    // set up the tab labels\n    const tabLabels = document.createElement('ul');\n    tabLabels.setAttribute('class', 'vc-tabs');\n    tabbedContent.appendChild(tabLabels);\n\n    /**\n     * Definition for the content callback used by addTab.\n     *\n     * @callback contentCallback\n     */\n\n    /**\n     * Add tab to tab container in DOM. Run callback function to populate\n     * content on tab click.\n     *\n     * @param {string} suffix - One of the TAB_TYPES values (or `unsigned`).\n     * @param {string} labelText - Human readable label name.\n     * @param {string} tabText - Text to display on the tab.\n     * @param {contentCallback} callback - Function which returns HTML.\n     */\n    function addTab(suffix, labelText, tabText, callback) {\n      const button = document.createElement('input');\n      button.setAttribute('type', 'radio');\n      button.setAttribute('id', `vc-tab${vcProofExampleIndex}${suffix}`);\n      button.setAttribute('name', `vc-tabs${vcProofExampleIndex}`);\n      if(tabbedContent.firstChild.tagName === 'INPUT') {\n        // place this one last of the inputs\n        [...tabbedContent.querySelectorAll('input')].pop().after(button);\n      } else {\n        tabbedContent.prepend(button);\n      }\n\n      const label = document.createElement('li');\n      label.setAttribute('class', 'vc-tab');\n\n      const tabLabel = document.createElement('label');\n      tabLabel.setAttribute('for', button.getAttribute('id'));\n\n      const abbr = document.createElement('abbr');\n      abbr.setAttribute('title', labelText);\n      abbr.innerText = tabText;\n\n      tabLabel.appendChild(abbr);\n      label.appendChild(tabLabel);\n      tabLabels.appendChild(label);\n\n      const content = document.createElement('div');\n      content.setAttribute('class', 'vc-tab-content');\n      content.style.minHeight = `${example.clientHeight}px`;\n      tabbedContent.appendChild(content);\n\n      if(suffix === 'unsigned') {\n        content.innerHTML = callback();\n      } else {\n        label.addEventListener('click', async () => {\n          content.innerHTML = await callback();\n        }, {once: true});\n      }\n    }\n\n    /**\n     * Add a Data Integrity based proof example tab.\n     *\n     * @global string verificationMethod\n     * @param {object} suite - Suite object.\n     * @param {string} tabText - Text to display on the tab.\n     * @param {string | undefined} key - Optional key to use for the proof.\n     */\n    async function addProofTab(suite, tabText, key) {\n      let verifiableCredentialProof;\n      const label = suite?.cryptosuite || suite.type;\n\n      if(key) {\n        suite.verificationMethod = 'did:key:' + key.publicKeyMultibase;\n      } else {\n        suite.verificationMethod = verificationMethod;\n      }\n\n      addTab(label, `Secured with Data Integrity - ${label}`, tabText, async () => {\n        // attach the proof\n        try {\n          verifiableCredentialProof = await attachProof({credential, suite});\n          return `<pre>${JSON.stringify(verifiableCredentialProof, null, 2)\n            .match(/.{1,75}/g).join('\\n')}</pre>`;\n        } catch(e) {\n          console.error(\n            'respec-vc error: Failed to attach proof to Verifiable Credential.',\n            e, example.innerText);\n        }\n      });\n    }\n\n    function hasTab(identifier) {\n      return tabTypes.indexOf(identifier) > -1;\n    }\n\n    // set up the unsigned button\n    addTab(\n      'unsigned',\n      'Unsecured credential',\n      'Credential',\n      () => example.outerHTML\n    );\n\n    for(const {proof, key, label} of exampleProofs) {\n      if(hasTab(proof.cryptosuite)) {\n        await addProofTab(proof, label, key);\n      }\n    }\n\n    if(hasTab(suiteEd25519Signature2020.type)) {\n      await addProofTab(suiteEd25519Signature2020, 'Ed25519Signature2020');\n    }\n\n    if(hasTab('vc-jwt')) {\n      // set up the signed JWT button\n      addTab('vc-jwt', 'Secured with VC-JWT', 'vc-jwt',\n        async () => {\n          // convert to a JWT\n          let verifiableCredentialJwt;\n          try {\n            verifiableCredentialJwt = await transformToJwt({\n              credential, kid: verificationMethod, jwk});\n            return `<pre>${verifiableCredentialJwt.match(/.{1,75}/g).join('\\n')}</pre>`;\n          } catch(e) {\n            console.error(\n              'respec-vc error: Failed to convert Credential to JWT.',\n              e, example.innerText);\n          }\n        });\n    }\n\n    // append the tabbed content\n\n    // replace the original example with the tabbed content\n    const container = example.parentNode;\n    // set first radio as checked\n    tabbedContent.querySelector('input').toggleAttribute('checked');\n    container.append(tabbedContent);\n    example.remove();\n  }\n}\n\n// setup exports on window\nwindow.respecVc = {\n  addContext,\n  createVcExamples\n};\n\n\n//# sourceURL=webpack://respec-vc/./index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/credentials-examples-context/js/constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/credentials-examples-context/js/constants.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = {\n  CONTEXT_FILENAME: 'credentials-examples-v1.jsonld',\n  CONTEXT_URL_V1: 'https://www.w3.org/2018/credentials/examples/v1'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/credentials-examples-context/js/constants.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/credentials-examples-context/js/context.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/credentials-examples-context/js/context.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst odrlCtx = __webpack_require__(/*! @digitalbazaar/odrl-context */ \"./node_modules/@digitalbazaar/odrl-context/js/index.js\");\n\nmodule.exports = {\n  '@context': [\n    {\n      '@version': 1.1\n    },\n    odrlCtx.CONTEXT_URL_V1,\n    {\n      ex: 'https://example.org/examples#',\n      schema: 'http://schema.org/',\n      rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n      '3rdPartyCorrelation': 'ex:3rdPartyCorrelation',\n      AllVerifiers: 'ex:AllVerifiers',\n      AlumniCredential: 'ex:AlumniCredential',\n      Archival: 'ex:Archival',\n      BachelorDegree: 'ex:BachelorDegree',\n      Child: 'ex:Child',\n      CLCredentialDefinition2019: 'ex:CLCredentialDefinition2019',\n      CLSignature2019: 'ex:CLSignature2019',\n      DisputeCredential: 'ex:DisputeCredential',\n      IssuerPolicy: 'ex:IssuerPolicy',\n      HolderPolicy: 'ex:HolderPolicy',\n      Mother: 'ex:Mother',\n      PrescriptionCredential: 'ex:PrescriptionCredential',\n      RelationshipCredential: 'ex:RelationshipCredential',\n      UniversityDegreeCredential: 'ex:UniversityDegreeCredential',\n      ZkpExampleSchema2018: 'ex:ZkpExampleSchema2018',\n      alumniOf: {\n        '@id': 'schema:alumniOf',\n        '@type': 'rdf:HTML'\n      },\n      attributes: 'ex:attributes',\n      child: {\n        '@id': 'ex:child',\n        '@type': '@id'\n      },\n      college: 'ex:college',\n      currentStatus: 'ex:currentStatus',\n      degree: 'ex:degree',\n      degreeSchool: 'ex:degreeSchool',\n      degreeType: 'ex:degreeType',\n      familyName: 'schema:familyName',\n      givenName: 'schema:givenName',\n      issuerData: 'ex:issuerData',\n      name: {\n        '@id': 'schema:name',\n        '@type': 'rdf:HTML'\n      },\n      nonRevocationProof: 'ex:nonRevocationProof',\n      parent: {\n        '@id': 'ex:parent',\n        '@type': '@id'\n      },\n      prescription: 'ex:prescription',\n      primaryProof: 'ex:primaryProof',\n      referenceId: 'ex:referenceId',\n      documentPresence: 'ex:documentPresence',\n      evidenceDocument: 'ex:evidenceDocument',\n      signature: 'ex:signature',\n      signatureCorrectnessProof: 'ex:signatureCorrectnessProof',\n      spouse: 'schema:spouse',\n      statusReason: 'ex:statusReason',\n      subjectPresence: 'ex:subjectPresence',\n      verifier: {\n        '@id': 'ex:verifier',\n        '@type': '@id'\n      }\n    }\n  ]\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/credentials-examples-context/js/context.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/credentials-examples-context/js/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/credentials-examples-context/js/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst context = __webpack_require__(/*! ./context.js */ \"./node_modules/@digitalbazaar/credentials-examples-context/js/context.js\");\nconst constants = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/credentials-examples-context/js/constants.js\");\nconst {CONTEXT_URL_V1} = constants;\n\nconst contexts = new Map();\ncontexts.set(CONTEXT_URL_V1, context);\n\nmodule.exports = {\n  constants,\n  contexts,\n  CONTEXT_URL_V1,\n  CONTEXT_V1: context\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/credentials-examples-context/js/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/odrl-context/js/constants.js":
/*!******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/odrl-context/js/constants.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = {\n  CONTEXT_FILENAME: 'odrl.jsonld',\n  CONTEXT_URL_V1: 'https://www.w3.org/ns/odrl.jsonld'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/odrl-context/js/constants.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/odrl-context/js/context.js":
/*!****************************************************************!*\
  !*** ./node_modules/@digitalbazaar/odrl-context/js/context.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = {\n  '@context': {\n    odrl: 'http://www.w3.org/ns/odrl/2/',\n    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',\n    owl: 'http://www.w3.org/2002/07/owl#',\n    skos: 'http://www.w3.org/2004/02/skos/core#',\n    dct: 'http://purl.org/dc/terms/',\n    xsd: 'http://www.w3.org/2001/XMLSchema#',\n    vcard: 'http://www.w3.org/2006/vcard/ns#',\n    foaf: 'http://xmlns.com/foaf/0.1/',\n    schema: 'http://schema.org/',\n    cc: 'http://creativecommons.org/ns#',\n    uid: '@id',\n    type: '@type',\n    Policy: 'odrl:Policy',\n    Rule: 'odrl:Rule',\n    profile: {\n      '@type': '@id',\n      '@id': 'odrl:profile'\n    },\n    inheritFrom: {\n      '@type': '@id',\n      '@id': 'odrl:inheritFrom'\n    },\n    ConflictTerm: 'odrl:ConflictTerm',\n    conflict: {\n      '@type': '@vocab',\n      '@id': 'odrl:conflict'\n    },\n    perm: 'odrl:perm',\n    prohibit: 'odrl:prohibit',\n    invalid: 'odrl:invalid',\n    Agreement: 'odrl:Agreement',\n    Assertion: 'odrl:Assertion',\n    Offer: 'odrl:Offer',\n    Privacy: 'odrl:Privacy',\n    Request: 'odrl:Request',\n    Set: 'odrl:Set',\n    Ticket: 'odrl:Ticket',\n    Asset: 'odrl:Asset',\n    AssetCollection: 'odrl:AssetCollection',\n    relation: {\n      '@type': '@id',\n      '@id': 'odrl:relation'\n    },\n    hasPolicy: {\n      '@type': '@id',\n      '@id': 'odrl:hasPolicy'\n    },\n    target: {\n      '@type': '@id',\n      '@id': 'odrl:target'\n    },\n    output: {\n      '@type': '@id',\n      '@id': 'odrl:output'\n    },\n    partOf: {\n      '@type': '@id',\n      '@id': 'odrl:partOf'\n    },\n    source: {\n      '@type': '@id',\n      '@id': 'odrl:source'\n    },\n    Party: 'odrl:Party',\n    PartyCollection: 'odrl:PartyCollection',\n    function: {\n      '@type': '@vocab',\n      '@id': 'odrl:function'\n    },\n    PartyScope: 'odrl:PartyScope',\n    assignee: {\n      '@type': '@id',\n      '@id': 'odrl:assignee'\n    },\n    assigner: {\n      '@type': '@id',\n      '@id': 'odrl:assigner'\n    },\n    assigneeOf: {\n      '@type': '@id',\n      '@id': 'odrl:assigneeOf'\n    },\n    assignerOf: {\n      '@type': '@id',\n      '@id': 'odrl:assignerOf'\n    },\n    attributedParty: {\n      '@type': '@id',\n      '@id': 'odrl:attributedParty'\n    },\n    attributingParty: {\n      '@type': '@id',\n      '@id': 'odrl:attributingParty'\n    },\n    compensatedParty: {\n      '@type': '@id',\n      '@id': 'odrl:compensatedParty'\n    },\n    compensatingParty: {\n      '@type': '@id',\n      '@id': 'odrl:compensatingParty'\n    },\n    consentingParty: {\n      '@type': '@id',\n      '@id': 'odrl:consentingParty'\n    },\n    consentedParty: {\n      '@type': '@id',\n      '@id': 'odrl:consentedParty'\n    },\n    informedParty: {\n      '@type': '@id',\n      '@id': 'odrl:informedParty'\n    },\n    informingParty: {\n      '@type': '@id',\n      '@id': 'odrl:informingParty'\n    },\n    trackingParty: {\n      '@type': '@id',\n      '@id': 'odrl:trackingParty'\n    },\n    trackedParty: {\n      '@type': '@id',\n      '@id': 'odrl:trackedParty'\n    },\n    contractingParty: {\n      '@type': '@id',\n      '@id': 'odrl:contractingParty'\n    },\n    contractedParty: {\n      '@type': '@id',\n      '@id': 'odrl:contractedParty'\n    },\n    Action: 'odrl:Action',\n    action: {\n      '@type': '@vocab',\n      '@id': 'odrl:action'\n    },\n    includedIn: {\n      '@type': '@id',\n      '@id': 'odrl:includedIn'\n    },\n    implies: {\n      '@type': '@id',\n      '@id': 'odrl:implies'\n    },\n    Permission: 'odrl:Permission',\n    permission: {\n      '@type': '@id',\n      '@id': 'odrl:permission'\n    },\n    Prohibition: 'odrl:Prohibition',\n    prohibition: {\n      '@type': '@id',\n      '@id': 'odrl:prohibition'\n    },\n    obligation: {\n      '@type': '@id',\n      '@id': 'odrl:obligation'\n    },\n    use: 'odrl:use',\n    grantUse: 'odrl:grantUse',\n    aggregate: 'odrl:aggregate',\n    annotate: 'odrl:annotate',\n    anonymize: 'odrl:anonymize',\n    archive: 'odrl:archive',\n    concurrentUse: 'odrl:concurrentUse',\n    derive: 'odrl:derive',\n    digitize: 'odrl:digitize',\n    display: 'odrl:display',\n    distribute: 'odrl:distribute',\n    execute: 'odrl:execute',\n    extract: 'odrl:extract',\n    give: 'odrl:give',\n    index: 'odrl:index',\n    install: 'odrl:install',\n    modify: 'odrl:modify',\n    move: 'odrl:move',\n    play: 'odrl:play',\n    present: 'odrl:present',\n    print: 'odrl:print',\n    read: 'odrl:read',\n    reproduce: 'odrl:reproduce',\n    sell: 'odrl:sell',\n    stream: 'odrl:stream',\n    textToSpeech: 'odrl:textToSpeech',\n    transfer: 'odrl:transfer',\n    transform: 'odrl:transform',\n    translate: 'odrl:translate',\n    Duty: 'odrl:Duty',\n    duty: {\n      '@type': '@id',\n      '@id': 'odrl:duty'\n    },\n    consequence: {\n      '@type': '@id',\n      '@id': 'odrl:consequence'\n    },\n    remedy: {\n      '@type': '@id',\n      '@id': 'odrl:remedy'\n    },\n    acceptTracking: 'odrl:acceptTracking',\n    attribute: 'odrl:attribute',\n    compensate: 'odrl:compensate',\n    delete: 'odrl:delete',\n    ensureExclusivity: 'odrl:ensureExclusivity',\n    include: 'odrl:include',\n    inform: 'odrl:inform',\n    nextPolicy: 'odrl:nextPolicy',\n    obtainConsent: 'odrl:obtainConsent',\n    reviewPolicy: 'odrl:reviewPolicy',\n    uninstall: 'odrl:uninstall',\n    watermark: 'odrl:watermark',\n    Constraint: 'odrl:Constraint',\n    LogicalConstraint: 'odrl:LogicalConstraint',\n    constraint: {\n      '@type': '@id',\n      '@id': 'odrl:constraint'\n    },\n    refinement: {\n      '@type': '@id',\n      '@id': 'odrl:refinement'\n    },\n    Operator: 'odrl:Operator',\n    operator: {\n      '@type': '@vocab',\n      '@id': 'odrl:operator'\n    },\n    RightOperand: 'odrl:RightOperand',\n    rightOperand: 'odrl:rightOperand',\n    rightOperandReference: {\n      '@type': 'xsd:anyURI',\n      '@id': 'odrl:rightOperandReference'\n    },\n    LeftOperand: 'odrl:LeftOperand',\n    leftOperand: {\n      '@type': '@vocab',\n      '@id': 'odrl:leftOperand'\n    },\n    unit: 'odrl:unit',\n    dataType: {\n      '@type': 'xsd:anyType',\n      '@id': 'odrl:datatype'\n    },\n    status: 'odrl:status',\n    absolutePosition: 'odrl:absolutePosition',\n    absoluteSpatialPosition: 'odrl:absoluteSpatialPosition',\n    absoluteTemporalPosition: 'odrl:absoluteTemporalPosition',\n    absoluteSize: 'odrl:absoluteSize',\n    count: 'odrl:count',\n    dateTime: 'odrl:dateTime',\n    delayPeriod: 'odrl:delayPeriod',\n    deliveryChannel: 'odrl:deliveryChannel',\n    elapsedTime: 'odrl:elapsedTime',\n    event: 'odrl:event',\n    fileFormat: 'odrl:fileFormat',\n    industry: 'odrl:industry:',\n    language: 'odrl:language',\n    media: 'odrl:media',\n    meteredTime: 'odrl:meteredTime',\n    payAmount: 'odrl:payAmount',\n    percentage: 'odrl:percentage',\n    product: 'odrl:product',\n    purpose: 'odrl:purpose',\n    recipient: 'odrl:recipient',\n    relativePosition: 'odrl:relativePosition',\n    relativeSpatialPosition: 'odrl:relativeSpatialPosition',\n    relativeTemporalPosition: 'odrl:relativeTemporalPosition',\n    relativeSize: 'odrl:relativeSize',\n    resolution: 'odrl:resolution',\n    spatial: 'odrl:spatial',\n    spatialCoordinates: 'odrl:spatialCoordinates',\n    systemDevice: 'odrl:systemDevice',\n    timeInterval: 'odrl:timeInterval',\n    unitOfCount: 'odrl:unitOfCount',\n    version: 'odrl:version',\n    virtualLocation: 'odrl:virtualLocation',\n    eq: 'odrl:eq',\n    gt: 'odrl:gt',\n    gteq: 'odrl:gteq',\n    lt: 'odrl:lt',\n    lteq: 'odrl:lteq',\n    neq: 'odrl:neg',\n    isA: 'odrl:isA',\n    hasPart: 'odrl:hasPart',\n    isPartOf: 'odrl:isPartOf',\n    isAllOf: 'odrl:isAllOf',\n    isAnyOf: 'odrl:isAnyOf',\n    isNoneOf: 'odrl:isNoneOf',\n    or: 'odrl:or',\n    xone: 'odrl:xone',\n    and: 'odrl:and',\n    andSequence: 'odrl:andSequence',\n    policyUsage: 'odrl:policyUsage'\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/odrl-context/js/context.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/odrl-context/js/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@digitalbazaar/odrl-context/js/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst context = __webpack_require__(/*! ./context.js */ \"./node_modules/@digitalbazaar/odrl-context/js/context.js\");\nconst constants = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/odrl-context/js/constants.js\");\nconst {CONTEXT_URL_V1} = constants;\n\nconst contexts = new Map();\ncontexts.set(CONTEXT_URL_V1, context);\n\nmodule.exports = {\n  constants,\n  contexts,\n  CONTEXT_URL_V1,\n  CONTEXT_V1: context\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/odrl-context/js/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/security-context/dist/context.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/security-context/dist/context.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT: () => (/* binding */ context_3),\n/* harmony export */   CONTEXT_URL: () => (/* binding */ context_4),\n/* harmony export */   SECURITY_CONTEXT_V1_URL: () => (/* binding */ context_5),\n/* harmony export */   SECURITY_CONTEXT_V2_URL: () => (/* binding */ context_6),\n/* harmony export */   constants: () => (/* binding */ context_2),\n/* harmony export */   contexts: () => (/* binding */ context_1),\n/* harmony export */   \"default\": () => (/* binding */ context$1)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n!function(e,t){for(var i in t)e[i]=t[i];}(exports,function(e){var t={};function i(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,i),a.l=!0,a.exports}return i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r});},i.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0});},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var a in e)i.d(r,a,function(t){return e[t]}.bind(null,a));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,\"a\",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p=\"\",i(i.s=0)}([function(e,t,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const r=i(1),a=i(2),c=i(3),{CONTEXT_URL:n,SECURITY_CONTEXT_V1_URL:o,SECURITY_CONTEXT_V2_URL:s}=c,p=new Map;p.set(o,r),p.set(s,a),e.exports={constants:c,contexts:p,SECURITY_CONTEXT_V1_URL:o,SECURITY_CONTEXT_V2_URL:s,CONTEXT_URL:n,CONTEXT:a};},function(e,t,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */e.exports={\"@context\":{id:\"@id\",type:\"@type\",dc:\"http://purl.org/dc/terms/\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",EcdsaKoblitzSignature2016:\"sec:EcdsaKoblitzSignature2016\",Ed25519Signature2018:\"sec:Ed25519Signature2018\",EncryptedMessage:\"sec:EncryptedMessage\",GraphSignature2012:\"sec:GraphSignature2012\",LinkedDataSignature2015:\"sec:LinkedDataSignature2015\",LinkedDataSignature2016:\"sec:LinkedDataSignature2016\",CryptographicKey:\"sec:Key\",authenticationTag:\"sec:authenticationTag\",canonicalizationAlgorithm:\"sec:canonicalizationAlgorithm\",cipherAlgorithm:\"sec:cipherAlgorithm\",cipherData:\"sec:cipherData\",cipherKey:\"sec:cipherKey\",created:{\"@id\":\"dc:created\",\"@type\":\"xsd:dateTime\"},creator:{\"@id\":\"dc:creator\",\"@type\":\"@id\"},digestAlgorithm:\"sec:digestAlgorithm\",digestValue:\"sec:digestValue\",domain:\"sec:domain\",encryptionKey:\"sec:encryptionKey\",expiration:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},initializationVector:\"sec:initializationVector\",iterationCount:\"sec:iterationCount\",nonce:\"sec:nonce\",normalizationAlgorithm:\"sec:normalizationAlgorithm\",owner:{\"@id\":\"sec:owner\",\"@type\":\"@id\"},password:\"sec:password\",privateKey:{\"@id\":\"sec:privateKey\",\"@type\":\"@id\"},privateKeyPem:\"sec:privateKeyPem\",publicKey:{\"@id\":\"sec:publicKey\",\"@type\":\"@id\"},publicKeyBase58:\"sec:publicKeyBase58\",publicKeyPem:\"sec:publicKeyPem\",publicKeyWif:\"sec:publicKeyWif\",publicKeyService:{\"@id\":\"sec:publicKeyService\",\"@type\":\"@id\"},revoked:{\"@id\":\"sec:revoked\",\"@type\":\"xsd:dateTime\"},salt:\"sec:salt\",signature:\"sec:signature\",signatureAlgorithm:\"sec:signingAlgorithm\",signatureValue:\"sec:signatureValue\"}};},function(e,t,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */e.exports={\"@context\":[{\"@version\":1.1},\"https://w3id.org/security/v1\",{AesKeyWrappingKey2019:\"sec:AesKeyWrappingKey2019\",DeleteKeyOperation:\"sec:DeleteKeyOperation\",DeriveSecretOperation:\"sec:DeriveSecretOperation\",EcdsaSecp256k1Signature2019:\"sec:EcdsaSecp256k1Signature2019\",EcdsaSecp256r1Signature2019:\"sec:EcdsaSecp256r1Signature2019\",EcdsaSecp256k1VerificationKey2019:\"sec:EcdsaSecp256k1VerificationKey2019\",EcdsaSecp256r1VerificationKey2019:\"sec:EcdsaSecp256r1VerificationKey2019\",Ed25519Signature2018:\"sec:Ed25519Signature2018\",Ed25519VerificationKey2018:\"sec:Ed25519VerificationKey2018\",EquihashProof2018:\"sec:EquihashProof2018\",ExportKeyOperation:\"sec:ExportKeyOperation\",GenerateKeyOperation:\"sec:GenerateKeyOperation\",KmsOperation:\"sec:KmsOperation\",RevokeKeyOperation:\"sec:RevokeKeyOperation\",RsaSignature2018:\"sec:RsaSignature2018\",RsaVerificationKey2018:\"sec:RsaVerificationKey2018\",Sha256HmacKey2019:\"sec:Sha256HmacKey2019\",SignOperation:\"sec:SignOperation\",UnwrapKeyOperation:\"sec:UnwrapKeyOperation\",VerifyOperation:\"sec:VerifyOperation\",WrapKeyOperation:\"sec:WrapKeyOperation\",X25519KeyAgreementKey2019:\"sec:X25519KeyAgreementKey2019\",allowedAction:\"sec:allowedAction\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capability:{\"@id\":\"sec:capability\",\"@type\":\"@id\"},capabilityAction:\"sec:capabilityAction\",capabilityChain:{\"@id\":\"sec:capabilityChain\",\"@type\":\"@id\",\"@container\":\"@list\"},capabilityDelegation:{\"@id\":\"sec:capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"sec:capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},caveat:{\"@id\":\"sec:caveat\",\"@type\":\"@id\",\"@container\":\"@set\"},challenge:\"sec:challenge\",ciphertext:\"sec:ciphertext\",controller:{\"@id\":\"sec:controller\",\"@type\":\"@id\"},delegator:{\"@id\":\"sec:delegator\",\"@type\":\"@id\"},equihashParameterK:{\"@id\":\"sec:equihashParameterK\",\"@type\":\"xsd:integer\"},equihashParameterN:{\"@id\":\"sec:equihashParameterN\",\"@type\":\"xsd:integer\"},invocationTarget:{\"@id\":\"sec:invocationTarget\",\"@type\":\"@id\"},invoker:{\"@id\":\"sec:invoker\",\"@type\":\"@id\"},jws:\"sec:jws\",keyAgreement:{\"@id\":\"sec:keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},kmsModule:{\"@id\":\"sec:kmsModule\"},parentCapability:{\"@id\":\"sec:parentCapability\",\"@type\":\"@id\"},plaintext:\"sec:plaintext\",proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\"},proofValue:\"sec:proofValue\",referenceId:\"sec:referenceId\",unwrappedKey:\"sec:unwrappedKey\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"},verifyData:\"sec:verifyData\",wrappedKey:\"sec:wrappedKey\"}]};},function(e,t,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */e.exports={SECURITY_CONTEXT_V1_URL:\"https://w3id.org/security/v1\",SECURITY_CONTEXT_V2_URL:\"https://w3id.org/security/v2\",CONTEXT_URL:\"https://w3id.org/security/v2\"};}]));\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.SECURITY_CONTEXT_V1_URL;\nvar context_6 = context.SECURITY_CONTEXT_V2_URL;\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/security-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/canonicalize/lib/canonicalize.js":
/*!*******************************************************!*\
  !*** ./node_modules/canonicalize/lib/canonicalize.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("/* jshint esversion: 6 */\n/* jslint node: true */\n\n\nmodule.exports = function serialize (object) {\n  if (object === null || typeof object !== 'object' || object.toJSON != null) {\n    return JSON.stringify(object);\n  }\n\n  if (Array.isArray(object)) {\n    return '[' + object.reduce((t, cv, ci) => {\n      const comma = ci === 0 ? '' : ',';\n      const value = cv === undefined || typeof cv === 'symbol' ? null : cv;\n      return t + comma + serialize(value);\n    }, '') + ']';\n  }\n\n  return '{' + Object.keys(object).sort().reduce((t, cv, ci) => {\n    if (object[cv] === undefined ||\n        typeof object[cv] === 'symbol') {\n      return t;\n    }\n    const comma = t.length === 0 ? '' : ',';\n    return t + comma + serialize(cv) + ':' + serialize(object[cv]);\n  }, '') + '}';\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/canonicalize/lib/canonicalize.js?");

/***/ }),

/***/ "./node_modules/credentials-context/dist/context.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/credentials-context/dist/context.esm.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT: () => (/* binding */ context_3),\n/* harmony export */   CONTEXT_URL: () => (/* binding */ context_4),\n/* harmony export */   CONTEXT_URL_V1: () => (/* binding */ context_5),\n/* harmony export */   CREDENTIALS_CONTEXT_V1_URL: () => (/* binding */ context_6),\n/* harmony export */   constants: () => (/* binding */ context_2),\n/* harmony export */   contexts: () => (/* binding */ context_1),\n/* harmony export */   \"default\": () => (/* binding */ context$1)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n/*! For license information please see context.js.LICENSE.txt */\n(()=>{var e={717:e=>{e.exports={CONTEXT_FILENAME:\"credentials-v1.jsonld\",CONTEXT_URL:\"https://www.w3.org/2018/credentials/v1\",CREDENTIALS_CONTEXT_V1_URL:\"https://www.w3.org/2018/credentials/v1\"};},869:e=>{e.exports={\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",VerifiableCredential:{\"@id\":\"https://www.w3.org/2018/credentials#VerifiableCredential\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",credentialSchema:{\"@id\":\"cred:credentialSchema\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",JsonSchemaValidator2018:\"cred:JsonSchemaValidator2018\"}},credentialStatus:{\"@id\":\"cred:credentialStatus\",\"@type\":\"@id\"},credentialSubject:{\"@id\":\"cred:credentialSubject\",\"@type\":\"@id\"},evidence:{\"@id\":\"cred:evidence\",\"@type\":\"@id\"},expirationDate:{\"@id\":\"cred:expirationDate\",\"@type\":\"xsd:dateTime\"},holder:{\"@id\":\"cred:holder\",\"@type\":\"@id\"},issued:{\"@id\":\"cred:issued\",\"@type\":\"xsd:dateTime\"},issuer:{\"@id\":\"cred:issuer\",\"@type\":\"@id\"},issuanceDate:{\"@id\":\"cred:issuanceDate\",\"@type\":\"xsd:dateTime\"},proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},refreshService:{\"@id\":\"cred:refreshService\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",ManualRefreshService2018:\"cred:ManualRefreshService2018\"}},termsOfUse:{\"@id\":\"cred:termsOfUse\",\"@type\":\"@id\"},validFrom:{\"@id\":\"cred:validFrom\",\"@type\":\"xsd:dateTime\"},validUntil:{\"@id\":\"cred:validUntil\",\"@type\":\"xsd:dateTime\"}}},VerifiablePresentation:{\"@id\":\"https://www.w3.org/2018/credentials#VerifiablePresentation\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",cred:\"https://www.w3.org/2018/credentials#\",sec:\"https://w3id.org/security#\",holder:{\"@id\":\"cred:holder\",\"@type\":\"@id\"},proof:{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},verifiableCredential:{\"@id\":\"cred:verifiableCredential\",\"@type\":\"@id\",\"@container\":\"@graph\"}}},EcdsaSecp256k1Signature2019:{\"@id\":\"https://w3id.org/security#EcdsaSecp256k1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},EcdsaSecp256r1Signature2019:{\"@id\":\"https://w3id.org/security#EcdsaSecp256r1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},Ed25519Signature2018:{\"@id\":\"https://w3id.org/security#Ed25519Signature2018\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",xsd:\"http://www.w3.org/2001/XMLSchema#\",challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},RsaSignature2018:{\"@id\":\"https://w3id.org/security#RsaSignature2018\",\"@context\":{\"@version\":1.1,\"@protected\":!0,challenge:\"sec:challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},domain:\"sec:domain\",expires:{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},jws:\"sec:jws\",nonce:\"sec:nonce\",proofPurpose:{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":!0,id:\"@id\",type:\"@type\",sec:\"https://w3id.org/security#\",assertionMethod:{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:\"sec:proofValue\",verificationMethod:{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"}}};},858:(e,t,i)=>{const{CONTEXT_URL:d}=i(717),r=i(869);e.exports={documentLoader(e){if(e!==d)throw new Error(`Loading document \"${e}\" is not allowed.`);return {contextUrl:null,document:r,documentUrl:e}}};},243:(e,t,i)=>{const d=i(869),r=i(717),{documentLoader:o}=i(858),{CONTEXT_URL:c}=r,s=new Map;s.set(r.CONTEXT_URL,d),e.exports={constants:r,contexts:s,documentLoader:o,CONTEXT_URL:c,CREDENTIALS_CONTEXT_V1_URL:c,CONTEXT_URL_V1:c,CONTEXT:d};}},t={},i=function i(d){var r=t[d];if(void 0!==r)return r.exports;var o=t[d]={exports:{}};return e[d](o,o.exports,i),o.exports}(243),d=exports;for(var r in i)d[r]=i[r];i.__esModule&&Object.defineProperty(d,\"__esModule\",{value:!0});})();\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.CONTEXT_URL_V1;\nvar context_6 = context.CREDENTIALS_CONTEXT_V1_URL;\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/credentials-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/ed25519-signature-2018-context/dist/context.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ed25519-signature-2018-context/dist/context.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT: () => (/* binding */ context_3),\n/* harmony export */   CONTEXT_URL: () => (/* binding */ context_4),\n/* harmony export */   appContextMap: () => (/* binding */ context_5),\n/* harmony export */   constants: () => (/* binding */ context_2),\n/* harmony export */   contexts: () => (/* binding */ context_1),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   documentLoader: () => (/* binding */ context_6)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n!function(t,e){for(var i in e)t[i]=e[i];}(exports,function(t){var e={};function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)i.d(r,o,function(e){return t[e]}.bind(null,o));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=2)}([function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={\"@context\":{id:\"@id\",type:\"@type\",\"@protected\":!0,proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},Ed25519VerificationKey2018:{\"@id\":\"https://w3id.org/security#Ed25519VerificationKey2018\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",controller:{\"@id\":\"https://w3id.org/security#controller\",\"@type\":\"@id\"},revoked:{\"@id\":\"https://w3id.org/security#revoked\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},publicKeyBase58:{\"@id\":\"https://w3id.org/security#publicKeyBase58\"}}},Ed25519Signature2018:{\"@id\":\"https://w3id.org/security#Ed25519Signature2018\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",challenge:\"https://w3id.org/security#challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},domain:\"https://w3id.org/security#domain\",expires:{\"@id\":\"https://w3id.org/security#expiration\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},nonce:\"https://w3id.org/security#nonce\",proofPurpose:{\"@id\":\"https://w3id.org/security#proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",assertionMethod:{\"@id\":\"https://w3id.org/security#assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"https://w3id.org/security#authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"https://w3id.org/security#capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityDelegation:{\"@id\":\"https://w3id.org/security#capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},keyAgreement:{\"@id\":\"https://w3id.org/security#keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},jws:{\"@id\":\"https://w3id.org/security#jws\"},verificationMethod:{\"@id\":\"https://w3id.org/security#verificationMethod\",\"@type\":\"@id\"}}}}};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={CONTEXT_FILENAME:\"ed25519-signature-2018-v1.jsonld\",CONTEXT_URL:\"https://w3id.org/security/suites/ed25519-2018/v1\",CBORLD_CODEC_VALUE:19};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const r=i(0),o=i(1),{documentLoader:n}=i(3),{CONTEXT_URL:d,CBORLD_CODEC_VALUE:c}=o,s=new Map;s.set(d,r);const p=new Map;p.set(d,c),t.exports={constants:o,contexts:s,appContextMap:p,documentLoader:n,CONTEXT_URL:d,CONTEXT:r};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const{CONTEXT_URL:r}=i(1),o=i(0);t.exports={documentLoader(t){if(t!==r)throw new Error(`Loading document \"${t}\" is not allowed.`);return {contextUrl:null,document:o,documentUrl:t}}};}]));\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.appContextMap;\nvar context_6 = context.documentLoader;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (context$1);\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/ed25519-signature-2018-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/ed25519-signature-2020-context/dist/context.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ed25519-signature-2020-context/dist/context.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT: () => (/* binding */ context_3),\n/* harmony export */   CONTEXT_URL: () => (/* binding */ context_4),\n/* harmony export */   appContextMap: () => (/* binding */ context_5),\n/* harmony export */   constants: () => (/* binding */ context_2),\n/* harmony export */   contexts: () => (/* binding */ context_1),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   documentLoader: () => (/* binding */ context_6)\n/* harmony export */ });\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar context = createCommonjsModule(function (module, exports) {\n!function(t,e){for(var i in e)t[i]=e[i];}(exports,function(t){var e={};function i(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=t,i.c=e,i.d=function(t,e,r){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r});},i.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0});},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&\"object\"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:t}),2&e&&\"string\"!=typeof t)for(var o in t)i.d(r,o,function(e){return t[e]}.bind(null,o));return r},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,\"a\",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p=\"\",i(i.s=2)}([function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={\"@context\":{id:\"@id\",type:\"@type\",\"@protected\":!0,proof:{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},Ed25519VerificationKey2020:{\"@id\":\"https://w3id.org/security#Ed25519VerificationKey2020\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",controller:{\"@id\":\"https://w3id.org/security#controller\",\"@type\":\"@id\"},revoked:{\"@id\":\"https://w3id.org/security#revoked\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},publicKeyMultibase:{\"@id\":\"https://w3id.org/security#publicKeyMultibase\",\"@type\":\"https://w3id.org/security#multibase\"}}},Ed25519Signature2020:{\"@id\":\"https://w3id.org/security#Ed25519Signature2020\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",challenge:\"https://w3id.org/security#challenge\",created:{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},domain:\"https://w3id.org/security#domain\",expires:{\"@id\":\"https://w3id.org/security#expiration\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},nonce:\"https://w3id.org/security#nonce\",proofPurpose:{\"@id\":\"https://w3id.org/security#proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@protected\":!0,id:\"@id\",type:\"@type\",assertionMethod:{\"@id\":\"https://w3id.org/security#assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},authentication:{\"@id\":\"https://w3id.org/security#authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityInvocation:{\"@id\":\"https://w3id.org/security#capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},capabilityDelegation:{\"@id\":\"https://w3id.org/security#capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},keyAgreement:{\"@id\":\"https://w3id.org/security#keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},proofValue:{\"@id\":\"https://w3id.org/security#proofValue\",\"@type\":\"https://w3id.org/security#multibase\"},verificationMethod:{\"@id\":\"https://w3id.org/security#verificationMethod\",\"@type\":\"@id\"}}}}};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */t.exports={CONTEXT_FILENAME:\"ed25519-signature-2020-v1.jsonld\",CONTEXT_URL:\"https://w3id.org/security/suites/ed25519-2020/v1\",CBORLD_CODEC_VALUE:20};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const r=i(0),o=i(1),{documentLoader:n}=i(3),{CONTEXT_URL:d,CBORLD_CODEC_VALUE:c}=o,s=new Map;s.set(o.CONTEXT_URL,r);const p=new Map;p.set(d,c),t.exports={constants:o,contexts:s,appContextMap:p,documentLoader:n,CONTEXT_URL:d,CONTEXT:r};},function(t,e,i){/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */const{CONTEXT_URL:r}=i(1),o=i(0);t.exports={documentLoader(t){if(t!==r)throw new Error(`Loading document \"${t}\" is not allowed.`);return {contextUrl:null,document:o,documentUrl:t}}};}]));\n});\n\nvar context$1 = unwrapExports(context);\nvar context_1 = context.contexts;\nvar context_2 = context.constants;\nvar context_3 = context.CONTEXT;\nvar context_4 = context.CONTEXT_URL;\nvar context_5 = context.appContextMap;\nvar context_6 = context.documentLoader;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (context$1);\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/ed25519-signature-2020-context/dist/context.esm.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/ProofSet.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/ProofSet.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst {extendContextLoader, strictDocumentLoader} = __webpack_require__(/*! ./documentLoader */ \"./node_modules/jsonld-signatures/lib/documentLoader.js\");\nconst {serializeError} = __webpack_require__(/*! serialize-error */ \"./node_modules/serialize-error/index.js\");\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new proof\n    const proof = await suite.createProof({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    jsonld.addValue(document, 'proof', proof);\n\n    return document;\n  }\n\n  /**\n   * Derives a new Linked Data document with a new `proof` from an existing\n   * document with an existing proof set.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document from which to derive a proof.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will derive the new document and new `proof`.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the new document, with a new\n   *   top-level `proof` property.\n   */\n  async derive(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new document and proof\n    const newDocument = await suite.derive({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    return newDocument;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {...document};\n\n      // get proofs from document\n      const proofSet = _getProofs({document});\n      if(proofSet.length === 0) {\n        // no possible matches\n        throw new Error('No matching proofs found in the given document.');\n      }\n      // clear proofs from shallow copy\n      delete document.proof;\n\n      // verify proofs\n      const results = await _verify(\n        {document, suites, proofSet, purpose, documentLoader});\n      if(results.length === 0) {\n        const error = new Error(\n          'Did not verify any proofs; insufficient proofs matched the ' +\n          'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _makeSerializable(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nfunction _getProofs({document}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => ({\n    '@context': context,\n    ...proof\n  }));\n\n  return proofSet;\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose, documentLoader\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs, proofToSuite, purpose, proofSet, suites,\n    suiteMatchQueue, document, documentLoader\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if(purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {verificationMethod}) {\n          vm = verificationMethod;\n          return {valid: true};\n        }\n      };\n      const {verified, verificationMethod, error} = await suite.verifyProof(\n        {proof, document, purpose, proofSet, documentLoader});\n      if(!vm) {\n        vm = verificationMethod;\n      }\n      result = {proof, verified, verificationMethod: vm, error};\n    } catch(error) {\n      result = {proof, verified: false, error};\n    }\n\n    if(result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(\n    async ([purpose, proofs]) => {\n      for(const proof of proofs) {\n        const result = verifyResults.get(proof);\n        if(!result.verified) {\n          // if proof was not verified, so not bother validating purpose\n          continue;\n        }\n\n        // validate purpose\n        const {verificationMethod} = result;\n        const suite = proofToSuite.get(proof);\n        let purposeResult;\n        try {\n          purposeResult = await purpose.validate(proof, {\n            document, suite, verificationMethod, documentLoader\n          });\n        } catch(error) {\n          purposeResult = {valid: false, error};\n        }\n\n        // add `purposeResult` to verification result regardless of validity\n        // to ensure that all purposes are represented\n        if(result.purposeResult) {\n          if(Array.isArray(result.purposeResult)) {\n            result.purposeResult.push(purposeResult);\n          } else {\n            result.purposeResult = [result.purposeResult, purposeResult];\n          }\n        } else {\n          result.purposeResult = purposeResult;\n        }\n\n        if(!purposeResult.valid) {\n          // ensure error is serializable\n          _makeSerializable(purposeResult.error);\n\n          // if no top level error set yet, set it\n          if(!result.error) {\n            result.verified = false;\n            result.error = purposeResult.error;\n          }\n        }\n      }\n    }));\n\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _matchProofSet({\n  purposeToProofs, proofToSuite, purpose, proofSet, suites,\n  suiteMatchQueue, document, documentLoader\n}) {\n  for(const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if(!await purpose.match(proof, {document, documentLoader})) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for(const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if(!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if(!promise) {\n        promise = s.matchProof({proof, document, documentLoader});\n        matchingProofs.set(proof, promise);\n      }\n      if(await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n\n    if(matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if(matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/ProofSet.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/VerificationError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/VerificationError.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Used as an umbrella wrapper around multiple verification errors.\n */\nclass VerificationError extends Error {\n  /**\n   * @param {Error|Error[]} errors\n   */\n  constructor(errors) {\n    super('Verification error(s).');\n\n    this.name = 'VerificationError';\n    this.errors = [].concat(errors);\n  }\n}\nmodule.exports = VerificationError;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/VerificationError.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/constants.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  constants: securityConstants\n} = __webpack_require__(/*! @digitalbazaar/security-context */ \"./node_modules/@digitalbazaar/security-context/dist/context.esm.js\");\n\nmodule.exports = {\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/constants.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/contexts.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/contexts.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst {contexts: securityContexts} = __webpack_require__(/*! @digitalbazaar/security-context */ \"./node_modules/@digitalbazaar/security-context/dist/context.esm.js\");\n\nmodule.exports = new Map([\n  [constants.SECURITY_CONTEXT_V1_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)],\n  [constants.SECURITY_CONTEXT_V2_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)]\n]);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/contexts.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/documentLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/documentLoader.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/*eslint max-len: [\"error\", { \"ignoreComments\": true }]*/\n\n// load locally embedded contexts\nconst contexts = __webpack_require__(/*! ./contexts */ \"./node_modules/jsonld-signatures/lib/contexts.js\");\n\n/**\n * This is a utility module that provides a set of functions for using or\n * extending jsonld-signature's built-in JSON-LD document loader.\n * @see https://www.w3.org/TR/json-ld11-api/#loaddocumentcallback\n */\nconst api = {};\nmodule.exports = api;\n\napi.extendContextLoader = documentLoader => {\n  /**\n   * extendContextLoader extends another JSON-LD document loader.\n   * Given a document loader to extend, this method will return a\n   * new document loader that will first check for a URL in\n   * jsonld-signature's built-in context map and, if not found,\n   * it will fall back to using the passed document loader.\n   * This utility method can be used to ensure that any local,\n   * in-memory, immutable context documents provided by\n   * jsonld-signatures will be used prior to using another\n   * document loader to load other documents.\n   *\n   * @param {Function} documentLoader - A function that fetches a document.\n   * @see [node documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/node.js}\n   * @see [xhr documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/xhr.js}\n   *\n   * @returns {Function} A function that accepts a\n   * url then fetches a jsonld document.\n   */\n  return async url => {\n    const context = contexts.get(url);\n    if(context !== undefined) {\n      return {\n        contextUrl: null,\n        documentUrl: url,\n        document: context,\n        tag: 'static'\n      };\n    }\n    return documentLoader(url);\n  };\n};\n\napi.strictDocumentLoader = api.extendContextLoader(url => {\n  /**\n   * strictDocumentLoader extends extendContextLoader.\n   * ensuring no network calls are made so the only documents\n   * available are the built-in contexts.\n   * @see documentLoader.extendContextLoader\n   *\n   * @param {string} url - A valid url to a jsonld context.\n   *\n   * @throws {Error} Always throws an error if the\n   * url is not in the context map\n   * (i.e., not a URL for a locally available context document).\n   * @return {Object} A JSON-LD RemoteDocument\n   * that is a copy of a locally available context.\n   */\n  throw new Error(`${url} not found.`);\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/documentLoader.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/jsonld-signatures.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/jsonld-signatures.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2010-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = __webpack_require__(/*! ./ProofSet */ \"./node_modules/jsonld-signatures/lib/ProofSet.js\");\nconst VerificationError = __webpack_require__(/*! ./VerificationError */ \"./node_modules/jsonld-signatures/lib/VerificationError.js\");\n\n/**\n * Derives a proof from the provided document, resulting in a new document\n * with a new `proof` on it as generated by the given cryptographic suite.\n *\n * @param {object} document - The JSON-LD document from which to derive a\n *   new proof.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite, containing private key material, with which to sign\n *   the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.derive = async function derive(document, {\n  suite, purpose, documentLoader, addSuiteContext = true\n} = {}) {\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the\n  // `addSuiteContext` flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().derive(\n      document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"derive\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object} document - The JSON-LD document to be signed.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite with which to sign the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, addSuiteContext = true\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the `addSuiteContext`\n  // flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().add(document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object} document - The JSON-LD document with one or more proofs to be\n *   verified.\n *\n * @param {object} options - The options to use.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n *\n * @return {Promise<{verified: boolean, results: Array,\n *   error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = (__webpack_require__(/*! ./suites */ \"./node_modules/jsonld-signatures/lib/suites.js\").suites);\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = (__webpack_require__(/*! ./purposes */ \"./node_modules/jsonld-signatures/lib/purposes.js\").purposes);\n\n// expose document loader helpers\nObject.assign(api, __webpack_require__(/*! ./documentLoader */ \"./node_modules/jsonld-signatures/lib/documentLoader.js\"));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/jsonld-signatures.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.purposes = {\n  AssertionProofPurpose: __webpack_require__(/*! ./purposes/AssertionProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js\"),\n  AuthenticationProofPurpose: __webpack_require__(/*! ./purposes/AuthenticationProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js\"),\n  ControllerProofPurpose: __webpack_require__(/*! ./purposes/ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\"),\n  ProofPurpose: __webpack_require__(/*! ./purposes/ProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\")\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod', controller,\n    date, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AuthenticationProofPurpose extends\n  ControllerProofPurpose {\n  constructor({\n    term = 'authentication', controller,\n    challenge, date, domain, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n    if(typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      // check challenge\n      if(proof.challenge !== this.challenge) {\n        throw new Error('The challenge is not as expected; ' +\n          `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`);\n      }\n\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof = await super.update(\n      proof, {document, suite, documentLoader, expansionMap});\n    proof.challenge = this.challenge;\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst ProofPurpose = __webpack_require__(/*! ./ProofPurpose */ \"./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\");\n\n// DID documents can be specially optimized\nconst DID_CONTEXT_V1 = 'https://www.w3.org/ns/did/v1';\n// verification relationship terms that are known to appear in DID documents\nconst DID_VR_TERMS = [\n  'assertionMethod',\n  'authentication',\n  'capabilityInvocation',\n  'capabilityDelegation',\n  'keyAgreement',\n  'verificationMethod'\n];\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n    this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n      const {term, _termDefinedByDIDContext} = this;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        const {controller} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        }\n\n        // apply optimization to controller documents that are DID documents;\n        // if `term` is one of those defined by the DID context\n        let {document} = await documentLoader(controllerId);\n        const mustFrame = !(_termDefinedByDIDContext &&\n          document['@context'] === DID_CONTEXT_V1 ||\n          (Array.isArray(document['@context']) &&\n          document['@context'][0] === DID_CONTEXT_V1));\n        if(mustFrame) {\n          // Note: `expansionMap` is intentionally not passed; we can safely\n          // drop properties here and must allow for it\n          document = await jsonld.frame(document, {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // this term must be in the JSON-LD controller document or\n            // verification will fail\n            [term]: {\n              '@embed': '@never',\n              id: verificationId\n            }\n          }, {documentLoader, compactToRelative: false, safe: true});\n        }\n        result.controller = document;\n      }\n\n      const verificationMethods = jsonld.getValues(result.controller, term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {/*document, suite, verificationMethod,\n      documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {/*document, suite, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {/* document, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return proof.proofPurpose === this.term;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/sha256digest-browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/sha256digest-browser.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n/* eslint-env browser */\n\nconst crypto = self && (self.crypto || self.msCrypto);\n\nmodule.exports = {\n  /**\n   * Hashes a string of data using SHA-256.\n   *\n   * @param {string} string - the string to hash.\n   *\n   * @return {Uint8Array} the hash digest.\n   */\n  async sha256digest({string}) {\n    const bytes = new TextEncoder().encode(string);\n    return new Uint8Array(\n      await crypto.subtle.digest('SHA-256', bytes)\n    );\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/sha256digest-browser.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites.js":
/*!******************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.suites = {\n  LinkedDataProof: __webpack_require__(/*! ./suites/LinkedDataProof */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\"),\n  LinkedDataSignature: __webpack_require__(/*! ./suites/LinkedDataSignature */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js\")\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    /* document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document from which to derive\n   *   a new document and proof.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the new document with a new\n   *   `proof` field.\n   */\n  async derive({\n    /* document, purpose, proofSet, documentLoader */\n  }) {\n    throw new Error('\"deriveProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    /* proof, document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to match.\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    return proof.type === this.type;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\nconst util = __webpack_require__(/*! ../util */ \"./node_modules/jsonld-signatures/lib/util.js\");\nconst {sha256digest} = __webpack_require__(/*! ../sha256digest */ \"./node_modules/jsonld-signatures/lib/sha256digest-browser.js\");\nconst LinkedDataProof = __webpack_require__(/*! ./LinkedDataProof */ \"./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\");\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   * @param {object} [options.canonizeOptions] - Options to pass to\n   *   canonize algorithm.\n   */\n  constructor({\n    type, proof, LDKeyClass, date, key, signer, verifier, useNativeCanonize,\n    canonizeOptions, contextUrl\n  } = {}) {\n    super({type});\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({key, signer, verifier});\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    this.canonizeOptions = canonizeOptions;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    document, purpose, proofSet, documentLoader, expansionMap\n  }) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof(\n      {document, proof, proofSet, purpose, documentLoader});\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData(\n      {document, proof, proofSet, documentLoader});\n\n    // sign data\n    proof = await this.sign({verifyData, document, proof, documentLoader});\n\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be updated.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, proofSet, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, proofSet, documentLoader, expansionMap});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      // do not resolve any relative URLs or terms, throw errors instead\n      base: null,\n      format: 'application/n-quads',\n      documentLoader,\n      // throw errors if any values would be dropped due to missing\n      // definitions or relative URLs\n      safe: true,\n      skipExpansion,\n      useNative: this.useNativeCanonize,\n      ...this.canonizeOptions\n    });\n  }\n\n  async canonizeProof(proof, {document, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false,\n      ...this.canonizeOptions\n    });\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed/verified.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({document, proof, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader, expansionMap})\n            .then(c14nDocument => sha256digest({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(\n        proof, {document, documentLoader, expansionMap})\n        .then(c14nProofOptions => sha256digest({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} document from which to derive a new document\n   *   and proof.\n   * @param proof {object}\n   * @param proofSet {Array}\n   * @param documentLoader {function}\n   *\n   * @returns {Promise<{object}>} The new document with `proof`.\n   */\n  async derive() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false, safe: true});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n        `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({key, signer, verifier}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if(key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if(typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if(typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if(!(vm.signer || vm.verifier)) {\n      throw new TypeError(\n        'The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = (signer && signer.id) ||\n      (verifier && verifier.id);\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n\n  if(vm.signer) {\n    if(typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if(vm.verifier) {\n    if(typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n\n  return vm;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js?");

/***/ }),

/***/ "./node_modules/jsonld-signatures/lib/util.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/util.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts the given date into W3C datetime format (eg: 2011-03-09T21:55:41Z).\n *\n * @param date the date to convert.\n *\n * @return the date in W3C datetime format.\n */\napi.w3cDate = date => {\n  if(date === undefined || date === null) {\n    date = new Date();\n  } else if(typeof date === 'number' || typeof date === 'string') {\n    date = new Date(date);\n  }\n  const str = date.toISOString();\n  return str.substr(0, str.length - 5) + 'Z';\n};\n\n/**\n * Concatenates two Uint8Arrays.\n *\n * @param b1 {Uint8Array}.\n * @param b2 {Uint8Array}.\n *\n * @return {Uint8Array} the result.\n */\napi.concat = (b1, b2) => {\n  const rval = new Uint8Array(b1.length + b2.length);\n  rval.set(b1, 0);\n  rval.set(b2, b1.length);\n  return rval;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld-signatures/lib/util.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/ContextResolver.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ContextResolver.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst {\n  asArray: _asArray\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst {prependBase} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst ResolvedContext = __webpack_require__(/*! ./ResolvedContext */ \"./node_modules/jsonld/lib/ResolvedContext.js\");\n\nconst MAX_CONTEXT_URLS = 10;\n\nmodule.exports = class ContextResolver {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  constructor({sharedCache}) {\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n\n  async resolve({\n    activeCtx, context, documentLoader, base, cycles = new Set()\n  }) {\n    // process `@context`\n    if(context && _isObject(context) && context['@context']) {\n      context = context['@context'];\n    }\n\n    // context is one or more contexts\n    context = _asArray(context);\n\n    // resolve each context in the array\n    const allResolved = [];\n    for(const ctx of context) {\n      if(_isString(ctx)) {\n        // see if `ctx` has been resolved before...\n        let resolved = this._get(ctx);\n        if(!resolved) {\n          // not resolved yet, resolve\n          resolved = await this._resolveRemoteContext(\n            {activeCtx, url: ctx, documentLoader, base, cycles});\n        }\n\n        // add to output and continue\n        if(_isArray(resolved)) {\n          allResolved.push(...resolved);\n        } else {\n          allResolved.push(resolved);\n        }\n        continue;\n      }\n      if(ctx === null) {\n        // handle `null` context, nothing to cache\n        allResolved.push(new ResolvedContext({document: null}));\n        continue;\n      }\n      if(!_isObject(ctx)) {\n        _throwInvalidLocalContext(context);\n      }\n      // context is an object, get/create `ResolvedContext` for it\n      const key = JSON.stringify(ctx);\n      let resolved = this._get(key);\n      if(!resolved) {\n        // create a new static `ResolvedContext` and cache it\n        resolved = new ResolvedContext({document: ctx});\n        this._cacheResolvedContext({key, resolved, tag: 'static'});\n      }\n      allResolved.push(resolved);\n    }\n\n    return allResolved;\n  }\n\n  _get(key) {\n    // get key from per operation cache; no `tag` is used with this cache so\n    // any retrieved context will always be the same during a single operation\n    let resolved = this.perOpCache.get(key);\n    if(!resolved) {\n      // see if the shared cache has a `static` entry for this URL\n      const tagMap = this.sharedCache.get(key);\n      if(tagMap) {\n        resolved = tagMap.get('static');\n        if(resolved) {\n          this.perOpCache.set(key, resolved);\n        }\n      }\n    }\n    return resolved;\n  }\n\n  _cacheResolvedContext({key, resolved, tag}) {\n    this.perOpCache.set(key, resolved);\n    if(tag !== undefined) {\n      let tagMap = this.sharedCache.get(key);\n      if(!tagMap) {\n        tagMap = new Map();\n        this.sharedCache.set(key, tagMap);\n      }\n      tagMap.set(tag, resolved);\n    }\n    return resolved;\n  }\n\n  async _resolveRemoteContext({activeCtx, url, documentLoader, base, cycles}) {\n    // resolve relative URL and fetch context\n    url = prependBase(base, url);\n    const {context, remoteDoc} = await this._fetchContext(\n      {activeCtx, url, documentLoader, cycles});\n\n    // update base according to remote document and resolve any relative URLs\n    base = remoteDoc.documentUrl || url;\n    _resolveContextUrls({context, base});\n\n    // resolve, cache, and return context\n    const resolved = await this.resolve(\n      {activeCtx, context, documentLoader, base, cycles});\n    this._cacheResolvedContext({key: url, resolved, tag: remoteDoc.tag});\n    return resolved;\n  }\n\n  async _fetchContext({activeCtx, url, documentLoader, cycles}) {\n    // check for max context URLs fetched during a resolve operation\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'loading remote context failed' :\n            'context overflow',\n          max: MAX_CONTEXT_URLS\n        });\n    }\n\n    // check for context URL cycle\n    // shortcut to avoid extra work that would eventually hit the max above\n    if(cycles.has(url)) {\n      throw new JsonLdError(\n        'Cyclical @context URLs detected.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'recursive context inclusion' :\n            'context overflow',\n          url\n        });\n    }\n\n    // track cycles\n    cycles.add(url);\n\n    let context;\n    let remoteDoc;\n\n    try {\n      remoteDoc = await documentLoader(url);\n      context = remoteDoc.document || null;\n      // parse string context as JSON\n      if(_isString(context)) {\n        context = JSON.parse(context);\n      }\n    } catch(e) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n        'Possible causes are an inaccessible URL perhaps due to ' +\n        'a same-origin policy (ensure the server uses CORS if you are ' +\n        'using client-side JavaScript), too many redirects, a ' +\n        'non-JSON response, or more than one HTTP Link Header was ' +\n        'provided for a remote context.',\n        'jsonld.InvalidUrl',\n        {code: 'loading remote context failed', url, cause: e});\n    }\n\n    // ensure ctx is an object\n    if(!_isObject(context)) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a JSON object. The ' +\n        'response was valid JSON, but it was not a JSON object.',\n        'jsonld.InvalidUrl', {code: 'invalid remote context', url});\n    }\n\n    // use empty context if no @context key is present\n    if(!('@context' in context)) {\n      context = {'@context': {}};\n    } else {\n      context = {'@context': context['@context']};\n    }\n\n    // append @context URL to context if given\n    if(remoteDoc.contextUrl) {\n      if(!_isArray(context['@context'])) {\n        context['@context'] = [context['@context']];\n      }\n      context['@context'].push(remoteDoc.contextUrl);\n    }\n\n    return {context, remoteDoc};\n  }\n};\n\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; @context must be an object.',\n    'jsonld.SyntaxError', {\n      code: 'invalid local context', context: ctx\n    });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls({context, base}) {\n  if(!context) {\n    return;\n  }\n\n  const ctx = context['@context'];\n\n  if(_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n\n  if(_isArray(ctx)) {\n    for(let i = 0; i < ctx.length; ++i) {\n      const element = ctx[i];\n      if(_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if(_isObject(element)) {\n        _resolveContextUrls({context: {'@context': element}, base});\n      }\n    }\n    return;\n  }\n\n  if(!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for(const term in ctx) {\n    _resolveContextUrls({context: ctx[term], base});\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/ContextResolver.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/JsonLdError.js":
/*!************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdError.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class JsonLdError extends Error {\n  /**\n   * Creates a JSON-LD Error.\n   *\n   * @param msg the error message.\n   * @param type the error type.\n   * @param details the error details.\n   */\n  constructor(\n    message = 'An unspecified JSON-LD error occurred.',\n    name = 'jsonld.Error',\n    details = {}) {\n    super(message);\n    this.name = name;\n    this.message = message;\n    this.details = details;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/JsonLdError.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/JsonLdProcessor.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdProcessor.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = jsonld => {\n  class JsonLdProcessor {\n    toString() {\n      return '[object JsonLdProcessor]';\n    }\n  }\n  Object.defineProperty(JsonLdProcessor, 'prototype', {\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: JsonLdProcessor\n  });\n\n  // The Web IDL test harness will check the number of parameters defined in\n  // the functions below. The number of parameters must exactly match the\n  // required (non-optional) parameters of the JsonLdProcessor interface as\n  // defined here:\n  // https://www.w3.org/TR/json-ld-api/#the-jsonldprocessor-interface\n\n  JsonLdProcessor.compact = function(input, ctx) {\n    if(arguments.length < 2) {\n      return Promise.reject(\n        new TypeError('Could not compact, too few arguments.'));\n    }\n    return jsonld.compact(input, ctx);\n  };\n  JsonLdProcessor.expand = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not expand, too few arguments.'));\n    }\n    return jsonld.expand(input);\n  };\n  JsonLdProcessor.flatten = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not flatten, too few arguments.'));\n    }\n    return jsonld.flatten(input);\n  };\n\n  return JsonLdProcessor;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/JsonLdProcessor.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/NQuads.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/NQuads.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// TODO: move `NQuads` to its own package\nmodule.exports = __webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\").NQuads;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/NQuads.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/RequestQueue.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonld/lib/RequestQueue.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class RequestQueue {\n  /**\n   * Creates a simple queue for requesting documents.\n   */\n  constructor() {\n    this._requests = {};\n  }\n\n  wrapLoader(loader) {\n    const self = this;\n    self._loader = loader;\n    return function(/* url */) {\n      return self.add.apply(self, arguments);\n    };\n  }\n\n  async add(url) {\n    let promise = this._requests[url];\n    if(promise) {\n      // URL already queued, wait for it to load\n      return Promise.resolve(promise);\n    }\n\n    // queue URL and load it\n    promise = this._requests[url] = this._loader(url);\n\n    try {\n      return await promise;\n    } finally {\n      delete this._requests[url];\n    }\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/RequestQueue.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/ResolvedContext.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ResolvedContext.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\n\nconst MAX_ACTIVE_CONTEXTS = 10;\n\nmodule.exports = class ResolvedContext {\n  /**\n   * Creates a ResolvedContext.\n   *\n   * @param document the context document.\n   */\n  constructor({document}) {\n    this.document = document;\n    // TODO: enable customization of processed context cache\n    // TODO: limit based on size of processed contexts vs. number of them\n    this.cache = new LRU({max: MAX_ACTIVE_CONTEXTS});\n  }\n\n  getProcessed(activeCtx) {\n    return this.cache.get(activeCtx);\n  }\n\n  setProcessed(activeCtx, processedCtx) {\n    this.cache.set(activeCtx, processedCtx);\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/ResolvedContext.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/compact.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/compact.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {}\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      const compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options\n      });\n      if(compacted === null) {\n        // FIXME: need event?\n        continue;\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        const _iri = _removeBase(_prependBase(base, activeCtx['@base']), iri);\n        return REGEX_KEYWORD.test(_iri) ? `./${_iri}` : _iri;\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/compact.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/jsonld/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst XSD = 'http://www.w3.org/2001/XMLSchema#';\n\nmodule.exports = {\n  // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.\n  LINK_HEADER_REL: 'http://www.w3.org/ns/json-ld#context',\n\n  LINK_HEADER_CONTEXT: 'http://www.w3.org/ns/json-ld#context',\n\n  RDF,\n  RDF_LIST: RDF + 'List',\n  RDF_FIRST: RDF + 'first',\n  RDF_REST: RDF + 'rest',\n  RDF_NIL: RDF + 'nil',\n  RDF_TYPE: RDF + 'type',\n  RDF_PLAIN_LITERAL: RDF + 'PlainLiteral',\n  RDF_XML_LITERAL: RDF + 'XMLLiteral',\n  RDF_JSON_LITERAL: RDF + 'JSON',\n  RDF_OBJECT: RDF + 'object',\n  RDF_LANGSTRING: RDF + 'langString',\n\n  XSD,\n  XSD_BOOLEAN: XSD + 'boolean',\n  XSD_DOUBLE: XSD + 'double',\n  XSD_INTEGER: XSD + 'integer',\n  XSD_STRING: XSD + 'string',\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/constants.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/context.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/context.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"./node_modules/jsonld/lib/events.js\");\n\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = async ({\n  activeCtx, localCtx, options,\n  propagate = true,\n  overrideProtected = false,\n  cycles = new Set()\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // event handler for capturing events to replay when using a cached context\n  const events = [];\n  const eventCaptureHandler = [\n    ({event, next}) => {\n      events.push(event);\n      next();\n    }\n  ];\n  // chain to original handler\n  if(options.eventHandler) {\n    eventCaptureHandler.push(options.eventHandler);\n  }\n  // store original options to use when replaying events\n  const originalOptions = options;\n  // shallow clone options with event capture handler\n  options = {...options, eventHandler: eventCaptureHandler};\n\n  // resolve contexts\n  const resolved = await options.contextResolver.resolve({\n    activeCtx,\n    context: localCtx,\n    documentLoader: options.documentLoader,\n    base: options.base\n  });\n\n  // override propagate if first resolved context has `@propagate`\n  if(_isObject(resolved[0].document) &&\n    typeof resolved[0].document['@propagate'] === 'boolean') {\n    // retrieve early, error checking done later\n    propagate = resolved[0].document['@propagate'];\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n\n  // track the previous context\n  // if not propagating, make sure rval has a previous context\n  if(!propagate && !rval.previousContext) {\n    // clone `rval` context before updating\n    rval = rval.clone();\n    rval.previousContext = activeCtx;\n  }\n\n  for(const resolvedContext of resolved) {\n    let {document: ctx} = resolvedContext;\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not allowing overrides (e.g. processing a property term scoped context)\n      if(!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {\n        throw new JsonLdError(\n          'Tried to nullify a context with protected terms outside of ' +\n          'a term definition.',\n          'jsonld.SyntaxError',\n          {code: 'invalid context nullification'});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      continue;\n    }\n\n    // get processed context from cache if available\n    const processed = resolvedContext.getProcessed(activeCtx);\n    if(processed) {\n      if(originalOptions.eventHandler) {\n        // replay events with original non-capturing options\n        for(const event of processed.events) {\n          _handleEvent({event, options: originalOptions});\n        }\n      }\n\n      rval = activeCtx = processed.context;\n      continue;\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `previousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.1\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode;\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null || _isAbsoluteIri(base)) {\n        // no action\n      } else if(_isRelativeIri(base)) {\n        base = prependBase(rval['@base'], base);\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        const vocab = _expandIri(rval, value, {vocab: true, base: true},\n          undefined, undefined, options);\n        if(!_isAbsoluteIri(vocab)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative @vocab reference',\n                level: 'warning',\n                message: 'Relative @vocab reference found.',\n                details: {\n                  vocab\n                }\n              },\n              options\n            });\n          }\n        }\n        rval['@vocab'] = vocab;\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        if(!value.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: value\n                }\n              },\n              options\n            });\n          }\n        }\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @direction\n    if('@direction' in ctx) {\n      const value = ctx['@direction'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @direction not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context member', context: ctx});\n      }\n      if(value === null) {\n        delete rval['@direction'];\n      } else if(value !== 'ltr' && value !== 'rtl') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@direction\" in a ' +\n          '@context must be null, \"ltr\", or \"rtl\".',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', context: ctx});\n      } else {\n        rval['@direction'] = value;\n      }\n      defined.set('@direction', true);\n    }\n\n    // handle @propagate\n    // note: we've already extracted it, here we just do error checking\n    if('@propagate' in ctx) {\n      const value = ctx['@propagate'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(typeof value !== 'boolean') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate value must be a boolean.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @propagate value', context: localCtx});\n      }\n      defined.set('@propagate', true);\n    }\n\n    // handle @import\n    if('@import' in ctx) {\n      const value = ctx['@import'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @import value', context: localCtx});\n      }\n\n      // resolve contexts\n      const resolvedImport = await options.contextResolver.resolve({\n        activeCtx,\n        context: value,\n        documentLoader: options.documentLoader,\n        base: options.base\n      });\n      if(resolvedImport.length !== 1) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must reference a single context.',\n          'jsonld.SyntaxError',\n          {code: 'invalid remote context', context: localCtx});\n      }\n      const processedImport = resolvedImport[0].getProcessed(activeCtx);\n      if(processedImport) {\n        // Note: if the same context were used in this active context\n        // as a reference context, then processed_input might not\n        // be a dict.\n        ctx = processedImport;\n      } else {\n        const importCtx = resolvedImport[0].document;\n        if('@import' in importCtx) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax: ' +\n            'imported context must not include @import.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context entry', context: localCtx});\n        }\n\n        // merge ctx into importCtx and replace rval with the result\n        for(const key in importCtx) {\n          if(!ctx.hasOwnProperty(key)) {\n            ctx[key] = importCtx[key];\n          }\n        }\n\n        // Note: this could potenially conflict if the import\n        // were used in the same active context as a referenced\n        // context and an import. In this case, we\n        // could override the cached result, but seems unlikely.\n        resolvedImport[0].setProcessed(activeCtx, ctx);\n      }\n\n      defined.set('@import', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition({\n        activeCtx: rval,\n        localCtx: ctx,\n        term: key,\n        defined,\n        options,\n        overrideProtected\n      });\n\n      if(_isObject(ctx[key]) && '@context' in ctx[key]) {\n        const keyCtx = ctx[key]['@context'];\n        let process = true;\n        if(_isString(keyCtx)) {\n          const url = prependBase(options.base, keyCtx);\n          // track processed contexts to avoid scoped context recursion\n          if(cycles.has(url)) {\n            process = false;\n          } else {\n            cycles.add(url);\n          }\n        }\n        // parse context to validate\n        if(process) {\n          try {\n            await api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[key]['@context'],\n              overrideProtected: true,\n              options,\n              cycles\n            });\n          } catch(e) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; invalid scoped context.',\n              'jsonld.SyntaxError',\n              {\n                code: 'invalid scoped context',\n                context: ctx[key]['@context'],\n                term: key\n              });\n          }\n        }\n      }\n    }\n\n    // cache processed result\n    resolvedContext.setProcessed(activeCtx, {\n      context: rval,\n      events\n    });\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = ({\n  activeCtx,\n  localCtx,\n  term,\n  defined,\n  options,\n  overrideProtected = false,\n}) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if(term === '@type' &&\n     _isObject(value) &&\n     (value['@container'] || '@set') === '@set' &&\n     api.processingMode(activeCtx, 1.1)) {\n\n    const validKeys = ['@container', '@id', '@protected'];\n    const keys = Object.keys(value);\n    if(keys.length === 0 || keys.some(k => !validKeys.includes(k))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords cannot be overridden.',\n        'jsonld.SyntaxError',\n        {code: 'keyword redefinition', context: localCtx, term});\n    }\n  } else if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  } else if(term.match(REGEX_KEYWORD)) {\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'reserved term',\n          level: 'warning',\n          message:\n            'Terms beginning with \"@\" are ' +\n            'reserved for future use and dropped.',\n          details: {\n            term\n          }\n        },\n        options\n      });\n    }\n    return;\n  } else if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push(\n      '@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon > 0);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    if(reverse.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @reverse value',\n            level: 'warning',\n            message:\n              '@reverse values beginning with \"@\" are ' +\n              'reserved for future use and dropped.',\n            details: {\n              reverse\n            }\n          },\n          options\n        });\n      }\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(id && !_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if(!api.isKeyword(id) && id.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message:\n              '@id values beginning with \"@\" are ' +\n              'reserved for future use and dropped.',\n            details: {\n              id\n            }\n          },\n          options\n        });\n      }\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n\n      // if term has the form of an IRI it must map the same\n      if(term.match(/(?::[^:])|\\//)) {\n        const termDefined = new Map(defined).set(term, true);\n        const termIri = _expandIri(\n          activeCtx, term, {vocab: true, base: false},\n          localCtx, termDefined, options);\n        if(termIri !== id) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; term in form of IRI must ' +\n            'expand to definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid IRI mapping', context: localCtx});\n        }\n      }\n\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (simpleTerm &&\n        !mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/) !== null);\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx, localCtx, term: prefix, defined, options\n        });\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if(term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if((type === '@json' || type === '@none')) {\n      if(api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must not be ' +\n          `\"${type}\" in JSON-LD 1.0 mode.`,\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    } else if(type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if(container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if(!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; container: @type requires @type to be ' +\n            '@id or @vocab.',\n            'jsonld.SyntaxError',\n            {code: 'invalid type mapping', context: localCtx});\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if('@index' in value) {\n    if(!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index without @index in @container: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index must expand to an IRI: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(term.match(/:|\\//)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords may not be used as prefixes',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@direction' in value) {\n    const direction = value['@direction'];\n    if(direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @direction value must be ' +\n        'null, \"ltr\", or \"rtl\".',\n        'jsonld.SyntaxError',\n        {code: 'invalid base direction', context: localCtx});\n    }\n    mapping['@direction'] = direction;\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // Check for overriding protected terms\n  if(previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; tried to redefine a protected term.',\n        'jsonld.SyntaxError',\n        {code: 'protected term redefinition', context: localCtx, term});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if(value.match(REGEX_KEYWORD)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx, localCtx, term: value, defined, options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon > 0) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx, localCtx, term: prefix, defined, options\n      });\n    }\n\n    // use mapping if prefix is defined\n    const mapping = activeCtx.mappings.get(prefix);\n    if(mapping && mapping._prefix) {\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if(_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // A flag that captures whether the iri being expanded is\n  // the value for an @type\n  //let typeExpansion = false;\n\n  //if(options !== undefined && options.typeExpansion !== undefined) {\n  //  typeExpansion = options.typeExpansion;\n  //}\n\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    // prepend vocab\n    const prependedResult = activeCtx['@vocab'] + value;\n    // FIXME: needed? may be better as debug event.\n    /*\n    if(options && options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'prepending @vocab during expansion',\n          level: 'info',\n          message: 'Prepending @vocab during expansion.',\n          details: {\n            type: '@vocab',\n            vocab: activeCtx['@vocab'],\n            value,\n            result: prependedResult,\n            typeExpansion\n          }\n        },\n        options\n      });\n    }\n    */\n    // the null case preserves value as potentially relative\n    value = prependedResult;\n  } else if(relativeTo.base) {\n    // prepend base\n    let prependedResult;\n    let base;\n    if('@base' in activeCtx) {\n      if(activeCtx['@base']) {\n        base = prependBase(options.base, activeCtx['@base']);\n        prependedResult = prependBase(base, value);\n      } else {\n        base = activeCtx['@base'];\n        prependedResult = value;\n      }\n    } else {\n      base = options.base;\n      prependedResult = prependBase(options.base, value);\n    }\n    // FIXME: needed? may be better as debug event.\n    /*\n    if(options && options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'prepending @base during expansion',\n          level: 'info',\n          message: 'Prepending @base during expansion.',\n          details: {\n            type: '@base',\n            base,\n            value,\n            result: prependedResult,\n            typeExpansion\n          }\n        },\n        options\n      });\n    }\n    */\n    // the null case preserves value as potentially relative\n    value = prependedResult;\n  }\n\n  // FIXME: duplicate? needed? maybe just enable in a verbose debug mode\n  /*\n  if(!_isAbsoluteIri(value) && options && options.eventHandler) {\n    // emit event indicating a relative IRI was found, which can result in it\n    // being dropped when converting to other RDF representations\n    _handleEvent({\n      event: {\n        type: ['JsonLdEvent'],\n        code: 'relative IRI after expansion',\n        // FIXME: what level?\n        level: 'warning',\n        message: 'Relative IRI after expansion.',\n        details: {\n          relativeIri: value,\n          typeExpansion\n        }\n      },\n      options\n    });\n    // NOTE: relative reference events emitted at calling sites as needed\n  }\n  */\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const key = JSON.stringify({processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    const defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      if(mapping['@id'] === null) {\n        continue;\n      }\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if(mapping['@type'] === '@none') {\n          _addPreferredTerm(term, entry['@any'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping && '@direction' in mapping) {\n          // term is preferred for values using specific language and direction\n          const language = mapping['@language'];\n          const direction = mapping['@direction'];\n          if(language && direction) {\n            _addPreferredTerm(term, entry['@language'],\n              `${language}_${direction}`.toLowerCase());\n          } else if(language) {\n            _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n          } else if(direction) {\n            _addPreferredTerm(term, entry['@language'], `_${direction}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@null');\n          }\n        } else if('@language' in mapping) {\n          _addPreferredTerm(term, entry['@language'],\n            (mapping['@language'] || '@null').toLowerCase());\n        } else if('@direction' in mapping) {\n          if(mapping['@direction']) {\n            _addPreferredTerm(term, entry['@language'],\n              `_${mapping['@direction']}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@none');\n          }\n        } else if(defaultDirection) {\n          _addPreferredTerm(term, entry['@language'], `_${defaultDirection}`);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else {\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if(type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/context.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/documentLoaders/xhr.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld/lib/documentLoaders/xhr.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {parseLinkHeader, buildHeaders} = __webpack_require__(/*! ../util */ \"./node_modules/jsonld/lib/util.js\");\nconst {LINK_HEADER_CONTEXT} = __webpack_require__(/*! ../constants */ \"./node_modules/jsonld/lib/constants.js\");\nconst JsonLdError = __webpack_require__(/*! ../JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst RequestQueue = __webpack_require__(/*! ../RequestQueue */ \"./node_modules/jsonld/lib/RequestQueue.js\");\nconst {prependBase} = __webpack_require__(/*! ../url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst REGEX_LINK_HEADER = /(^|(\\r\\n))link:/i;\n\n/**\n * Creates a built-in XMLHttpRequest document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *          [xhr]: the XMLHttpRequest API to use.\n *\n * @return the XMLHttpRequest document loader.\n */\nmodule.exports = ({\n  secure,\n  headers = {},\n  xhr\n} = {headers: {}}) => {\n  headers = buildHeaders(headers);\n  const queue = new RequestQueue();\n  return queue.wrapLoader(loader);\n\n  async function loader(url) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n\n    let req;\n    try {\n      req = await _get(xhr, url, headers);\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    if(req.status >= 400) {\n      throw new JsonLdError(\n        'URL could not be dereferenced: ' + req.statusText,\n        'jsonld.LoadDocumentError', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: req.status\n        });\n    }\n\n    let doc = {contextUrl: null, documentUrl: url, document: req.response};\n    let alternate = null;\n\n    // handle Link Header (avoid unsafe header warning by existence testing)\n    const contentType = req.getResponseHeader('Content-Type');\n    let linkHeader;\n    if(REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {\n      linkHeader = req.getResponseHeader('Link');\n    }\n    if(linkHeader && contentType !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(linkHeader);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one ' +\n          'associated HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders.alternate;\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(contentType || '').match(/^application\\/(\\w*\\+)?json$/)) {\n        doc = await loader(prependBase(url, alternate.target));\n      }\n    }\n\n    return doc;\n  }\n};\n\nfunction _get(xhr, url, headers) {\n  xhr = xhr || XMLHttpRequest;\n  const req = new xhr();\n  return new Promise((resolve, reject) => {\n    req.onload = () => resolve(req);\n    req.onerror = err => reject(err);\n    req.open('GET', url, true);\n    for(const k in headers) {\n      req.setRequestHeader(k, headers[k]);\n    }\n    req.send();\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/documentLoaders/xhr.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/events.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/events.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  asArray: _asArray\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\n\n// default handler, store as null or an array\n// exposed to allow fast external pre-handleEvent() checks\napi.defaultEventHandler = null;\n\n/**\n * Setup event handler.\n *\n * Return an array event handler constructed from an optional safe mode\n * handler, an optional options event handler, and an optional default handler.\n *\n * @param {object} options - processing options\n *   {function|object|array} [eventHandler] - an event handler.\n *\n * @return an array event handler.\n */\napi.setupEventHandler = ({options = {}}) => {\n  // build in priority order\n  const eventHandler = [].concat(\n    options.safe ? api.safeEventHandler : [],\n    options.eventHandler ? _asArray(options.eventHandler) : [],\n    api.defaultEventHandler ? api.defaultEventHandler : []\n  );\n  // null if no handlers\n  return eventHandler.length === 0 ? null : eventHandler;\n};\n\n/**\n * Handle an event.\n *\n * Top level APIs have a common 'eventHandler' option. This option can be a\n * function, array of functions, object mapping event.code to functions (with a\n * default to call next()), or any combination of such handlers. Handlers will\n * be called with an object with an 'event' entry and a 'next' function. Custom\n * handlers should process the event as appropriate. The 'next()' function\n * should be called to let the next handler process the event.\n *\n * NOTE: Only call this function if options.eventHandler is set and is an\n * array of hanlers. This is an optimization. Callers are expected to check\n * for an event handler before constructing events and calling this function.\n *\n * @param {object} event - event structure:\n *   {string} code - event code\n *   {string} level - severity level, one of: ['warning']\n *   {string} message - human readable message\n *   {object} details - event specific details\n * @param {object} options - processing options\n *   {array} eventHandler - an event handler array.\n */\napi.handleEvent = ({\n  event,\n  options\n}) => {\n  _handle({event, handlers: options.eventHandler});\n};\n\nfunction _handle({event, handlers}) {\n  let doNext = true;\n  for(let i = 0; doNext && i < handlers.length; ++i) {\n    doNext = false;\n    const handler = handlers[i];\n    if(_isArray(handler)) {\n      doNext = _handle({event, handlers: handler});\n    } else if(typeof handler === 'function') {\n      handler({event, next: () => {\n        doNext = true;\n      }});\n    } else if(typeof handler === 'object') {\n      if(event.code in handler) {\n        handler[event.code]({event, next: () => {\n          doNext = true;\n        }});\n      } else {\n        doNext = true;\n      }\n    } else {\n      throw new JsonLdError(\n        'Invalid event handler.',\n        'jsonld.InvalidEventHandler',\n        {event});\n    }\n  }\n  return doNext;\n}\n\nconst _notSafeEventCodes = new Set([\n  'empty object',\n  'free-floating scalar',\n  'invalid @language value',\n  'invalid property',\n  // NOTE: spec edge case\n  'null @id value',\n  'null @value value',\n  'object with only @id',\n  'object with only @language',\n  'object with only @list',\n  'object with only @value',\n  'relative @id reference',\n  'relative @type reference',\n  'relative @vocab reference',\n  'reserved @id value',\n  'reserved @reverse value',\n  'reserved term',\n  // toRDF\n  'blank node predicate',\n  'relative graph reference',\n  'relative object reference',\n  'relative predicate reference',\n  'relative subject reference',\n  // toRDF / fromRDF\n  'rdfDirection not set'\n]);\n\n// safe handler that rejects unsafe warning conditions\napi.safeEventHandler = function safeEventHandler({event, next}) {\n  // fail on all unsafe warnings\n  if(event.level === 'warning' && _notSafeEventCodes.has(event.code)) {\n    throw new JsonLdError(\n      'Safe mode validation error.',\n      'jsonld.ValidationError',\n      {event}\n    );\n  }\n  next();\n};\n\n// logs all events and continues\napi.logEventHandler = function logEventHandler({event, next}) {\n  console.log(`EVENT: ${event.message}`, {event});\n  next();\n};\n\n// log 'warning' level events\napi.logWarningEventHandler = function logWarningEventHandler({event, next}) {\n  if(event.level === 'warning') {\n    console.warn(`WARNING: ${event.message}`, {event});\n  }\n  next();\n};\n\n// fallback to throw errors for any unhandled events\napi.unhandledEventHandler = function unhandledEventHandler({event}) {\n  throw new JsonLdError(\n    'No handler for event.',\n    'jsonld.UnhandledEvent',\n    {event}\n  );\n};\n\n/**\n * Set default event handler.\n *\n * By default, all event are unhandled. It is recommended to pass in an\n * eventHandler into each call. However, this call allows using a default\n * eventHandler when one is not otherwise provided.\n *\n * @param {object} options - default handler options:\n *   {function|object|array} eventHandler - a default event handler.\n *     falsey to unset.\n */\napi.setDefaultEventHandler = function({eventHandler} = {}) {\n  api.defaultEventHandler = eventHandler ? _asArray(eventHandler) : null;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/events.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/expand.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"./node_modules/jsonld/lib/events.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'free-floating scalar',\n            level: 'warning',\n            message: 'Dropping free-floating scalar not in a list.',\n            details: {\n              value: element\n              //activeProperty\n              //insideList\n            }\n          },\n          options\n        });\n      }\n      return null;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        // FIXME: add debug event?\n        //unmappedValue: element[i],\n        //activeProperty,\n        //parent: element,\n        //index: i,\n        //expandedParent: rval,\n        //insideList\n\n        // NOTE: no-value events emitted at calling sites as needed\n        continue;\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext\n  });\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'null @value value',\n            level: 'warning',\n            message: 'Dropping null @value value.',\n            details: {\n              value: rval\n            }\n          },\n          options\n        });\n      }\n      rval = null;\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language\n    // FIXME\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'object with only @language',\n          level: 'warning',\n          message: 'Dropping object with only @language.',\n          details: {\n            value: rval\n          }\n        },\n        options\n      });\n    }\n    rval = null;\n  }\n\n  // drop certain top-level objects that do not occur in lists\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null ||\n      expandedActiveProperty === '@graph' ||\n      (_getContextValue(activeCtx, activeProperty, '@container') || [])\n        .includes('@graph')\n    )) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    rval = _dropUnsafeObject({value: rval, count, options});\n  }\n\n  return rval;\n};\n\n/**\n * Drop empty object, top-level @value/@list, or object with only @id\n *\n * @param value Value to check.\n * @param count Number of properties in object.\n * @param options The expansion options.\n *\n * @return null if dropped, value otherwise.\n */\nfunction _dropUnsafeObject({\n  value,\n  count,\n  options\n}) {\n  if(count === 0 || '@value' in value || '@list' in value ||\n    (count === 1 && '@id' in value)) {\n    // FIXME\n    if(options.eventHandler) {\n      // FIXME: one event or diff event for empty, @v/@l, {@id}?\n      let code;\n      let message;\n      if(count === 0) {\n        code = 'empty object';\n        message = 'Dropping empty object.';\n      } else if('@value' in value) {\n        code = 'object with only @value';\n        message = 'Dropping object with only @value.';\n      } else if('@list' in value) {\n        code = 'object with only @list';\n        message = 'Dropping object with only @list.';\n      } else if(count === 1 && '@id' in value) {\n        code = 'object with only @id';\n        message = 'Dropping object with only @id.';\n      }\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code,\n          level: 'warning',\n          message,\n          details: {\n            value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n  return value;\n}\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, {\n        ...options,\n        typeExpansion: true\n      }) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid property',\n            level: 'warning',\n            message: 'Dropping property that did not expand into an ' +\n              'absolute IRI or keyword.',\n            details: {\n              property: key,\n              expandedProperty\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(activeCtx, v, {base: true}, options);\n            if(options.eventHandler) {\n              if(ve === null) {\n                // NOTE: spec edge case\n                // See https://github.com/w3c/json-ld-api/issues/480\n                if(v === null) {\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'null @id value',\n                      level: 'warning',\n                      message: 'Null @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                } else {\n                  // matched KEYWORD regex\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'reserved @id value',\n                      level: 'warning',\n                      message: 'Reserved @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                }\n              } else if(!_isAbsoluteIri(ve)) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @id reference',\n                    level: 'warning',\n                    message: 'Relative @id reference found.',\n                    details: {\n                      id: v,\n                      expandedId: ve\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true},\n              {...options, typeExpansion: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(typeScopedContext, v,\n              {base: true, vocab: true},\n              {...options, typeExpansion: true});\n            if(ve !== '@json' && !_isAbsoluteIri(ve)) {\n              if(options.eventHandler) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @type reference',\n                    level: 'warning',\n                    message: 'Relative @type reference found.',\n                    details: {\n                      type: v\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: !!options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const language of value) {\n        if(_isString(language) && !language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty: '@reverse',\n        element: value,\n        options\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(activeCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = expandedProperty === '@list';\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // FIXME: event?\n      //unmappedValue: value,\n      //expandedProperty,\n      //key,\n      continue;\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are in an array\n      expandedValue = _asArray(expandedValue);\n      if(!options.isFrame) {\n        // drop items if needed\n        expandedValue = expandedValue.filter(v => {\n          const count = Object.keys(v).length;\n          return _dropUnsafeObject({value: v, count, options}) !== null;\n        });\n      }\n      if(expandedValue.length === 0) {\n        // all items dropped, skip adding and continue\n        continue;\n      }\n      // convert to graph\n      expandedValue = expandedValue.map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey\n      });\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true},\n      {...options, typeExpansion: true});\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    const expandedValue = _expandIri(activeCtx, value, {base: true}, options);\n    // NOTE: handle spec edge case and avoid invalid {\"@id\": null}\n    if(expandedValue === null && value.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message: 'Reserved @id found.',\n            details: {\n              id: activeProperty\n            }\n          },\n          options\n        });\n      }\n    }\n    return {'@id': expandedValue};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        if(!key.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: key\n                }\n              },\n              options\n            });\n          }\n        }\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap({\n  activeCtx, options, activeProperty, value, asGraph, indexKey, propertyIndex\n}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/expand.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/flatten.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/flatten.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  createMergedNodeMap: _createMergedNodeMap\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the expanded JSON-LD to flatten.\n *\n * @return the flattened output.\n */\napi.flatten = input => {\n  const defaultGraph = _createMergedNodeMap(input);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n  return flattened;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/flatten.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/frame.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/frame.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst url = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst {\n  createNodeMap: _createNodeMap,\n  mergeNodeMapGraphs: _mergeNodeMapGraphs\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD `merged` framing.\n *\n * @param input the expanded JSON-LD to frame.\n * @param frame the expanded JSON-LD frame to use.\n * @param options the framing options.\n *\n * @return the framed output.\n */\napi.frameMergedOrDefault = (input, frame, options) => {\n  // create framing state\n  const state = {\n    options,\n    embedded: false,\n    graph: '@default',\n    graphMap: {'@default': {}},\n    subjectStack: [],\n    link: {},\n    bnodeMap: {}\n  };\n\n  // produce a map of all graphs and name each bnode\n  // FIXME: currently uses subjects from @merged graph only\n  const issuer = new util.IdentifierIssuer('_:b');\n  _createNodeMap(input, state.graphMap, '@default', issuer);\n  if(options.merged) {\n    state.graphMap['@merged'] = _mergeNodeMapGraphs(state.graphMap);\n    state.graph = '@merged';\n  }\n  state.subjects = state.graphMap[state.graph];\n\n  // frame the subjects\n  const framed = [];\n  api.frame(state, Object.keys(state.subjects).sort(), frame, framed);\n\n  // If pruning blank nodes, find those to prune\n  if(options.pruneBlankNodeIdentifiers) {\n    // remove all blank nodes appearing only once, done in compaction\n    options.bnodesToClear =\n      Object.keys(state.bnodeMap).filter(id => state.bnodeMap[id].length === 1);\n  }\n\n  // remove @preserve from results\n  options.link = {};\n  return _cleanupPreserve(framed, options);\n};\n\n/**\n * Frames subjects according to the given frame.\n *\n * @param state the current framing state.\n * @param subjects the subjects to filter.\n * @param frame the frame.\n * @param parent the parent subject or top-level array.\n * @param property the parent property, initialized to null.\n */\napi.frame = (state, subjects, frame, parent, property = null) => {\n  // validate the frame\n  _validateFrame(frame);\n  frame = frame[0];\n\n  // get flags for current frame\n  const options = state.options;\n  const flags = {\n    embed: _getFrameFlag(frame, options, 'embed'),\n    explicit: _getFrameFlag(frame, options, 'explicit'),\n    requireAll: _getFrameFlag(frame, options, 'requireAll')\n  };\n\n  // get link for current graph\n  if(!state.link.hasOwnProperty(state.graph)) {\n    state.link[state.graph] = {};\n  }\n  const link = state.link[state.graph];\n\n  // filter out subjects that match the frame\n  const matches = _filterSubjects(state, subjects, frame, flags);\n\n  // add matches to output\n  const ids = Object.keys(matches).sort();\n  for(const id of ids) {\n    const subject = matches[id];\n\n    /* Note: In order to treat each top-level match as a compartmentalized\n    result, clear the unique embedded subjects map when the property is null,\n    which only occurs at the top-level. */\n    if(property === null) {\n      state.uniqueEmbeds = {[state.graph]: {}};\n    } else {\n      state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};\n    }\n\n    if(flags.embed === '@link' && id in link) {\n      // TODO: may want to also match an existing linked subject against\n      // the current frame ... so different frames could produce different\n      // subjects that are only shared in-memory when the frames are the same\n\n      // add existing linked subject\n      _addFrameOutput(parent, property, link[id]);\n      continue;\n    }\n\n    // start output for subject\n    const output = {'@id': id};\n    if(id.indexOf('_:') === 0) {\n      util.addValue(state.bnodeMap, id, output, {propertyIsArray: true});\n    }\n    link[id] = output;\n\n    // validate @embed\n    if((flags.embed === '@first' || flags.embed === '@last') && state.is11) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n\n    if(!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      // skip adding this node object to the top level, as it was\n      // already included in another node object\n      continue;\n    }\n\n    // if embed is @never or if a circular reference would be created by an\n    // embed, the subject cannot be embedded, just add the reference;\n    // note that a circular reference won't occur when the embed flag is\n    // `@link` as the above check will short-circuit before reaching this point\n    if(state.embedded &&\n      (flags.embed === '@never' ||\n      _createsCircularReference(subject, state.graph, state.subjectStack))) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the first (or once) should be embedded\n    if(state.embedded &&\n       (flags.embed == '@first' || flags.embed == '@once') &&\n       state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the last match should be embedded\n    if(flags.embed === '@last') {\n      // remove any existing embed\n      if(id in state.uniqueEmbeds[state.graph]) {\n        _removeEmbed(state, id);\n      }\n    }\n\n    state.uniqueEmbeds[state.graph][id] = {parent, property};\n\n    // push matching subject onto stack to enable circular embed checks\n    state.subjectStack.push({subject, graph: state.graph});\n\n    // subject is also the name of a graph\n    if(id in state.graphMap) {\n      let recurse = false;\n      let subframe = null;\n      if(!('@graph' in frame)) {\n        recurse = state.graph !== '@merged';\n        subframe = {};\n      } else {\n        subframe = frame['@graph'][0];\n        recurse = !(id === '@merged' || id === '@default');\n        if(!types.isObject(subframe)) {\n          subframe = {};\n        }\n      }\n\n      if(recurse) {\n        // recurse into graph\n        api.frame(\n          {...state, graph: id, embedded: false},\n          Object.keys(state.graphMap[id]).sort(), [subframe], output, '@graph');\n      }\n    }\n\n    // if frame has @included, recurse over its sub-frame\n    if('@included' in frame) {\n      api.frame(\n        {...state, embedded: false},\n        subjects, frame['@included'], output, '@included');\n    }\n\n    // iterate over subject properties\n    for(const prop of Object.keys(subject).sort()) {\n      // copy keywords to output\n      if(isKeyword(prop)) {\n        output[prop] = util.clone(subject[prop]);\n\n        if(prop === '@type') {\n          // count bnode values of @type\n          for(const type of subject['@type']) {\n            if(type.indexOf('_:') === 0) {\n              util.addValue(\n                state.bnodeMap, type, output, {propertyIsArray: true});\n            }\n          }\n        }\n        continue;\n      }\n\n      // explicit is on and property isn't in the frame, skip processing\n      if(flags.explicit && !(prop in frame)) {\n        continue;\n      }\n\n      // add objects\n      for(const o of subject[prop]) {\n        const subframe = (prop in frame ?\n          frame[prop] : _createImplicitFrame(flags));\n\n        // recurse into list\n        if(graphTypes.isList(o)) {\n          const subframe =\n            (frame[prop] && frame[prop][0] && frame[prop][0]['@list']) ?\n              frame[prop][0]['@list'] :\n              _createImplicitFrame(flags);\n\n          // add empty list\n          const list = {'@list': []};\n          _addFrameOutput(output, prop, list);\n\n          // add list objects\n          const src = o['@list'];\n          for(const oo of src) {\n            if(graphTypes.isSubjectReference(oo)) {\n              // recurse into subject reference\n              api.frame(\n                {...state, embedded: true},\n                [oo['@id']], subframe, list, '@list');\n            } else {\n              // include other values automatically\n              _addFrameOutput(list, '@list', util.clone(oo));\n            }\n          }\n        } else if(graphTypes.isSubjectReference(o)) {\n          // recurse into subject reference\n          api.frame(\n            {...state, embedded: true},\n            [o['@id']], subframe, output, prop);\n        } else if(_valueMatch(subframe[0], o)) {\n          // include other values, if they match\n          _addFrameOutput(output, prop, util.clone(o));\n        }\n      }\n    }\n\n    // handle defaults\n    for(const prop of Object.keys(frame).sort()) {\n      // skip keywords\n      if(prop === '@type') {\n        if(!types.isObject(frame[prop][0]) ||\n           !('@default' in frame[prop][0])) {\n          continue;\n        }\n        // allow through default types\n      } else if(isKeyword(prop)) {\n        continue;\n      }\n\n      // if omit default is off, then include default values for properties\n      // that appear in the next frame but are not in the matching subject\n      const next = frame[prop][0] || {};\n      const omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');\n      if(!omitDefaultOn && !(prop in output)) {\n        let preserve = '@null';\n        if('@default' in next) {\n          preserve = util.clone(next['@default']);\n        }\n        if(!types.isArray(preserve)) {\n          preserve = [preserve];\n        }\n        output[prop] = [{'@preserve': preserve}];\n      }\n    }\n\n    // if embed reverse values by finding nodes having this subject as a value\n    // of the associated property\n    for(const reverseProp of Object.keys(frame['@reverse'] || {}).sort()) {\n      const subframe = frame['@reverse'][reverseProp];\n      for(const subject of Object.keys(state.subjects)) {\n        const nodeValues =\n          util.getValues(state.subjects[subject], reverseProp);\n        if(nodeValues.some(v => v['@id'] === id)) {\n          // node has property referencing this subject, recurse\n          output['@reverse'] = output['@reverse'] || {};\n          util.addValue(\n            output['@reverse'], reverseProp, [], {propertyIsArray: true});\n          api.frame(\n            {...state, embedded: true},\n            [subject], subframe, output['@reverse'][reverseProp],\n            property);\n        }\n      }\n    }\n\n    // add output to parent\n    _addFrameOutput(parent, property, output);\n\n    // pop matching subject from circular ref-checking stack\n    state.subjectStack.pop();\n  }\n};\n\n/**\n * Replace `@null` with `null`, removing it from arrays.\n *\n * @param input the framed, compacted output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\napi.cleanupNull = (input, options) => {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    const noNulls = input.map(v => api.cleanupNull(v, options));\n    return noNulls.filter(v => v); // removes nulls from array\n  }\n\n  if(input === '@null') {\n    return null;\n  }\n\n  if(types.isObject(input)) {\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    for(const key in input) {\n      input[key] = api.cleanupNull(input[key], options);\n    }\n  }\n  return input;\n};\n\n/**\n * Creates an implicit frame when recursing through subject matches. If\n * a frame doesn't have an explicit frame for a particular property, then\n * a wildcard child frame will be created that uses the same flags that the\n * parent frame used.\n *\n * @param flags the current framing flags.\n *\n * @return the implicit frame.\n */\nfunction _createImplicitFrame(flags) {\n  const frame = {};\n  for(const key in flags) {\n    if(flags[key] !== undefined) {\n      frame['@' + key] = [flags[key]];\n    }\n  }\n  return [frame];\n}\n\n/**\n * Checks the current subject stack to see if embedding the given subject\n * would cause a circular reference.\n *\n * @param subjectToEmbed the subject to embed.\n * @param graph the graph the subject to embed is in.\n * @param subjectStack the current stack of subjects.\n *\n * @return true if a circular reference would be created, false if not.\n */\nfunction _createsCircularReference(subjectToEmbed, graph, subjectStack) {\n  for(let i = subjectStack.length - 1; i >= 0; --i) {\n    const subject = subjectStack[i];\n    if(subject.graph === graph &&\n      subject.subject['@id'] === subjectToEmbed['@id']) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Gets the frame flag value for the given flag name.\n *\n * @param frame the frame.\n * @param options the framing options.\n * @param name the flag name.\n *\n * @return the flag value.\n */\nfunction _getFrameFlag(frame, options, name) {\n  const flag = '@' + name;\n  let rval = (flag in frame ? frame[flag][0] : options[name]);\n  if(name === 'embed') {\n    // default is \"@last\"\n    // backwards-compatibility support for \"embed\" maps:\n    // true => \"@last\"\n    // false => \"@never\"\n    if(rval === true) {\n      rval = '@once';\n    } else if(rval === false) {\n      rval = '@never';\n    } else if(rval !== '@always' && rval !== '@never' && rval !== '@link' &&\n      rval !== '@first' && rval !== '@last' && rval !== '@once') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n  }\n  return rval;\n}\n\n/**\n * Validates a JSON-LD frame, throwing an exception if the frame is invalid.\n *\n * @param frame the frame to validate.\n */\nfunction _validateFrame(frame) {\n  if(!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a JSON-LD frame must be a single object.',\n      'jsonld.SyntaxError', {frame});\n  }\n\n  if('@id' in frame[0]) {\n    for(const id of util.asArray(frame[0]['@id'])) {\n      // @id must be wildcard or an IRI\n      if(!(types.isObject(id) || url.isAbsolute(id)) ||\n        (types.isString(id) && id.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @id in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n\n  if('@type' in frame[0]) {\n    for(const type of util.asArray(frame[0]['@type'])) {\n      // @type must be wildcard, IRI, or @json\n      if(!(types.isObject(type) || url.isAbsolute(type) ||\n          (type === '@json')) ||\n        (types.isString(type) && type.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @type in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n}\n\n/**\n * Returns a map of all of the subjects that match a parsed frame.\n *\n * @param state the current framing state.\n * @param subjects the set of subjects to filter.\n * @param frame the parsed frame.\n * @param flags the frame flags.\n *\n * @return all of the matched subjects.\n */\nfunction _filterSubjects(state, subjects, frame, flags) {\n  // filter subjects in @id order\n  const rval = {};\n  for(const id of subjects) {\n    const subject = state.graphMap[state.graph][id];\n    if(_filterSubject(state, subject, frame, flags)) {\n      rval[id] = subject;\n    }\n  }\n  return rval;\n}\n\n/**\n * Returns true if the given subject matches the given frame.\n *\n * Matches either based on explicit type inclusion where the node has any\n * type listed in the frame. If the frame has empty types defined matches\n * nodes not having a @type. If the frame has a type of {} defined matches\n * nodes having any type defined.\n *\n * Otherwise, does duck typing, where the node must have all of the\n * properties defined in the frame.\n *\n * @param state the current framing state.\n * @param subject the subject to check.\n * @param frame the frame to check.\n * @param flags the frame flags.\n *\n * @return true if the subject matches, false if not.\n */\nfunction _filterSubject(state, subject, frame, flags) {\n  // check ducktype\n  let wildcard = true;\n  let matchesSome = false;\n\n  for(const key in frame) {\n    let matchThis = false;\n    const nodeValues = util.getValues(subject, key);\n    const isEmpty = util.getValues(frame, key).length === 0;\n\n    if(key === '@id') {\n      // match on no @id or any matching @id, including wildcard\n      if(types.isEmptyObject(frame['@id'][0] || {})) {\n        matchThis = true;\n      } else if(frame['@id'].length >= 0) {\n        matchThis = frame['@id'].includes(nodeValues[0]);\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(key === '@type') {\n      // check @type (object value means 'any' type,\n      // fall through to ducktyping)\n      wildcard = false;\n      if(isEmpty) {\n        if(nodeValues.length > 0) {\n          // don't match on no @type\n          return false;\n        }\n        matchThis = true;\n      } else if(frame['@type'].length === 1 &&\n        types.isEmptyObject(frame['@type'][0])) {\n        // match on wildcard @type if there is a type\n        matchThis = nodeValues.length > 0;\n      } else {\n        // match on a specific @type\n        for(const type of frame['@type']) {\n          if(types.isObject(type) && '@default' in type) {\n            // match on default object\n            matchThis = true;\n          } else {\n            matchThis = matchThis || nodeValues.some(tt => tt === type);\n          }\n        }\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(isKeyword(key)) {\n      continue;\n    } else {\n      // Force a copy of this frame entry so it can be manipulated\n      const thisFrame = util.getValues(frame, key)[0];\n      let hasDefault = false;\n      if(thisFrame) {\n        _validateFrame([thisFrame]);\n        hasDefault = '@default' in thisFrame;\n      }\n\n      // no longer a wildcard pattern if frame has any non-keyword properties\n      wildcard = false;\n\n      // skip, but allow match if node has no value for property, and frame has\n      // a default value\n      if(nodeValues.length === 0 && hasDefault) {\n        continue;\n      }\n\n      // if frame value is empty, don't match if subject has any value\n      if(nodeValues.length > 0 && isEmpty) {\n        return false;\n      }\n\n      if(thisFrame === undefined) {\n        // node does not match if values is not empty and the value of property\n        // in frame is match none.\n        if(nodeValues.length > 0) {\n          return false;\n        }\n        matchThis = true;\n      } else {\n        if(graphTypes.isList(thisFrame)) {\n          const listValue = thisFrame['@list'][0];\n          if(graphTypes.isList(nodeValues[0])) {\n            const nodeListValues = nodeValues[0]['@list'];\n\n            if(graphTypes.isValue(listValue)) {\n              // match on any matching value\n              matchThis = nodeListValues.some(lv => _valueMatch(listValue, lv));\n            } else if(graphTypes.isSubject(listValue) ||\n              graphTypes.isSubjectReference(listValue)) {\n              matchThis = nodeListValues.some(lv => _nodeMatch(\n                state, listValue, lv, flags));\n            }\n          }\n        } else if(graphTypes.isValue(thisFrame)) {\n          matchThis = nodeValues.some(nv => _valueMatch(thisFrame, nv));\n        } else if(graphTypes.isSubjectReference(thisFrame)) {\n          matchThis =\n            nodeValues.some(nv => _nodeMatch(state, thisFrame, nv, flags));\n        } else if(types.isObject(thisFrame)) {\n          matchThis = nodeValues.length > 0;\n        } else {\n          matchThis = false;\n        }\n      }\n    }\n\n    // all non-defaulted values must match if requireAll is set\n    if(!matchThis && flags.requireAll) {\n      return false;\n    }\n\n    matchesSome = matchesSome || matchThis;\n  }\n\n  // return true if wildcard or subject matches some properties\n  return wildcard || matchesSome;\n}\n\n/**\n * Removes an existing embed.\n *\n * @param state the current framing state.\n * @param id the @id of the embed to remove.\n */\nfunction _removeEmbed(state, id) {\n  // get existing embed\n  const embeds = state.uniqueEmbeds[state.graph];\n  const embed = embeds[id];\n  const parent = embed.parent;\n  const property = embed.property;\n\n  // create reference to replace embed\n  const subject = {'@id': id};\n\n  // remove existing embed\n  if(types.isArray(parent)) {\n    // replace subject with reference\n    for(let i = 0; i < parent.length; ++i) {\n      if(util.compareValues(parent[i], subject)) {\n        parent[i] = subject;\n        break;\n      }\n    }\n  } else {\n    // replace subject with reference\n    const useArray = types.isArray(parent[property]);\n    util.removeValue(parent, property, subject, {propertyIsArray: useArray});\n    util.addValue(parent, property, subject, {propertyIsArray: useArray});\n  }\n\n  // recursively remove dependent dangling embeds\n  const removeDependents = id => {\n    // get embed keys as a separate array to enable deleting keys in map\n    const ids = Object.keys(embeds);\n    for(const next of ids) {\n      if(next in embeds && types.isObject(embeds[next].parent) &&\n        embeds[next].parent['@id'] === id) {\n        delete embeds[next];\n        removeDependents(next);\n      }\n    }\n  };\n  removeDependents(id);\n}\n\n/**\n * Removes the @preserve keywords from expanded result of framing.\n *\n * @param input the framed, framed output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\nfunction _cleanupPreserve(input, options) {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    return input.map(value => _cleanupPreserve(value, options));\n  }\n\n  if(types.isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      return input['@preserve'][0];\n    }\n\n    // skip @values\n    if(graphTypes.isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(graphTypes.isList(input)) {\n      input['@list'] = _cleanupPreserve(input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === '@id' && options.bnodesToClear.includes(input[prop])) {\n        delete input['@id'];\n        continue;\n      }\n\n      input[prop] = _cleanupPreserve(input[prop], options);\n    }\n  }\n  return input;\n}\n\n/**\n * Adds framing output to the given parent.\n *\n * @param parent the parent to add to.\n * @param property the parent property.\n * @param output the output to add.\n */\nfunction _addFrameOutput(parent, property, output) {\n  if(types.isObject(parent)) {\n    util.addValue(parent, property, output, {propertyIsArray: true});\n  } else {\n    parent.push(output);\n  }\n}\n\n/**\n * Node matches if it is a node, and matches the pattern as a frame.\n *\n * @param state the current framing state.\n * @param pattern used to match value\n * @param value to check\n * @param flags the frame flags.\n */\nfunction _nodeMatch(state, pattern, value, flags) {\n  if(!('@id' in value)) {\n    return false;\n  }\n  const nodeObject = state.subjects[value['@id']];\n  return nodeObject && _filterSubject(state, nodeObject, pattern, flags);\n}\n\n/**\n * Value matches if it is a value and matches the value pattern\n *\n * * `pattern` is empty\n * * @values are the same, or `pattern[@value]` is a wildcard, and\n * * @types are the same or `value[@type]` is not null\n *   and `pattern[@type]` is `{}`, or `value[@type]` is null\n *   and `pattern[@type]` is null or `[]`, and\n * * @languages are the same or `value[@language]` is not null\n *   and `pattern[@language]` is `{}`, or `value[@language]` is null\n *   and `pattern[@language]` is null or `[]`.\n *\n * @param pattern used to match value\n * @param value to check\n */\nfunction _valueMatch(pattern, value) {\n  const v1 = value['@value'];\n  const t1 = value['@type'];\n  const l1 = value['@language'];\n  const v2 = pattern['@value'] ?\n    (types.isArray(pattern['@value']) ?\n      pattern['@value'] : [pattern['@value']]) :\n    [];\n  const t2 = pattern['@type'] ?\n    (types.isArray(pattern['@type']) ?\n      pattern['@type'] : [pattern['@type']]) :\n    [];\n  const l2 = pattern['@language'] ?\n    (types.isArray(pattern['@language']) ?\n      pattern['@language'] : [pattern['@language']]) :\n    [];\n\n  if(v2.length === 0 && t2.length === 0 && l2.length === 0) {\n    return true;\n  }\n  if(!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {\n    return false;\n  }\n  if(!(!t1 && t2.length === 0 || t2.includes(t1) || t1 &&\n    types.isEmptyObject(t2[0]))) {\n    return false;\n  }\n  if(!(!l1 && l2.length === 0 || l2.includes(l1) || l1 &&\n    types.isEmptyObject(l2[0]))) {\n    return false;\n  }\n  return true;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/frame.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/fromRdf.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/fromRdf.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  REGEX_BCP47,\n  addValue: _addValue\n} = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"./node_modules/jsonld/lib/events.js\");\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld/lib/constants.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  options\n) => {\n  const {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  } = options;\n  // FIXME: use Maps?\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n  if(rdfDirection) {\n    if(rdfDirection === 'compound-literal') {\n      throw new JsonLdError(\n        'Unsupported rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if(rdfDirection !== 'i18n-datatype') {\n      throw new JsonLdError(\n        'Unknown rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    }\n  }\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      _addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection, options);\n    _addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        _addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      _addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n * @param rdfDirection text direction mode [null, i18n-datatype]\n * @param options top level API options\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection, options) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    if(!o.language.match(REGEX_BCP47)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid @language value',\n            level: 'warning',\n            message: '@language value must be valid BCP47.',\n            details: {\n              language: o.language\n            }\n          },\n          options\n        });\n      }\n    }\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/fromRdf.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/graphTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonld/lib/graphTypes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is a subject with properties.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject with properties, false if not.\n */\napi.isSubject = v => {\n  // Note: A value is a subject if all of these hold true:\n  // 1. It is an Object.\n  // 2. It is not a @value, @set, or @list.\n  // 3. It has more than 1 key OR any existing key is not @id.\n  if(types.isObject(v) &&\n    !(('@value' in v) || ('@set' in v) || ('@list' in v))) {\n    const keyCount = Object.keys(v).length;\n    return (keyCount > 1 || !('@id' in v));\n  }\n  return false;\n};\n\n/**\n * Returns true if the given value is a subject reference.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject reference, false if not.\n */\napi.isSubjectReference = v =>\n  // Note: A value is a subject reference if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has a single key: @id.\n  (types.isObject(v) && Object.keys(v).length === 1 && ('@id' in v));\n\n/**\n * Returns true if the given value is a @value.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @value, false if not.\n */\napi.isValue = v =>\n  // Note: A value is a @value if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @value property.\n  types.isObject(v) && ('@value' in v);\n\n/**\n * Returns true if the given value is a @list.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @list, false if not.\n */\napi.isList = v =>\n  // Note: A value is a @list if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @list property.\n  types.isObject(v) && ('@list' in v);\n\n/**\n * Returns true if the given value is a @graph.\n *\n * @return true if the value is a @graph, false if not.\n */\napi.isGraph = v => {\n  // Note: A value is a graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It may have '@id' or '@index'\n  return types.isObject(v) &&\n    '@graph' in v &&\n    Object.keys(v)\n      .filter(key => key !== '@id' && key !== '@index').length === 1;\n};\n\n/**\n * Returns true if the given value is a simple @graph.\n *\n * @return true if the value is a simple @graph, false if not.\n */\napi.isSimpleGraph = v => {\n  // Note: A value is a simple graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It has only 1 key or 2 keys where one of them is `@index`.\n  return api.isGraph(v) && !('@id' in v);\n};\n\n/**\n * Returns true if the given value is a blank node.\n *\n * @param v the value to check.\n *\n * @return true if the value is a blank node, false if not.\n */\napi.isBlankNode = v => {\n  // Note: A value is a blank node if all of these hold true:\n  // 1. It is an Object.\n  // 2. If it has an @id key that is not a string OR begins with '_:'.\n  // 3. It has no keys OR is not a @value, @set, or @list.\n  if(types.isObject(v)) {\n    if('@id' in v) {\n      const id = v['@id'];\n      return !types.isString(id) || id.indexOf('_:') === 0;\n    }\n    return (Object.keys(v).length === 0 ||\n      !(('@value' in v) || ('@set' in v) || ('@list' in v)));\n  }\n  return false;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/graphTypes.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/jsonld.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/jsonld.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2022 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = __webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\");\nconst platform = __webpack_require__(/*! ./platform */ \"./node_modules/jsonld/lib/platform-browser.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst ContextResolver = __webpack_require__(/*! ./ContextResolver */ \"./node_modules/jsonld/lib/ContextResolver.js\");\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/jsonld/lib/NQuads.js\");\n\nconst {expand: _expand} = __webpack_require__(/*! ./expand */ \"./node_modules/jsonld/lib/expand.js\");\nconst {flatten: _flatten} = __webpack_require__(/*! ./flatten */ \"./node_modules/jsonld/lib/flatten.js\");\nconst {fromRDF: _fromRDF} = __webpack_require__(/*! ./fromRdf */ \"./node_modules/jsonld/lib/fromRdf.js\");\nconst {toRDF: _toRDF} = __webpack_require__(/*! ./toRdf */ \"./node_modules/jsonld/lib/toRdf.js\");\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = __webpack_require__(/*! ./frame */ \"./node_modules/jsonld/lib/frame.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = __webpack_require__(/*! ./compact */ \"./node_modules/jsonld/lib/compact.js\");\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\n\nconst {\n  logEventHandler: _logEventHandler,\n  logWarningEventHandler: _logWarningEventHandler,\n  safeEventHandler: _safeEventHandler,\n  setDefaultEventHandler: _setDefaultEventHandler,\n  setupEventHandler: _setupEventHandler,\n  strictEventHandler: _strictEventHandler,\n  unhandledEventHandler: _unhandledEventHandler\n} = __webpack_require__(/*! ./events */ \"./node_modules/jsonld/lib/events.js\");\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [documentLoader(url, options)] the document loader.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@once',\n    explicit: false,\n    requireAll: false,\n    omitDefault: false,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), frameContext, options);\n\n  // mode specific defaults\n  if(!options.hasOwnProperty('omitGraph')) {\n    options.omitGraph = _processingMode(activeCtx, 1.1);\n  }\n  if(!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n    options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n  }\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  const frameKeys = Object.keys(frame)\n    .map(key => _expandIri(activeCtx, key, {vocab: true}));\n  opts.merged = !frameKeys.includes('@graph');\n  opts.is11 = _processingMode(activeCtx, 1.1);\n\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  opts.graph = !options.omitGraph;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  let compacted = await jsonld.compact(framed, frameContext, opts);\n\n  // replace @null with null, compacting arrays\n  opts.link = {};\n  compacted = _cleanupNull(compacted, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * Note: Canonicalization sets `safe` to `true` and `base` to `null` by\n * default in order to produce safe outputs and \"fail closed\" by default. This\n * is different from the other API transformations in this version which\n * allow unsafe defaults (for cryptographic usage) in order to comply with the\n * JSON-LD 1.1 specification.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use (default: `null`).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [safe] true to use safe mode. (default: true).\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : null,\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    safe: true,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [safe] true to use safe mode. (default: false)\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = (__webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\").getContextValue);\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n/* URL API */\njsonld.url = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\n/* Events API and handlers */\njsonld.logEventHandler = _logEventHandler;\njsonld.logWarningEventHandler = _logWarningEventHandler;\njsonld.safeEventHandler = _safeEventHandler;\njsonld.setDefaultEventHandler = _setDefaultEventHandler;\njsonld.strictEventHandler = _strictEventHandler;\njsonld.unhandledEventHandler = _unhandledEventHandler;\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = __webpack_require__(/*! ./RequestQueue */ \"./node_modules/jsonld/lib/RequestQueue.js\");\n\n/* WebIDL API */\njsonld.JsonLdProcessor = __webpack_require__(/*! ./JsonLdProcessor */ \"./node_modules/jsonld/lib/JsonLdProcessor.js\")(jsonld);\n\nplatform.setupGlobals(jsonld);\nplatform.setupDocumentLoaders(jsonld);\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  // fail if obsolete options present\n  if(options && 'compactionMap' in options) {\n    throw new JsonLdError(\n      '\"compactionMap\" not supported.',\n      'jsonld.OptionsError');\n  }\n  if(options && 'expansionMap' in options) {\n    throw new JsonLdError(\n      '\"expansionMap\" not supported.',\n      'jsonld.OptionsError');\n  }\n  return Object.assign(\n    {},\n    {documentLoader},\n    defaults,\n    options,\n    {eventHandler: _setupEventHandler({options})}\n  );\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/jsonld.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/nodeMap.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/nodeMap.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/nodeMap.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/platform-browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsonld/lib/platform-browser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst xhrLoader = __webpack_require__(/*! ./documentLoaders/xhr */ \"./node_modules/jsonld/lib/documentLoaders/xhr.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Setup browser document loaders.\n *\n * @param jsonld the jsonld api.\n */\napi.setupDocumentLoaders = function(jsonld) {\n  if(typeof XMLHttpRequest !== 'undefined') {\n    jsonld.documentLoaders.xhr = xhrLoader;\n    // use xhr document loader by default\n    jsonld.useDocumentLoader('xhr');\n  }\n};\n\n/**\n * Setup browser globals.\n *\n * @param jsonld the jsonld api.\n */\napi.setupGlobals = function(jsonld) {\n  // setup browser global JsonLdProcessor\n  if(typeof globalThis.JsonLdProcessor === 'undefined') {\n    Object.defineProperty(globalThis, 'JsonLdProcessor', {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: jsonld.JsonLdProcessor\n    });\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/platform-browser.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/toRdf.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/toRdf.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {createNodeMap} = __webpack_require__(/*! ./nodeMap */ \"./node_modules/jsonld/lib/nodeMap.js\");\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst jsonCanonicalize = __webpack_require__(/*! canonicalize */ \"./node_modules/canonicalize/lib/canonicalize.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"./node_modules/jsonld/lib/events.js\");\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"./node_modules/jsonld/lib/constants.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"./node_modules/jsonld/lib/url.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'relative graph reference',\n            level: 'warning',\n            message: 'Relative graph reference found.',\n            details: {\n              graph: graphName\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative subject reference',\n                level: 'warning',\n                message: 'Relative subject reference found.',\n                details: {\n                  subject: id\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative predicate reference',\n                level: 'warning',\n                message: 'Relative predicate reference found.',\n                details: {\n                  predicate: property\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'blank node predicate',\n                level: 'warning',\n                message: 'Dropping blank node predicate.',\n                details: {\n                  // FIXME: add better issuer API to get reverse mapping\n                  property: issuer.getOldIds()\n                    .find(key => issuer.getId(key) === property)\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(\n          item, issuer, dataset, graphTerm, options.rdfDirection, options);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(\n      item, issuer, dataset, graphTerm, rdfDirection, options);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(\n      last, issuer, dataset, graphTerm, rdfDirection, options);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(\n  item, issuer, dataset, graphTerm, rdfDirection, options\n) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if('@direction' in item && rdfDirection === 'i18n-datatype') {\n      const language = (item['@language'] || '').toLowerCase();\n      const direction = item['@direction'];\n      const datatype = `https://www.w3.org/ns/i18n#${language}_${direction}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@direction' in item && rdfDirection === 'compound-literal') {\n      throw new JsonLdError(\n        'Unsupported rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if('@direction' in item && rdfDirection) {\n      throw new JsonLdError(\n        'Unknown rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if('@language' in item) {\n      if('@direction' in item && !rdfDirection) {\n        if(options.eventHandler) {\n          // FIXME: only emit once?\n          _handleEvent({\n            event: {\n              type: ['JsonLdEvent'],\n              code: 'rdfDirection not set',\n              level: 'warning',\n              message: 'rdfDirection not set for @direction.',\n              details: {\n                object: object.value\n              }\n            },\n            options\n          });\n        }\n      }\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      if('@direction' in item && !rdfDirection) {\n        if(options.eventHandler) {\n          // FIXME: only emit once?\n          _handleEvent({\n            event: {\n              type: ['JsonLdEvent'],\n              code: 'rdfDirection not set',\n              level: 'warning',\n              message: 'rdfDirection not set for @direction.',\n              details: {\n                object: object.value\n              }\n            },\n            options\n          });\n        }\n      }\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list = _listToRDF(\n      item['@list'], issuer, dataset, graphTerm, rdfDirection, options);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'relative object reference',\n          level: 'warning',\n          message: 'Relative object reference found.',\n          details: {\n            object: object.value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n\n  return object;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/toRdf.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/types.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/types.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is an Array.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Array, false if not.\n */\napi.isArray = Array.isArray;\n\n/**\n * Returns true if the given value is a Boolean.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Boolean, false if not.\n */\napi.isBoolean = v => (typeof v === 'boolean' ||\n  Object.prototype.toString.call(v) === '[object Boolean]');\n\n/**\n * Returns true if the given value is a double.\n *\n * @param v the value to check.\n *\n * @return true if the value is a double, false if not.\n */\napi.isDouble = v => api.isNumber(v) &&\n  (String(v).indexOf('.') !== -1 || Math.abs(v) >= 1e21);\n\n/**\n * Returns true if the given value is an empty Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an empty Object, false if not.\n */\napi.isEmptyObject = v => api.isObject(v) && Object.keys(v).length === 0;\n\n/**\n * Returns true if the given value is a Number.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Number, false if not.\n */\napi.isNumber = v => (typeof v === 'number' ||\n  Object.prototype.toString.call(v) === '[object Number]');\n\n/**\n * Returns true if the given value is numeric.\n *\n * @param v the value to check.\n *\n * @return true if the value is numeric, false if not.\n */\napi.isNumeric = v => !isNaN(parseFloat(v)) && isFinite(v);\n\n/**\n * Returns true if the given value is an Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Object, false if not.\n */\napi.isObject = v => Object.prototype.toString.call(v) === '[object Object]';\n\n/**\n * Returns true if the given value is a String.\n *\n * @param v the value to check.\n *\n * @return true if the value is a String, false if not.\n */\napi.isString = v => (typeof v === 'string' ||\n  Object.prototype.toString.call(v) === '[object String]');\n\n/**\n * Returns true if the given value is undefined.\n *\n * @param v the value to check.\n *\n * @return true if the value is undefined, false if not.\n */\napi.isUndefined = v => typeof v === 'undefined';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/types.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/url.js":
/*!****************************************!*\
  !*** ./node_modules/jsonld/lib/url.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n// define URL parser\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n// with local jsonld.js modifications\napi.parsers = {\n  simple: {\n    // RFC 3986 basic parts\n    keys: [\n      'href', 'scheme', 'authority', 'path', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/\n  },\n  full: {\n    keys: [\n      'href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password',\n      'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(?:(((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\napi.parse = (str, parser) => {\n  const parsed = {};\n  const o = api.parsers[parser || 'full'];\n  const m = o.regex.exec(str);\n  let i = o.keys.length;\n  while(i--) {\n    parsed[o.keys[i]] = (m[i] === undefined) ? null : m[i];\n  }\n\n  // remove default ports in found in URLs\n  if((parsed.scheme === 'https' && parsed.port === '443') ||\n    (parsed.scheme === 'http' && parsed.port === '80')) {\n    parsed.href = parsed.href.replace(':' + parsed.port, '');\n    parsed.authority = parsed.authority.replace(':' + parsed.port, '');\n    parsed.port = null;\n  }\n\n  parsed.normalizedPath = api.removeDotSegments(parsed.path);\n  return parsed;\n};\n\n/**\n * Prepends a base IRI to the given relative IRI.\n *\n * @param base the base IRI.\n * @param iri the relative IRI.\n *\n * @return the absolute IRI.\n */\napi.prependBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n  // already an absolute IRI\n  if(api.isAbsolute(iri)) {\n    return iri;\n  }\n\n  // parse base if it is a string\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // parse given IRI\n  const rel = api.parse(iri);\n\n  // per RFC3986 5.2.2\n  const transform = {\n    protocol: base.protocol || ''\n  };\n\n  if(rel.authority !== null) {\n    transform.authority = rel.authority;\n    transform.path = rel.path;\n    transform.query = rel.query;\n  } else {\n    transform.authority = base.authority;\n\n    if(rel.path === '') {\n      transform.path = base.path;\n      if(rel.query !== null) {\n        transform.query = rel.query;\n      } else {\n        transform.query = base.query;\n      }\n    } else {\n      if(rel.path.indexOf('/') === 0) {\n        // IRI represents an absolute path\n        transform.path = rel.path;\n      } else {\n        // merge paths\n        let path = base.path;\n\n        // append relative path to the end of the last directory from base\n        path = path.substr(0, path.lastIndexOf('/') + 1);\n        if((path.length > 0 || base.authority) && path.substr(-1) !== '/') {\n          path += '/';\n        }\n        path += rel.path;\n\n        transform.path = path;\n      }\n      transform.query = rel.query;\n    }\n  }\n\n  if(rel.path !== '') {\n    // remove slashes and dots in path\n    transform.path = api.removeDotSegments(transform.path);\n  }\n\n  // construct URL\n  let rval = transform.protocol;\n  if(transform.authority !== null) {\n    rval += '//' + transform.authority;\n  }\n  rval += transform.path;\n  if(transform.query !== null) {\n    rval += '?' + transform.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes a base IRI from the given absolute IRI.\n *\n * @param base the base IRI.\n * @param iri the absolute IRI.\n *\n * @return the relative IRI if relative to base, otherwise the absolute IRI.\n */\napi.removeBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // establish base root\n  let root = '';\n  if(base.href !== '') {\n    root += (base.protocol || '') + '//' + (base.authority || '');\n  } else if(iri.indexOf('//')) {\n    // support network-path reference with empty base\n    root += '//';\n  }\n\n  // IRI not relative to base\n  if(iri.indexOf(root) !== 0) {\n    return iri;\n  }\n\n  // remove root from IRI and parse remainder\n  const rel = api.parse(iri.substr(root.length));\n\n  // remove path segments that match (do not remove last segment unless there\n  // is a hash or query)\n  const baseSegments = base.normalizedPath.split('/');\n  const iriSegments = rel.normalizedPath.split('/');\n  const last = (rel.fragment || rel.query) ? 0 : 1;\n  while(baseSegments.length > 0 && iriSegments.length > last) {\n    if(baseSegments[0] !== iriSegments[0]) {\n      break;\n    }\n    baseSegments.shift();\n    iriSegments.shift();\n  }\n\n  // use '../' for each non-matching base segment\n  let rval = '';\n  if(baseSegments.length > 0) {\n    // don't count the last segment (if it ends with '/' last path doesn't\n    // count and if it doesn't end with '/' it isn't a path)\n    baseSegments.pop();\n    for(let i = 0; i < baseSegments.length; ++i) {\n      rval += '../';\n    }\n  }\n\n  // prepend remaining segments\n  rval += iriSegments.join('/');\n\n  // add query and hash\n  if(rel.query !== null) {\n    rval += '?' + rel.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes dot segments from a URL path.\n *\n * @param path the path to remove dot segments from.\n */\napi.removeDotSegments = path => {\n  // RFC 3986 5.2.4 (reworked)\n\n  // empty path shortcut\n  if(path.length === 0) {\n    return '';\n  }\n\n  const input = path.split('/');\n  const output = [];\n\n  while(input.length > 0) {\n    const next = input.shift();\n    const done = input.length === 0;\n\n    if(next === '.') {\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    if(next === '..') {\n      output.pop();\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    output.push(next);\n  }\n\n  // if path was absolute, ensure output has leading /\n  if(path[0] === '/' && output.length > 0 && output[0] !== '') {\n    output.unshift('');\n  }\n  if(output.length === 1 && output[0] === '') {\n    return '/';\n  }\n\n  return output.join('/');\n};\n\n// TODO: time better isAbsolute/isRelative checks using full regexes:\n// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html\n\n// regex to check for absolute IRI (starting scheme and ':') or blank node IRI\nconst isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\\s]*$/;\n\n/**\n * Returns true if the given value is an absolute IRI or blank node IRI, false\n * if not.\n * Note: This weak check only checks for a correct starting scheme.\n *\n * @param v the value to check.\n *\n * @return true if the value is an absolute IRI, false if not.\n */\napi.isAbsolute = v => types.isString(v) && isAbsoluteRegex.test(v);\n\n/**\n * Returns true if the given value is a relative IRI, false if not.\n * Note: this is a weak check.\n *\n * @param v the value to check.\n *\n * @return true if the value is a relative IRI, false if not.\n */\napi.isRelative = v => types.isString(v);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/url.js?");

/***/ }),

/***/ "./node_modules/jsonld/lib/util.js":
/*!*****************************************!*\
  !*** ./node_modules/jsonld/lib/util.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/jsonld/lib/types.js\");\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = (__webpack_require__(/*! rdf-canonize */ \"./node_modules/rdf-canonize/index.js\").IdentifierIssuer);\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"./node_modules/jsonld/lib/JsonLdError.js\");\n\n// constants\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nconst REGEX_KEYWORD = /^@[a-zA-Z]+$/;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\napi.REGEX_BCP47 = REGEX_BCP47;\napi.REGEX_KEYWORD = REGEX_KEYWORD;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result.rel || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = (v, isFrame) => {\n  if(types.isString(v)) {\n    return;\n  }\n\n  if(types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n  if(isFrame && types.isObject(v)) {\n    switch(Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if('@default' in v &&\n          api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n    }\n  }\n\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n    'strings, an empty object, ' +\n    'or a default object.', 'jsonld.SyntaxError',\n    {code: 'invalid type value', value: v});\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jsonld/lib/util.js?");

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/lru-cache/index.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/index.js":
/*!********************************************!*\
  !*** ./node_modules/rdf-canonize/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n *\n * @author Dave Longley\n *\n * Copyright 2010-2021 Digital Bazaar, Inc.\n */\nmodule.exports = __webpack_require__(/*! ./lib */ \"./node_modules/rdf-canonize/lib/index.js\");\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/index.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/IdentifierIssuer.js":
/*!***********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/IdentifierIssuer.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class IdentifierIssuer {\n  /**\n   * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique\n   * identifiers, keeping track of any previously issued identifiers.\n   *\n   * @param prefix the prefix to use ('<prefix><counter>').\n   * @param existing an existing Map to use.\n   * @param counter the counter to use.\n   */\n  constructor(prefix, existing = new Map(), counter = 0) {\n    this.prefix = prefix;\n    this._existing = existing;\n    this.counter = counter;\n  }\n\n  /**\n   * Copies this IdentifierIssuer.\n   *\n   * @return a copy of this IdentifierIssuer.\n   */\n  clone() {\n    const {prefix, _existing, counter} = this;\n    return new IdentifierIssuer(prefix, new Map(_existing), counter);\n  }\n\n  /**\n   * Gets the new identifier for the given old identifier, where if no old\n   * identifier is given a new identifier will be generated.\n   *\n   * @param [old] the old identifier to get the new identifier for.\n   *\n   * @return the new identifier.\n   */\n  getId(old) {\n    // return existing old identifier\n    const existing = old && this._existing.get(old);\n    if(existing) {\n      return existing;\n    }\n\n    // get next identifier\n    const identifier = this.prefix + this.counter;\n    this.counter++;\n\n    // save mapping\n    if(old) {\n      this._existing.set(old, identifier);\n    }\n\n    return identifier;\n  }\n\n  /**\n   * Returns true if the given old identifer has already been assigned a new\n   * identifier.\n   *\n   * @param old the old identifier to check.\n   *\n   * @return true if the old identifier has been assigned a new identifier,\n   *   false if not.\n   */\n  hasId(old) {\n    return this._existing.has(old);\n  }\n\n  /**\n   * Returns all of the IDs that have been issued new IDs in the order in\n   * which they were issued new IDs.\n   *\n   * @return the list of old IDs that has been issued new IDs in order.\n   */\n  getOldIds() {\n    return [...this._existing.keys()];\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/IdentifierIssuer.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/MessageDigest-browser.js":
/*!****************************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/MessageDigest-browser.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n\nconst crypto = self.crypto || self.msCrypto;\n\nmodule.exports = class MessageDigest {\n  /**\n   * Creates a new MessageDigest.\n   *\n   * @param algorithm the algorithm to use.\n   */\n  constructor(algorithm) {\n    // check if crypto.subtle is available\n    // check is here rather than top-level to only fail if class is used\n    if(!(crypto && crypto.subtle)) {\n      throw new Error('crypto.subtle not found.');\n    }\n    if(algorithm === 'sha256') {\n      this.algorithm = {name: 'SHA-256'};\n    } else if(algorithm === 'sha1') {\n      this.algorithm = {name: 'SHA-1'};\n    } else {\n      throw new Error(`Unsupported algorithm \"${algorithm}\".`);\n    }\n    this._content = '';\n  }\n\n  update(msg) {\n    this._content += msg;\n  }\n\n  async digest() {\n    const data = new TextEncoder().encode(this._content);\n    const buffer = new Uint8Array(\n      await crypto.subtle.digest(this.algorithm, data));\n    // return digest in hex\n    let hex = '';\n    for(let i = 0; i < buffer.length; ++i) {\n      hex += buffer[i].toString(16).padStart(2, '0');\n    }\n    return hex;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/MessageDigest-browser.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/NQuads.js":
/*!*************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/NQuads.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// eslint-disable-next-line no-unused-vars\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nconst REGEX = {};\n(() => {\n  const iri = '(?:<([^:]+:[^>]*)>)';\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  const PN_CHARS_BASE =\n    'A-Z' + 'a-z' +\n    '\\u00C0-\\u00D6' +\n    '\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02FF' +\n    '\\u0370-\\u037D' +\n    '\\u037F-\\u1FFF' +\n    '\\u200C-\\u200D' +\n    '\\u2070-\\u218F' +\n    '\\u2C00-\\u2FEF' +\n    '\\u3001-\\uD7FF' +\n    '\\uF900-\\uFDCF' +\n    '\\uFDF0-\\uFFFD';\n    // TODO:\n    //'\\u10000-\\uEFFFF';\n  const PN_CHARS_U =\n    PN_CHARS_BASE +\n    '_';\n  const PN_CHARS =\n    PN_CHARS_U +\n    '0-9' +\n    '-' +\n    '\\u00B7' +\n    '\\u0300-\\u036F' +\n    '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL =\n    '(_:' +\n      '(?:[' + PN_CHARS_U + '0-9])' +\n      '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' +\n    ')';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + iri + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  const subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  const property = iri + ws;\n  const object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp(\n    '^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param input the N-Quads input to parse.\n   *\n   * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n\n    const graphs = {};\n\n    // split N-Quad input into lines\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n    for(const line of lines) {\n      lineNumber++;\n\n      // skip empty lines\n      if(REGEX.empty.test(line)) {\n        continue;\n      }\n\n      // parse quad\n      const match = line.match(REGEX.quad);\n      if(match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      }\n\n      // create RDF quad\n      const quad = {subject: null, predicate: null, object: null, graph: null};\n\n      // get subject\n      if(match[1] !== undefined) {\n        quad.subject = {termType: TYPE_NAMED_NODE, value: match[1]};\n      } else {\n        quad.subject = {termType: TYPE_BLANK_NODE, value: match[2]};\n      }\n\n      // get predicate\n      quad.predicate = {termType: TYPE_NAMED_NODE, value: match[3]};\n\n      // get object\n      if(match[4] !== undefined) {\n        quad.object = {termType: TYPE_NAMED_NODE, value: match[4]};\n      } else if(match[5] !== undefined) {\n        quad.object = {termType: TYPE_BLANK_NODE, value: match[5]};\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n        if(match[7] !== undefined) {\n          quad.object.datatype.value = match[7];\n        } else if(match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n        quad.object.value = _unescape(match[6]);\n      }\n\n      // get graph\n      if(match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: match[9]\n        };\n      } else if(match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      }\n\n      // only add quad if it is unique in its graph\n      if(!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n        for(const q of quads) {\n          if(_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n        if(unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param dataset (array of quads) the RDF dataset to convert.\n   *\n   * @return the N-Quads string.\n   */\n  static serialize(dataset) {\n    if(!Array.isArray(dataset)) {\n      dataset = NQuads.legacyDatasetToQuads(dataset);\n    }\n    const quads = [];\n    for(const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n    return quads.sort().join('');\n  }\n\n  /**\n   * Converts RDF quad components to an N-Quad string (a single quad).\n   *\n   * @param {Object} s - N-Quad subject component.\n   * @param {Object} p - N-Quad predicate component.\n   * @param {Object} o - N-Quad object component.\n   * @param {Object} g - N-Quad graph component.\n   *\n   * @return {string} the N-Quad.\n   */\n  static serializeQuadComponents(s, p, o, g) {\n    let nquad = '';\n\n    // subject can only be NamedNode or BlankNode\n    if(s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${s.value}>`;\n    } else {\n      nquad += `${s.value}`;\n    }\n\n    // predicate can only be NamedNode\n    nquad += ` <${p.value}> `;\n\n    // object is NamedNode, BlankNode, or Literal\n    if(o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${o.value}>`;\n    } else if(o.termType === TYPE_BLANK_NODE) {\n      nquad += o.value;\n    } else {\n      nquad += `\"${_escape(o.value)}\"`;\n      if(o.datatype.value === RDF_LANGSTRING) {\n        if(o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if(o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${o.datatype.value}>`;\n      }\n    }\n\n    // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n    if(g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${g.value}>`;\n    } else if(g.termType === TYPE_BLANK_NODE) {\n      nquad += ` ${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param quad the RDF quad convert.\n   *\n   * @return the N-Quad string.\n   */\n  static serializeQuad(quad) {\n    return NQuads.serializeQuadComponents(\n      quad.subject, quad.predicate, quad.object, quad.graph);\n  }\n\n  /**\n   * Converts a legacy-formatted dataset to an array of quads dataset per\n   * http://rdf.js.org/.\n   *\n   * @param dataset the legacy dataset to convert.\n   *\n   * @return the array of quads dataset.\n   */\n  static legacyDatasetToQuads(dataset) {\n    const quads = [];\n\n    const termTypeMap = {\n      'blank node': TYPE_BLANK_NODE,\n      IRI: TYPE_NAMED_NODE,\n      literal: TYPE_LITERAL\n    };\n\n    for(const graphName in dataset) {\n      const triples = dataset[graphName];\n      triples.forEach(triple => {\n        const quad = {};\n        for(const componentName in triple) {\n          const oldComponent = triple[componentName];\n          const newComponent = {\n            termType: termTypeMap[oldComponent.type],\n            value: oldComponent.value\n          };\n          if(newComponent.termType === TYPE_LITERAL) {\n            newComponent.datatype = {\n              termType: TYPE_NAMED_NODE\n            };\n            if('datatype' in oldComponent) {\n              newComponent.datatype.value = oldComponent.datatype;\n            }\n            if('language' in oldComponent) {\n              if(!('datatype' in oldComponent)) {\n                newComponent.datatype.value = RDF_LANGSTRING;\n              }\n              newComponent.language = oldComponent.language;\n            } else if(!('datatype' in oldComponent)) {\n              newComponent.datatype.value = XSD_STRING;\n            }\n          }\n          quad[componentName] = newComponent;\n        }\n        if(graphName === '@default') {\n          quad.graph = {\n            termType: TYPE_DEFAULT_GRAPH,\n            value: ''\n          };\n        } else {\n          quad.graph = {\n            termType: graphName.startsWith('_:') ?\n              TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n            value: graphName\n          };\n        }\n        quads.push(quad);\n      });\n    }\n\n    return quads;\n  }\n};\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if(!(t1.subject.termType === t2.subject.termType &&\n    t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if(!(t1.subject.value === t2.subject.value &&\n    t1.predicate.value === t2.predicate.value &&\n    t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if(t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return (\n    (t1.object.datatype.termType === t2.object.datatype.termType) &&\n    (t1.object.language === t2.object.language) &&\n    (t1.object.datatype.value === t2.object.datatype.value)\n  );\n}\n\nconst _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function(match) {\n    switch(match) {\n      case '\"': return '\\\\\"';\n      case '\\\\': return '\\\\\\\\';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n    }\n  });\n}\n\nconst _unescapeRegex =\n  /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function(match, code, u, U) {\n    if(code) {\n      switch(code) {\n        case 't': return '\\t';\n        case 'b': return '\\b';\n        case 'n': return '\\n';\n        case 'r': return '\\r';\n        case 'f': return '\\f';\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n      }\n    }\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/NQuads.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/Permuter.js":
/*!***************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/Permuter.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class Permuter {\n  /**\n   * A Permuter iterates over all possible permutations of the given array\n   * of elements.\n   *\n   * @param list the array of elements to iterate over.\n   */\n  constructor(list) {\n    // original array\n    this.current = list.sort();\n    // indicates whether there are more permutations\n    this.done = false;\n    // directional info for permutation algorithm\n    this.dir = new Map();\n    for(let i = 0; i < list.length; ++i) {\n      this.dir.set(list[i], true);\n    }\n  }\n\n  /**\n   * Returns true if there is another permutation.\n   *\n   * @return true if there is another permutation, false if not.\n   */\n  hasNext() {\n    return !this.done;\n  }\n\n  /**\n   * Gets the next permutation. Call hasNext() to ensure there is another one\n   * first.\n   *\n   * @return the next permutation.\n   */\n  next() {\n    // copy current permutation to return it\n    const {current, dir} = this;\n    const rval = current.slice();\n\n    /* Calculate the next permutation using the Steinhaus-Johnson-Trotter\n     permutation algorithm. */\n\n    // get largest mobile element k\n    // (mobile: element is greater than the one it is looking at)\n    let k = null;\n    let pos = 0;\n    const length = current.length;\n    for(let i = 0; i < length; ++i) {\n      const element = current[i];\n      const left = dir.get(element);\n      if((k === null || element > k) &&\n        ((left && i > 0 && element > current[i - 1]) ||\n        (!left && i < (length - 1) && element > current[i + 1]))) {\n        k = element;\n        pos = i;\n      }\n    }\n\n    // no more permutations\n    if(k === null) {\n      this.done = true;\n    } else {\n      // swap k and the element it is looking at\n      const swap = dir.get(k) ? pos - 1 : pos + 1;\n      current[pos] = current[swap];\n      current[swap] = k;\n\n      // reverse the direction of all elements larger than k\n      for(const element of current) {\n        if(element > k) {\n          dir.set(element, !dir.get(element));\n        }\n      }\n    }\n\n    return rval;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/Permuter.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URDNA2015.js":
/*!****************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URDNA2015.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"./node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\n\nmodule.exports = class URDNA2015 {\n  constructor({\n    createMessageDigest = () => new MessageDigest('sha256'),\n    canonicalIdMap = new Map(),\n    maxDeepIterations = Infinity\n  } = {}) {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n', canonicalIdMap);\n    this.createMessageDigest = createMessageDigest;\n    this.maxDeepIterations = maxDeepIterations;\n    this.quads = null;\n    this.deepIterations = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  async main(dataset) {\n    this.deepIterations = new Map();\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    let i = 0;\n    for(const id of nonNormalized) {\n      // Note: batch hashing first degree quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // steps 5.3.1 and 5.3.2:\n      await this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = await this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize away the copy here.\n      const nQuad = NQuads.serializeQuadComponents(\n        this._componentWithCanonicalId(quad.subject),\n        quad.predicate,\n        this._componentWithCanonicalId(quad.object),\n        this._componentWithCanonicalId(quad.graph)\n      );\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(nQuad);\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  async hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = this.createMessageDigest();\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = await md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  async hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = this.createMessageDigest();\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  async hashNDegreeQuads(id, issuer) {\n    const deepIterations = this.deepIterations.get(id) || 0;\n    if(deepIterations > this.maxDeepIterations) {\n      throw new Error(\n        `Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);\n    }\n    this.deepIterations.set(id, deepIterations + 1);\n\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = this.createMessageDigest();\n    const hashToRelated = await this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      let i = 0;\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n        // Note: batch permutations 3 at a time\n        if(++i % 3 === 0) {\n          await this._yield();\n        }\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = await this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: await md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // Note: batch hashing related blank node quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.1) For each component in quad, if component is the subject, object,\n      // and graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      await Promise.all([\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.subject, position: 's',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.object, position: 'o',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.graph, position: 'g',\n          id, issuer, hashToRelated\n        })\n      ]);\n    }\n\n    return hashToRelated;\n  }\n\n  async _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = await this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  async _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = await this.hashRelatedBlankNode(\n      related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  // canonical ids for 7.1\n  _componentWithCanonicalId(component) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      // create new BlankNode\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n\n  async _yield() {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URDNA2015.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URDNA2015Sync.js":
/*!********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URDNA2015Sync.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\n// FIXME: do not import; convert to requiring a\n// hash factory\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"./node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\n\nmodule.exports = class URDNA2015Sync {\n  constructor({\n    createMessageDigest = () => new MessageDigest('sha256'),\n    canonicalIdMap = new Map(),\n    maxDeepIterations = Infinity\n  } = {}) {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n', canonicalIdMap);\n    this.createMessageDigest = createMessageDigest;\n    this.maxDeepIterations = maxDeepIterations;\n    this.quads = null;\n    this.deepIterations = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  main(dataset) {\n    this.deepIterations = new Map();\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    for(const id of nonNormalized) {\n      // steps 5.3.1 and 5.3.2:\n      this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize away the copy here.\n      const nQuad = NQuads.serializeQuadComponents(\n        this._componentWithCanonicalId({component: quad.subject}),\n        quad.predicate,\n        this._componentWithCanonicalId({component: quad.object}),\n        this._componentWithCanonicalId({component: quad.graph})\n      );\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(nQuad);\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = this.createMessageDigest();\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = this.createMessageDigest();\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  hashNDegreeQuads(id, issuer) {\n    const deepIterations = this.deepIterations.get(id) || 0;\n    if(deepIterations > this.maxDeepIterations) {\n      throw new Error(\n        `Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);\n    }\n    this.deepIterations.set(id, deepIterations + 1);\n\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = this.createMessageDigest();\n    const hashToRelated = this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) For each component in quad, if component is the subject, object,\n      // or graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.subject, position: 's',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.object, position: 'o',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.graph, position: 'g',\n        id, issuer, hashToRelated\n      });\n    }\n\n    return hashToRelated;\n  }\n\n  _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = this.hashRelatedBlankNode(related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  // canonical ids for 7.1\n  _componentWithCanonicalId({component}) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      // create new BlankNode\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URDNA2015Sync.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URGNA2012.js":
/*!****************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URGNA2012.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst URDNA2015 = __webpack_require__(/*! ./URDNA2015 */ \"./node_modules/rdf-canonize/lib/URDNA2015.js\");\n\nmodule.exports = class URDNA2012 extends URDNA2015 {\n  constructor() {\n    super();\n    this.name = 'URGNA2012';\n    this.createMessageDigest = () => new MessageDigest('sha1');\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component, key) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    if(key === 'graph') {\n      return {\n        termType: 'BlankNode',\n        value: '_:g'\n      };\n    }\n    return {\n      termType: 'BlankNode',\n      value: (component.value === id ? '_:a' : '_:z')\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return quad.predicate.value;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // 3.1) If the quad's subject is a blank node that does not match\n      // identifier, set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for subject as related,\n      // quad, path identifier issuer as issuer, and p as position.\n      let position;\n      let related;\n      if(quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n        related = quad.subject.value;\n        position = 'p';\n      } else if(\n        quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n        // 3.2) Otherwise, if quad's object is a blank node that does not match\n        // identifier, to the result of the Hash Related Blank Node algorithm,\n        // passing the blank node identifier for object as related, quad, path\n        // identifier issuer as issuer, and r as position.\n        related = quad.object.value;\n        position = 'r';\n      } else {\n        // 3.3) Otherwise, continue to the next quad.\n        continue;\n      }\n      // Note: batch hashing related blank nodes 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.4) Add a mapping of hash to the blank node identifier for the\n      // component that matched (subject or object) to hash to related blank\n      // nodes map, adding an entry as necessary.\n      const hash = await this.hashRelatedBlankNode(\n        related, quad, issuer, position);\n      const entries = hashToRelated.get(hash);\n      if(entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n\n    return hashToRelated;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URGNA2012.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/URGNA2012Sync.js":
/*!********************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/URGNA2012Sync.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"./node_modules/rdf-canonize/lib/MessageDigest-browser.js\");\nconst URDNA2015Sync = __webpack_require__(/*! ./URDNA2015Sync */ \"./node_modules/rdf-canonize/lib/URDNA2015Sync.js\");\n\nmodule.exports = class URDNA2012Sync extends URDNA2015Sync {\n  constructor() {\n    super();\n    this.name = 'URGNA2012';\n    this.createMessageDigest = () => new MessageDigest('sha1');\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component, key) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    if(key === 'graph') {\n      return {\n        termType: 'BlankNode',\n        value: '_:g'\n      };\n    }\n    return {\n      termType: 'BlankNode',\n      value: (component.value === id ? '_:a' : '_:z')\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return quad.predicate.value;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) If the quad's subject is a blank node that does not match\n      // identifier, set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for subject as related,\n      // quad, path identifier issuer as issuer, and p as position.\n      let position;\n      let related;\n      if(quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n        related = quad.subject.value;\n        position = 'p';\n      } else if(\n        quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n        // 3.2) Otherwise, if quad's object is a blank node that does not match\n        // identifier, to the result of the Hash Related Blank Node algorithm,\n        // passing the blank node identifier for object as related, quad, path\n        // identifier issuer as issuer, and r as position.\n        related = quad.object.value;\n        position = 'r';\n      } else {\n        // 3.3) Otherwise, continue to the next quad.\n        continue;\n      }\n      // 3.4) Add a mapping of hash to the blank node identifier for the\n      // component that matched (subject or object) to hash to related blank\n      // nodes map, adding an entry as necessary.\n      const hash = this.hashRelatedBlankNode(related, quad, issuer, position);\n      const entries = hashToRelated.get(hash);\n      if(entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n\n    return hashToRelated;\n  }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/URGNA2012Sync.js?");

/***/ }),

/***/ "./node_modules/rdf-canonize/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/rdf-canonize/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n * This library works in the browser and node.js.\n *\n * BSD 3-Clause License\n * Copyright (c) 2016-2023 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nconst URDNA2015 = __webpack_require__(/*! ./URDNA2015 */ \"./node_modules/rdf-canonize/lib/URDNA2015.js\");\nconst URGNA2012 = __webpack_require__(/*! ./URGNA2012 */ \"./node_modules/rdf-canonize/lib/URGNA2012.js\");\nconst URDNA2015Sync = __webpack_require__(/*! ./URDNA2015Sync */ \"./node_modules/rdf-canonize/lib/URDNA2015Sync.js\");\nconst URGNA2012Sync = __webpack_require__(/*! ./URGNA2012Sync */ \"./node_modules/rdf-canonize/lib/URGNA2012Sync.js\");\n\n// optional native support\nlet rdfCanonizeNative;\ntry {\n  rdfCanonizeNative = __webpack_require__(/*! rdf-canonize-native */ \"?2b19\");\n} catch(e) {}\n\n// return a dataset from input dataset or legacy dataset\nfunction _inputToDataset(input/*, options*/) {\n  // back-compat with legacy dataset\n  if(!Array.isArray(input)) {\n    return exports.NQuads.legacyDatasetToQuads(input);\n  }\n  return input;\n}\n\n// expose helpers\nexports.NQuads = __webpack_require__(/*! ./NQuads */ \"./node_modules/rdf-canonize/lib/NQuads.js\");\nexports.IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"./node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\n\n/**\n * Get or set native API.\n *\n * @param api the native API.\n *\n * @return the currently set native API.\n */\nexports._rdfCanonizeNative = function(api) {\n  if(api) {\n    rdfCanonizeNative = api;\n  }\n  return rdfCanonizeNative;\n};\n\n/**\n * Asynchronously canonizes an RDF dataset.\n *\n * @param {Array|object|string} input - The input to canonize given as a\n *   dataset or legacy dataset.\n * @param {object} options - The options to use:\n *   {string} algorithm - The canonicalization algorithm to use, `URDNA2015` or\n *     `URGNA2012`.\n *   {Function} [createMessageDigest] - A factory function for creating a\n *     `MessageDigest` interface that overrides the built-in message digest\n *     implementation used by the canonize algorithm; note that using a hash\n *     algorithm (or HMAC algorithm) that differs from the one specified by\n *     the canonize algorithm will result in different output.\n *   {Map} [canonicalIdMap] - An optional Map to be populated by the canonical\n *     identifier issuer with the bnode identifier mapping generated by the\n *     canonicalization algorithm.\n *   {boolean} [useNative=false] - Use native implementation.\n *   {number} [maxDeepIterations=Infinity] - The maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in URDNA2015) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets, a recommended value is\n *     `1`.\n *\n * @return a Promise that resolves to the canonicalized RDF Dataset.\n */\nexports.canonize = async function(input, options) {\n  const dataset = _inputToDataset(input, options);\n\n  if(options.useNative) {\n    if(!rdfCanonizeNative) {\n      throw new Error('rdf-canonize-native not available');\n    }\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"useNative\".');\n    }\n    return new Promise((resolve, reject) =>\n      rdfCanonizeNative.canonize(dataset, options, (err, canonical) =>\n        err ? reject(err) : resolve(canonical)));\n  }\n\n  if(options.algorithm === 'URDNA2015') {\n    return new URDNA2015(options).main(dataset);\n  }\n  if(options.algorithm === 'URGNA2012') {\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"URGNA2012\".');\n    }\n    return new URGNA2012(options).main(dataset);\n  }\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n\n/**\n * This method is no longer available in the public API, it is for testing\n * only. It synchronously canonizes an RDF dataset and does not work in the\n * browser.\n *\n * @param {Array|object|string} input - The input to canonize given as a\n *   dataset or legacy dataset.\n * @param {object} options - The options to use:\n *   {string} algorithm - The canonicalization algorithm to use, `URDNA2015` or\n *     `URGNA2012`.\n *   {Function} [createMessageDigest] - A factory function for creating a\n *     `MessageDigest` interface that overrides the built-in message digest\n *     implementation used by the canonize algorithm; note that using a hash\n *     algorithm (or HMAC algorithm) that differs from the one specified by\n *     the canonize algorithm will result in different output.\n *   {boolean} [useNative=false] - Use native implementation.\n *   {number} [maxDeepIterations=Infinity] - The maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in URDNA2015) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets, a recommended value is\n *     `1`.\n *\n * @return the RDF dataset in canonical form.\n */\nexports._canonizeSync = function(input, options) {\n  const dataset = _inputToDataset(input, options);\n\n  if(options.useNative) {\n    if(!rdfCanonizeNative) {\n      throw new Error('rdf-canonize-native not available');\n    }\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"useNative\".');\n    }\n    return rdfCanonizeNative.canonizeSync(dataset, options);\n  }\n  if(options.algorithm === 'URDNA2015') {\n    return new URDNA2015Sync(options).main(dataset);\n  }\n  if(options.algorithm === 'URGNA2012') {\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"URGNA2012\".');\n    }\n    return new URGNA2012Sync(options).main(dataset);\n  }\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/rdf-canonize/lib/index.js?");

/***/ }),

/***/ "./node_modules/serialize-error/index.js":
/*!***********************************************!*\
  !*** ./node_modules/serialize-error/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass NonError extends Error {\n\tconstructor(message) {\n\t\tsuper(NonError._prepareSuperMessage(message));\n\t\tObject.defineProperty(this, 'name', {\n\t\t\tvalue: 'NonError',\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, NonError);\n\t\t}\n\t}\n\n\tstatic _prepareSuperMessage(message) {\n\t\ttry {\n\t\t\treturn JSON.stringify(message);\n\t\t} catch {\n\t\t\treturn String(message);\n\t\t}\n\t}\n}\n\nconst commonProperties = [\n\t{property: 'name', enumerable: false},\n\t{property: 'message', enumerable: false},\n\t{property: 'stack', enumerable: false},\n\t{property: 'code', enumerable: true}\n];\n\nconst isCalled = Symbol('.toJSON called');\n\nconst toJSON = from => {\n\tfrom[isCalled] = true;\n\tconst json = from.toJSON();\n\tdelete from[isCalled];\n\treturn json;\n};\n\nconst destroyCircular = ({\n\tfrom,\n\tseen,\n\tto_,\n\tforceEnumerable,\n\tmaxDepth,\n\tdepth\n}) => {\n\tconst to = to_ || (Array.isArray(from) ? [] : {});\n\n\tseen.push(from);\n\n\tif (depth >= maxDepth) {\n\t\treturn to;\n\t}\n\n\tif (typeof from.toJSON === 'function' && from[isCalled] !== true) {\n\t\treturn toJSON(from);\n\t}\n\n\tfor (const [key, value] of Object.entries(from)) {\n\t\tif (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n\t\t\tto[key] = '[object Buffer]';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\tto[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!seen.includes(from[key])) {\n\t\t\tdepth++;\n\n\t\t\tto[key] = destroyCircular({\n\t\t\t\tfrom: from[key],\n\t\t\t\tseen: seen.slice(),\n\t\t\t\tforceEnumerable,\n\t\t\t\tmaxDepth,\n\t\t\t\tdepth\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tfor (const {property, enumerable} of commonProperties) {\n\t\tif (typeof from[property] === 'string') {\n\t\t\tObject.defineProperty(to, property, {\n\t\t\t\tvalue: from[property],\n\t\t\t\tenumerable: forceEnumerable ? true : enumerable,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\t}\n\n\treturn to;\n};\n\nconst serializeError = (value, options = {}) => {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (typeof value === 'object' && value !== null) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tforceEnumerable: true,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0\n\t\t});\n\t}\n\n\t// People sometimes throw things besides Error objects\n\tif (typeof value === 'function') {\n\t\t// `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n\t\treturn `[Function: ${(value.name || 'anonymous')}]`;\n\t}\n\n\treturn value;\n};\n\nconst deserializeError = (value, options = {}) => {\n\tconst {maxDepth = Number.POSITIVE_INFINITY} = options;\n\n\tif (value instanceof Error) {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n\t\tconst newError = new Error(); // eslint-disable-line unicorn/error-message\n\t\tdestroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tto_: newError,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0\n\t\t});\n\t\treturn newError;\n\t}\n\n\treturn new NonError(value);\n};\n\nmodule.exports = {\n\tserializeError,\n\tdeserializeError\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/serialize-error/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof __webpack_require__.g === \"undefined\" ? this : __webpack_require__.g : self));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID\n});\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://respec-vc/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/yallist/iterator.js?");

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/yallist/yallist.js?");

/***/ }),

/***/ "?51ea":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://respec-vc/crypto_(ignored)?");

/***/ }),

/***/ "?2b19":
/*!*************************************!*\
  !*** rdf-canonize-native (ignored) ***!
  \*************************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://respec-vc/rdf-canonize-native_(ignored)?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/disclose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/disclose.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDiscloseCryptosuite: () => (/* binding */ createDiscloseCryptosuite)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/bls12-381-multikey */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _sdFunctions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sdFunctions.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sdFunctions.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\nfunction createDiscloseCryptosuite({\n  proofId, selectivePointers = [], presentationHeader = new Uint8Array()\n} = {}) {\n  const options = {proofId, selectivePointers, presentationHeader};\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_4__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.requiredAlgorithm,\n    createVerifier: _throwDeriveUsageError,\n    createVerifyData: _throwDeriveUsageError,\n    createProofValue: _throwDeriveUsageError,\n    derive: _derive,\n    options\n  };\n}\n\nasync function _createDisclosureData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_4__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_4__.name}\".`);\n  }\n  if(!(cryptosuite.options && typeof cryptosuite.options === 'object')) {\n    throw new TypeError(`\"cryptosuite.options\" must be an object.`);\n  }\n  if(!(cryptosuite.options.presentationHeader instanceof Uint8Array)) {\n    throw new TypeError(\n      '\"cryptosuite.options.presentationHeader\" must be a Uint8Array.');\n  }\n\n  // 1. Parse base `proof` to get parameters for disclosure proof.\n  const {\n    bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n  } = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_2__.parseBaseProofValue)({proof});\n\n  // 2. Ensure mandatory and / or selective data will be disclosed.\n  const {selectivePointers = []} = cryptosuite.options;\n  if(!(mandatoryPointers?.length > 0 || selectivePointers?.length > 0)) {\n    throw new Error('Nothing selected for disclosure.');\n  }\n\n  // 3. Create HMAC label replacement function from `hmacKey` to randomize\n  //   bnode identifiers.\n  const hmac = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.createHmac)({key: hmacKey});\n  const labelMapFactoryFunction = (0,_sdFunctions_js__WEBPACK_IMPORTED_MODULE_3__.createShuffledIdLabelMapFunction)({hmac});\n\n  // 4. Canonicalize document with randomized bnode labels and group N-Quads\n  //  by mandatory, selective, and combined pointers.\n  const options = {documentLoader};\n  const combinedPointers = mandatoryPointers.concat(selectivePointers);\n  const {\n    groups: {\n      mandatory: mandatoryGroup,\n      selective: selectiveGroup,\n      combined: combinedGroup,\n    },\n    labelMap\n  } = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.canonicalizeAndGroup)({\n    document,\n    labelMapFactoryFunction,\n    groups: {\n      mandatory: mandatoryPointers,\n      selective: selectivePointers,\n      combined: combinedPointers\n    },\n    options\n  });\n\n  // 5. Convert absolute indexes of mandatory N-Quads to indexes relative to\n  // the combined output to be revealed.\n  let relativeIndex = 0;\n  const mandatoryIndexes = [];\n  for(const absoluteIndex of combinedGroup.matching.keys()) {\n    if(mandatoryGroup.matching.has(absoluteIndex)) {\n      mandatoryIndexes.push(relativeIndex);\n    }\n    relativeIndex++;\n  }\n\n  // 6. Convert absolute indexes of selective N-Quads to indexes relative to\n  // the non-mandatory messages as these are the indexes used in BBS.\n  relativeIndex = 0;\n  const selectiveIndexes = [];\n  for(const absoluteIndex of mandatoryGroup.nonMatching.keys()) {\n    if(selectiveGroup.matching.has(absoluteIndex)) {\n      selectiveIndexes.push(relativeIndex);\n    }\n    relativeIndex++;\n  }\n\n  // 7. Set `bbsMessages` to an array with the UTF-8 encoding of each\n  // non-mandatory message.\n  const bbsMessages = [...mandatoryGroup.nonMatching.values()]\n    .map(_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.stringToUtf8Bytes);\n\n  // 8. Produce reveal document using combination of mandatory and selective\n  //   pointers.\n  const revealDoc = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.selectJsonLd)({document, pointers: combinedPointers});\n\n  // 9. Canonicalize deskolemized N-Quads for the combined group to generate\n  //   the canonical blank node labels a verifier will see.\n  let canonicalIdMap = new Map();\n  await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.canonicalize)(\n    combinedGroup.deskolemizedNQuads.join(''),\n    {...options, inputFormat: 'application/n-quads', canonicalIdMap});\n  // implementation-specific bnode prefix fix\n  canonicalIdMap = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.stripBlankNodePrefixes)(canonicalIdMap);\n\n  // 10. Produce a blank node label map from the canonical blank node labels\n  //   the verifier will see to the HMAC labels.\n  const verifierLabelMap = new Map();\n  for(const [inputLabel, verifierLabel] of canonicalIdMap) {\n    verifierLabelMap.set(verifierLabel, labelMap.get(inputLabel));\n  }\n\n  // 11. Generate BBS proof.\n  const importedKey = await _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__.fromRaw({\n    algorithm: _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__.ALGORITHMS.BBS_BLS12381_SHA256, publicKey\n  });\n  const {presentationHeader} = cryptosuite.options;\n  const bbsProof = await importedKey.deriveProof({\n    signature: bbsSignature, header: bbsHeader, messages: bbsMessages,\n    presentationHeader, disclosedMessageIndexes: selectiveIndexes\n  });\n\n  // 12. Return data used by cryptosuite to disclose.\n  return {\n    bbsProof, labelMap: verifierLabelMap,\n    mandatoryIndexes, selectiveIndexes, presentationHeader,\n    revealDoc\n  };\n}\n\nasync function _derive({\n  cryptosuite, document, purpose, proofSet,\n  documentLoader, dataIntegrityProof\n}) {\n  // find matching base `proof` in `proofSet`\n  const {options: {proofId}} = cryptosuite;\n  const baseProof = await _findProof({proofId, proofSet, dataIntegrityProof});\n\n  // ensure `purpose` matches `baseProof`\n  if(baseProof.proofPurpose !== purpose.term) {\n    throw new Error(\n      'Base proof purpose does not match purpose for derived proof.');\n  }\n\n  // generate data for disclosure\n  const {\n    bbsProof, labelMap,\n    mandatoryIndexes, selectiveIndexes, presentationHeader,\n    revealDoc\n  } = await _createDisclosureData(\n    {cryptosuite, document, proof: baseProof, documentLoader});\n\n  // create new disclosure proof\n  const newProof = {...baseProof};\n  newProof.proofValue = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_2__.serializeDisclosureProofValue)({\n    bbsProof, labelMap, mandatoryIndexes, selectiveIndexes,\n    presentationHeader\n  });\n\n  // attach proof to reveal doc w/o context\n  delete newProof['@context'];\n  revealDoc.proof = newProof;\n  return revealDoc;\n}\n\nasync function _findProof({proofId, proofSet, dataIntegrityProof}) {\n  let proof;\n  if(proofId) {\n    proof = proofSet.find(p => p.id === proofId);\n  } else {\n    // no `proofId` given, so see if a single matching proof exists\n    for(const p of proofSet) {\n      if(await dataIntegrityProof.matchProof({proof: p})) {\n        if(proof) {\n          // already matched\n          throw new Error(\n            'Multiple matching proofs; a \"proofId\" must be specified.');\n        }\n        proof = p;\n      }\n    }\n  }\n  if(!proof) {\n    throw new Error(\n      'No matching base proof found from which to derive a disclosure proof.');\n  }\n  return proof;\n}\n\nfunction _throwDeriveUsageError() {\n  throw new Error('This cryptosuite must only be used with \"derive\".');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/disclose.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDiscloseCryptosuite: () => (/* reexport safe */ _disclose_js__WEBPACK_IMPORTED_MODULE_0__.createDiscloseCryptosuite),\n/* harmony export */   createSignCryptosuite: () => (/* reexport safe */ _sign_js__WEBPACK_IMPORTED_MODULE_1__.createSignCryptosuite),\n/* harmony export */   createVerifyCryptosuite: () => (/* reexport safe */ _verify_js__WEBPACK_IMPORTED_MODULE_2__.createVerifyCryptosuite),\n/* harmony export */   requiredAlgorithm: () => (/* reexport safe */ _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__.requiredAlgorithm)\n/* harmony export */ });\n/* harmony import */ var _disclose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./disclose.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/disclose.js\");\n/* harmony import */ var _sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sign.js\");\n/* harmony import */ var _verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./verify.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/verify.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n*/\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\nconst name = 'bbs-2023';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concatBuffers: () => (/* binding */ concatBuffers),\n/* harmony export */   parseBaseProofValue: () => (/* binding */ parseBaseProofValue),\n/* harmony export */   parseDisclosureProofValue: () => (/* binding */ parseDisclosureProofValue),\n/* harmony export */   serializeBaseProofValue: () => (/* binding */ serializeBaseProofValue),\n/* harmony export */   serializeDisclosureProofValue: () => (/* binding */ serializeDisclosureProofValue)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n/* CBOR proof value representation:\n0xd9 == 11011001\n110 = CBOR major type 6\n11001 = 25, 16-bit tag size (65536 possible values)\n0x5d = always the first 8-bits of a bbs-2023 tag\n0x02 | 0x03 = last 8-bits of a bbs-2023 tag indicating proof mode\nproof mode can be 2 = base, 3 = derived\n*/\nconst CBOR_PREFIX_BASE = new Uint8Array([0xd9, 0x5d, 0x02]);\nconst CBOR_PREFIX_DERIVED = new Uint8Array([0xd9, 0x5d, 0x03]);\n\n// CBOR decoder for implementations that use tag 64 for Uint8Array instead\n// of byte string major type 2\nconst TAGS = [];\nTAGS[64] = _decodeUint8Array;\n\nfunction concatBuffers(buffers) {\n  const bytes = new Uint8Array(buffers.reduce((acc, b) => acc + b.length, 0));\n  let offset = 0;\n  for(const b of buffers) {\n    bytes.set(b, offset);\n    offset += b.length;\n  }\n  return bytes;\n}\n\nfunction parseBaseProofValue({proof} = {}) {\n  try {\n    if(typeof proof?.proofValue !== 'string') {\n      throw new TypeError('\"proof.proofValue\" must be a string.');\n    }\n    if(proof.proofValue[0] !== 'u') {\n      throw new Error('Only base64url multibase encoding is supported.');\n    }\n\n    // decode from base64url\n    const proofValue = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(proof.proofValue.slice(1));\n    if(!_startsWithBytes(proofValue, CBOR_PREFIX_BASE)) {\n      throw new TypeError('\"proof.proofValue\" must be a base proof.');\n    }\n\n    const payload = proofValue.subarray(CBOR_PREFIX_BASE.length);\n    const [\n      bbsSignature,\n      bbsHeader,\n      publicKey,\n      hmacKey,\n      mandatoryPointers\n    ] = cborg__WEBPACK_IMPORTED_MODULE_1__.decode(payload, {useMaps: true, tags: TAGS});\n\n    const params = {\n      bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n    };\n    _validateBaseProofParams(params);\n    return params;\n  } catch(e) {\n    const err = new TypeError(\n      'The proof does not include a valid \"proofValue\" property.');\n    err.cause = e;\n    throw err;\n  }\n}\n\nfunction parseDisclosureProofValue({proof} = {}) {\n  try {\n    if(typeof proof?.proofValue !== 'string') {\n      throw new TypeError('\"proof.proofValue\" must be a string.');\n    }\n    if(proof.proofValue[0] !== 'u') {\n      throw new Error('Only base64url multibase encoding is supported.');\n    }\n\n    // decode from base64url\n    const proofValue = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(proof.proofValue.slice(1));\n    if(!_startsWithBytes(proofValue, CBOR_PREFIX_DERIVED)) {\n      throw new TypeError('\"proof.proofValue\" must be a derived proof.');\n    }\n\n    const payload = proofValue.subarray(CBOR_PREFIX_DERIVED.length);\n    const [\n      bbsProof,\n      compressedLabelMap,\n      mandatoryIndexes,\n      selectiveIndexes,\n      presentationHeader\n    ] = cborg__WEBPACK_IMPORTED_MODULE_1__.decode(payload, {useMaps: true, tags: TAGS});\n\n    const labelMap = _decompressLabelMap(compressedLabelMap);\n    const params = {\n      bbsProof, labelMap, mandatoryIndexes, selectiveIndexes,\n      presentationHeader\n    };\n    _validateDerivedProofParams(params);\n    return params;\n  } catch(e) {\n    const err = new TypeError(\n      'The proof does not include a valid \"proofValue\" property.');\n    err.cause = e;\n    throw err;\n  }\n}\n\nfunction serializeBaseProofValue({\n  bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n} = {}) {\n  _validateBaseProofParams({\n    bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n  });\n\n  // encode as multibase (base64url no pad) CBOR\n  const payload = [\n    // Uint8Array\n    bbsSignature,\n    // Uint8Array\n    bbsHeader,\n    // Uint8Array\n    publicKey,\n    // Uint8Array\n    hmacKey,\n    // array of strings\n    mandatoryPointers\n  ];\n  const cbor = concatBuffers([\n    CBOR_PREFIX_BASE, cborg__WEBPACK_IMPORTED_MODULE_1__.encode(payload, {useMaps: true})\n  ]);\n  return `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(cbor)}`;\n}\n\nfunction serializeDisclosureProofValue({\n  bbsProof, labelMap, mandatoryIndexes, selectiveIndexes, presentationHeader\n} = {}) {\n  _validateDerivedProofParams({\n    bbsProof, labelMap, mandatoryIndexes, selectiveIndexes, presentationHeader\n  });\n\n  // encode as multibase (base64url no pad) CBOR\n  const payload = [\n    // Uint8Array\n    bbsProof,\n    // Map of strings => strings compressed to ints => Uint8Arrays\n    _compressLabelMap(labelMap),\n    // array of numbers\n    mandatoryIndexes,\n    // array of numbers\n    selectiveIndexes,\n    // Uint8Array\n    presentationHeader\n  ];\n  const cbor = concatBuffers([\n    CBOR_PREFIX_DERIVED, cborg__WEBPACK_IMPORTED_MODULE_1__.encode(payload, {useMaps: true})\n  ]);\n  return `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(cbor)}`;\n}\n\nfunction _compressLabelMap(labelMap) {\n  const map = new Map();\n  for(const [k, v] of labelMap.entries()) {\n    map.set(parseInt(k.slice(4), 10), parseInt(v.slice(1), 10));\n  }\n  return map;\n}\n\nfunction _decompressLabelMap(compressedLabelMap) {\n  const map = new Map();\n  for(const [k, v] of compressedLabelMap.entries()) {\n    map.set(`c14n${k}`, `b${v}`);\n  }\n  return map;\n}\n\nfunction _startsWithBytes(buffer, prefix) {\n  for(let i = 0; i < prefix.length; ++i) {\n    if(buffer[i] !== prefix[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _validateBaseProofParams({\n  bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n}) {\n  if(!(bbsSignature instanceof Uint8Array && bbsSignature.length === 80)) {\n    throw new TypeError('\"bbsSignature\" must be a Uint8Array of length 80.');\n  }\n  if(!(bbsHeader instanceof Uint8Array && bbsHeader.length === 64)) {\n    throw new TypeError('\"bbsHeader\" must be a Uint8Array of length 64.');\n  }\n  if(!(publicKey instanceof Uint8Array && publicKey.length === 96)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array of length 96.');\n  }\n  if(!(hmacKey instanceof Uint8Array && hmacKey.length === 32)) {\n    throw new TypeError('\"hmacKey\" must be a Uint8Array of length 32.');\n  }\n  if(!(Array.isArray(mandatoryPointers) &&\n    mandatoryPointers.every(p => typeof p === 'string'))) {\n    throw new TypeError('\"mandatoryPointers\" must be an array of strings.');\n  }\n}\n\nfunction _validateDerivedProofParams({\n  bbsProof, labelMap, mandatoryIndexes, selectiveIndexes, presentationHeader\n}) {\n  if(!(bbsProof instanceof Uint8Array)) {\n    // note: `bbsProof` length is variable\n    throw new TypeError('\"bbsProof\" must be a Uint8Array.');\n  }\n  if(!(labelMap instanceof Map &&\n    [...labelMap.entries()].every(\n      ([k, v]) => typeof k === 'string' && typeof v === 'string'))) {\n    throw new TypeError('\"labelMap\" must be a Map of strings to strings.');\n  }\n  if(!(Array.isArray(mandatoryIndexes) &&\n    mandatoryIndexes.every(Number.isInteger))) {\n    throw new TypeError('\"mandatoryIndexes\" must be an array of integers.');\n  }\n  if(!(Array.isArray(selectiveIndexes) &&\n    selectiveIndexes.every(Number.isInteger))) {\n    throw new TypeError('\"selectiveIndexes\" must be an array of integers.');\n  }\n  if(!(presentationHeader instanceof Uint8Array)) {\n    // note: `presentationHeader` length is variable\n    throw new TypeError('\"presentationHeader\" must be a Uint8Array.');\n  }\n}\n\nfunction _decodeUint8Array(bytes) {\n  return bytes;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requiredAlgorithm: () => (/* binding */ requiredAlgorithm)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/bls12-381-multikey */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst requiredAlgorithm = [\n  _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__.ALGORITHMS.BBS_BLS12381_SHA256,\n  'Bls12381G2'\n];\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sdFunctions.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sdFunctions.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createShuffledIdLabelMapFunction: () => (/* binding */ createShuffledIdLabelMapFunction)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nfunction createShuffledIdLabelMapFunction({hmac} = {}) {\n  // the second step from the spec produces the same `bnodeIdMap` as\n  // the one used in `createHmacIdLabelMapFunction` from ecdsa-sd-2023, so\n  // that is reused below;\n  const hmacIdLabelFunction = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.createHmacIdLabelMapFunction)({hmac});\n  return async ({canonicalIdMap}) => {\n    const bnodeIdMap = await hmacIdLabelFunction({canonicalIdMap});\n    const hmacIds = [...bnodeIdMap.values()].sort();\n    const bnodeKeys = [...bnodeIdMap.keys()];\n    for(const key of bnodeKeys) {\n      bnodeIdMap.set(key, 'b' + hmacIds.indexOf(bnodeIdMap.get(key)));\n    }\n    return bnodeIdMap;\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sdFunctions.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sign.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sign.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSignCryptosuite: () => (/* binding */ createSignCryptosuite)\n/* harmony export */ });\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _sdFunctions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sdFunctions.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sdFunctions.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\nfunction createSignCryptosuite({mandatoryPointers = []} = {}) {\n  const options = {mandatoryPointers};\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_4__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.requiredAlgorithm,\n    createVerifier: _throwSignUsageError,\n    createVerifyData: _createSignData,\n    createProofValue: _createBaseProofValue,\n    options\n  };\n}\n\nasync function _createBaseProofValue({verifyData, dataIntegrityProof}) {\n  const {signer} = dataIntegrityProof;\n  const {\n    proofHash, mandatoryPointers, mandatoryHash, nonMandatory, hmacKey\n  } = verifyData;\n\n  // 1. Set BBS header to the concatenation of `proofHash` and `mandatoryHash`.\n  const bbsHeader = (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_2__.concatBuffers)([proofHash, mandatoryHash]);\n\n  // 2. Set BBS messages to all non-mandatory messages using UTF-8 encoding.\n  const messages = nonMandatory.map(_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.stringToUtf8Bytes);\n\n  // 3. Create BBS signature.\n  const {publicKey} = signer;\n  let bbsSignature;\n  // use `multisign` if provided, otherwise use CBOR to encode `data` for `sign`\n  if(signer.multisign) {\n    bbsSignature = await signer.multisign({header: bbsHeader, messages});\n  } else {\n    const data = cborg__WEBPACK_IMPORTED_MODULE_0__.encode([bbsHeader, messages]);\n    bbsSignature = await signer.sign({data});\n  }\n\n  // 4. Generate `proofValue`.\n  const proofValue = (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_2__.serializeBaseProofValue)({\n    bbsSignature, bbsHeader, publicKey, hmacKey, mandatoryPointers\n  });\n  return proofValue;\n}\n\nasync function _createSignData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_4__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_4__.name}\".`);\n  }\n  if(!(cryptosuite.options && typeof cryptosuite.options === 'object')) {\n    throw new TypeError(`\"cryptosuite.options\" must be an object.`);\n  }\n  const {mandatoryPointers = []} = cryptosuite.options;\n  if(!Array.isArray(mandatoryPointers)) {\n    throw new TypeError(\n      `\"cryptosuite.options.mandatoryPointers\" must be an array.`);\n  }\n\n  // 0. Remove `created` from proof if present.\n  // FIXME: implement `updateProof` or another method to ensure `created`\n  // is not set once some API is exposed via `data-integrity`\n  delete proof.created;\n\n  // 1. Generate `proofHash` in parallel.\n  const options = {documentLoader};\n  const proofHashPromise = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.hashCanonizedProof)({document, proof, options})\n    .catch(e => e);\n\n  // 2. Create HMAC label replacement function to randomize bnode labels.\n  const hmac = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.createHmac)({key: null});\n  const labelMapFactoryFunction = (0,_sdFunctions_js__WEBPACK_IMPORTED_MODULE_3__.createShuffledIdLabelMapFunction)({hmac});\n\n  // 3. Canonicalize document with randomized bnode labels and group N-Quads\n  //  by mandatory pointers.\n  const {\n    groups: {mandatory: mandatoryGroup}\n  } = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.canonicalizeAndGroup)({\n    document,\n    labelMapFactoryFunction,\n    groups: {mandatory: mandatoryPointers},\n    options\n  });\n  const mandatory = [...mandatoryGroup.matching.values()];\n  const nonMandatory = [...mandatoryGroup.nonMatching.values()];\n\n  // 4. Hash any mandatory N-Quads.\n  const {mandatoryHash} = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_1__.hashMandatory)({mandatory});\n\n  // 5. Export HMAC key.\n  const hmacKey = await hmac.export();\n\n  // 6. Return data used by cryptosuite to sign.\n  const proofHash = await proofHashPromise;\n  if(proofHash instanceof Error) {\n    throw proofHash;\n  }\n  return {proofHash, mandatoryPointers, mandatoryHash, nonMandatory, hmacKey};\n}\n\nfunction _throwSignUsageError() {\n  throw new Error('This cryptosuite must only be used with \"sign\".');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/sign.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/verify.js":
/*!************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/verify.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier),\n/* harmony export */   createVerifyCryptosuite: () => (/* binding */ createVerifyCryptosuite)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/bls12-381-multikey */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\nfunction createVerifyCryptosuite({expectedPresentationHeader} = {}) {\n  const options = {expectedPresentationHeader};\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_3__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_4__.requiredAlgorithm,\n    createVerifier,\n    createVerifyData: _createVerifyData,\n    options,\n    results: {lastParsedProof: null}\n  };\n}\n\nasync function createVerifier({verificationMethod}) {\n  const key = await _digitalbazaar_bls12_381_multikey__WEBPACK_IMPORTED_MODULE_0__.from(verificationMethod);\n  const verifier = key.verifier();\n  return {\n    algorithm: verifier.algorithm,\n    id: verifier.id,\n    // `data` includes `signature` in this cryptosuite\n    async verify({data}) {\n      return _multiverify({verifier, data});\n    }\n  };\n}\n\nasync function _createVerifyData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_3__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_3__.name}\".`);\n  }\n  const {expectedPresentationHeader} = cryptosuite.options;\n  if(expectedPresentationHeader &&\n    !(expectedPresentationHeader instanceof Uint8Array)) {\n    throw new TypeError(\n      '\"cryptosuite.options.expectedPresentationHeader\" must be a Uint8Array.');\n  }\n\n  // 1. Generate `proofHash` in parallel.\n  const options = {documentLoader};\n  const proofHashPromise = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashCanonizedProof)({document, proof, options})\n    .catch(e => e);\n\n  // 2. Parse disclosure `proof` to get parameters to verify.\n  const {\n    bbsProof, labelMap, mandatoryIndexes, selectiveIndexes, presentationHeader\n  } = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_1__.parseDisclosureProofValue)({proof});\n\n  // 3. Check expected presentation header, if any.\n  if(expectedPresentationHeader) {\n    if(!(presentationHeader.length === expectedPresentationHeader.length &&\n      presentationHeader.every(\n        (e, i) => e === expectedPresentationHeader[i]))) {\n      // presentation header does not match expected value\n      return false;\n    }\n  } else {\n    // store last parsed presentation header\n    cryptosuite.results.lastParsedProof = {presentationHeader};\n  }\n\n  // 4. Canonicalize document using label map.\n  const labelMapFactoryFunction = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.createLabelMapFunction)({labelMap});\n  const nquads = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.labelReplacementCanonicalizeJsonLd)(\n    {document, labelMapFactoryFunction, options});\n\n  // 5. Separate N-Quads into mandatory and non-mandatory.\n  const mandatory = [];\n  const nonMandatory = [];\n  for(const [index, nq] of nquads.entries()) {\n    if(mandatoryIndexes.includes(index)) {\n      mandatory.push(nq);\n    } else {\n      nonMandatory.push(nq);\n    }\n  }\n\n  // 6. Hash any mandatory N-Quads.\n  const {mandatoryHash} = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashMandatory)({mandatory});\n\n  // 7. Return data used by cryptosuite to verify.\n  const proofHash = await proofHashPromise;\n  if(proofHash instanceof Error) {\n    throw proofHash;\n  }\n  return {\n    bbsProof, proofHash, nonMandatory, mandatoryHash, selectiveIndexes,\n    presentationHeader\n  };\n}\n\nasync function _multiverify({verifier, data} = {}) {\n  // 1. Deserialize `data` into named components.\n  const {\n    bbsProof: proof, proofHash, nonMandatory, mandatoryHash, selectiveIndexes,\n    presentationHeader\n  } = data;\n\n  // 2. Set `bbsHeader` to the concatenation of `proofHash` and `mandatoryHash`.\n  const header = (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_1__.concatBuffers)([proofHash, mandatoryHash]);\n\n  // 3. Set `verificationResult` to the result of BBS `ProofVerify` passing\n  //   the appropriate params.\n  const disclosedMessages = nonMandatory.map(_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.stringToUtf8Bytes);\n  if(disclosedMessages.length !== selectiveIndexes.length) {\n    throw new Error(\n      `Number of disclosed messages (${disclosedMessages.length}) does not ` +\n      `equal number of \"selectiveIndexes\" (${selectiveIndexes.length}).`);\n  }\n  // build sparse `messages` array using selective indexes\n  const messages = [];\n  for(const [i, message] of disclosedMessages.entries()) {\n    messages[selectiveIndexes[i]] = message;\n  }\n  return verifier.multiverify({proof, header, presentationHeader, messages});\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-2023-cryptosuite/lib/verify.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js":
/*!******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertArray: () => (/* binding */ assertArray),\n/* harmony export */   assertInstance: () => (/* binding */ assertInstance),\n/* harmony export */   assertType: () => (/* binding */ assertType)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\nfunction assertArray(value, name) {\n  if(!Array.isArray(value)) {\n    throw new TypeError(`\"${name}\" must be an array.`);\n  }\n}\n\nfunction assertInstance(type, value, name) {\n  if(!(value instanceof type)) {\n    throw new TypeError(`\"${name}\" must be a ${type.name}.`);\n  }\n}\n\nfunction assertType(type, value, name) {\n  if(typeof value !== type) {\n    const aOrAn = type === 'object' ? 'an' : 'a';\n    throw new TypeError(`\"${name}\" must be ${aOrAn} ${type}.`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CIPHERSUITES: () => (/* binding */ CIPHERSUITES),\n/* harmony export */   getCiphersuite: () => (/* binding */ getCiphersuite)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_hash_to_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/abstract/hash-to-curve */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js\");\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"./node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"./node_modules/@noble/hashes/esm/sha3.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\n// supported BBS cryptosuites\nconst CIPHERSUITES = {\n  BLS12381_SHAKE256: {\n    ciphersuite_id: 'BBS_BLS12381G1_XOF:SHAKE-256_SSWU_RO_',\n    name: 'BLS12-381-SHAKE-256',\n    expand_len: 48,\n    hash: 'SHAKE-256',\n    octet_scalar_length: 32,\n    octet_point_length: 48,\n    BP1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.ProjectivePoint.BASE,\n    BP2: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G2.ProjectivePoint.BASE,\n    E1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fp,\n    E2: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fp2,\n    P1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.ProjectivePoint.fromHex(\n      '8929dfbc7e6642c4ed9cba0856e493f8b9d7d5fcb0c31ef8fdcd34d50648a5' +\n      '6c795e106e9eada6e0bda386b414150755'),\n    // field over `r`\n    Fr: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fr,\n    // `r`\n    r: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fr.ORDER,\n    // hash_to_curve_suite params\n    hash_to_curve_g1(msg_octets, dst) {\n      if(dst.length > 255) {\n        throw new Error('\"dst.length\" must be <= 255.');\n      }\n      return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.hashToCurve(msg_octets, {\n        DST: dst,\n        expand: 'xof',\n        // `k` bits; security param for the suite\n        k: 128,\n        hash: _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_2__.shake256\n      });\n    },\n    expand_message(msg_octets, dst, expand_len) {\n      if(dst.length > 255) {\n        throw new Error('\"dst.length\" must be <= 255.');\n      }\n      return (0,_noble_curves_abstract_hash_to_curve__WEBPACK_IMPORTED_MODULE_3__.expand_message_xof)(\n        msg_octets, dst,\n        expand_len ?? CIPHERSUITES.BLS12381_SHAKE256.expand_len,\n        // `k` bits; security param for the suite\n        128,\n        _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_2__.shake256);\n    },\n    // instead of just `e()`, this performs `e(pair1) * e(pair2_negation)`\n    // and compares against Identity_GT efficiently\n    eCompare: _comparePairings,\n    octets_to_point_E1: _octetsToG1Point,\n    octets_to_point_E2: _octetsToG2Point,\n    point_to_octets_E1: _pointToOctets,\n    point_to_octets_E2: _pointToOctets\n  },\n  BLS12381_SHA256: {\n    ciphersuite_id: 'BBS_BLS12381G1_XMD:SHA-256_SSWU_RO_',\n    name: 'BLS12-381-SHA-256',\n    expand_len: 48,\n    hash: 'SHA-256',\n    octet_scalar_length: 32,\n    octet_point_length: 48,\n    // field over `r`\n    Fr: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fr,\n    // `r`\n    r: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fr.ORDER,\n    BP1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.ProjectivePoint.BASE,\n    BP2: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G2.ProjectivePoint.BASE,\n    E1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fp,\n    E2: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.fields.Fp2,\n    P1: _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.ProjectivePoint.fromHex(\n      'a8ce256102840821a3e94ea9025e4662b205762f9776b3a766c872b948f1fd' +\n      '225e7c59698588e70d11406d161b4e28c9'),\n    // hash_to_curve_suite params\n    hash_to_curve_g1(msg_octets, dst) {\n      if(dst.length > 255) {\n        throw new Error('\"dst.length\" must be <= 255.');\n      }\n      return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.hashToCurve(msg_octets, {\n        DST: dst,\n        expand: 'xmd',\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256\n      });\n    },\n    expand_message(msg_octets, dst, expand_len) {\n      if(dst.length > 255) {\n        throw new Error('\"dst.length\" must be <= 255.');\n      }\n      return (0,_noble_curves_abstract_hash_to_curve__WEBPACK_IMPORTED_MODULE_3__.expand_message_xmd)(\n        msg_octets, dst,\n        expand_len ?? CIPHERSUITES.BLS12381_SHA256.expand_len,\n        _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256);\n    },\n    // instead of just `e()`, this performs `e(pair1) * e(pair2_negation)`\n    // and compares against Identity_GT efficiently\n    eCompare: _comparePairings,\n    octets_to_point_E1: _octetsToG1Point,\n    octets_to_point_E2: _octetsToG2Point,\n    point_to_octets_E1: _pointToOctets,\n    point_to_octets_E2: _pointToOctets\n  }\n};\n\nconst ALL_CIPHERSUITES = [...Object.values(CIPHERSUITES)];\n\nfunction getCiphersuite(ciphersuite) {\n  if(typeof ciphersuite === 'object') {\n    if(!ALL_CIPHERSUITES.includes(ciphersuite)) {\n      throw new TypeError(`Unknown ciphersuite \"${ciphersuite?.name}\".`);\n    }\n    return ciphersuite;\n  }\n\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertType)('string', ciphersuite, 'ciphersuite');\n  const match = CIPHERSUITES[ciphersuite];\n  if(match) {\n    return match;\n  }\n  for(const [, value] of Object.entries(CIPHERSUITES)) {\n    if(value.name === ciphersuite || value.ciphersuite_id === ciphersuite) {\n      return value;\n    }\n  }\n  throw new Error(`Unknown ciphersuite \"${ciphersuite}\".`);\n}\n\n// `@noble/curves` serializes points in compressed format using `toRawBytes()`\nfunction _pointToOctets(p) {\n  return p.toRawBytes();\n}\n\nfunction _octetsToG1Point(octets) {\n  return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G1.ProjectivePoint.fromHex(octets);\n}\n\nfunction _octetsToG2Point(octets) {\n  return _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.G2.ProjectivePoint.fromHex(octets);\n}\n\n// compares two pairings against one another by:\n// 1. negating the second element of the the second pair\n// 2. implementing \"Optimal Ate Pairing\" (`e()`) on each pair\n// 3. multipling the pairings efficiently with minimal exponentiation\n// 4. comparing against the identity element of the GT subgroup\nfunction _comparePairings({pair1, pair2, performNegation = true} = {}) {\n  if(performNegation) {\n    pair2 = [pair2[0], pair2[1].negate()];\n  }\n  // do not perform final exponentiation until after multiplication\n  const left = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.pairing(...pair1, false);\n  const right = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381.pairing(...pair2, false);\n  const {fields: {Fp12}} = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_1__.bls12_381;\n  const Identity_GT = Fp12.ONE;\n  const product = Fp12.finalExponentiate(Fp12.mul(left, right));\n  return Fp12.eql(product, Identity_GT);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/core.js":
/*!********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/core.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoreProofGen: () => (/* binding */ CoreProofGen),\n/* harmony export */   CoreProofVerify: () => (/* binding */ CoreProofVerify),\n/* harmony export */   CoreSign: () => (/* binding */ CoreSign),\n/* harmony export */   CoreVerify: () => (/* binding */ CoreVerify)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proof.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/proof.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\nasync function CoreProofGen({\n  PK, signature, generators,\n  header = new Uint8Array(), ph = new Uint8Array(),\n  messages = [], disclosed_indexes = [],\n  api_id = new Uint8Array(), ciphersuite, mocked_random_scalars_options\n} = {}) {\n  /* Deserialization:\n\n  1.  signature_result = octets_to_signature(signature)\n  2.  if signature_result is INVALID, return INVALID\n  3.  (A, e) = signature_result\n  4.  L = length(messages)\n  5.  R = length(disclosed_indexes)\n  6.  if R > L, return INVALID\n  7.  U = L - R\n  8.  for i in disclosed_indexes, if i < 0 or i > L - 1, return INVALID\n  9.  undisclosed_indexes = (0, 1, ..., L - 1) \\ disclosed_indexes\n  10. (i1, ..., iR) = disclosed_indexes\n  11. (j1, ..., jU) = undisclosed_indexes\n  12. disclosed_messages = (messages[i1], ..., messages[iR])\n  13. undisclosed_messages = (messages[j1], ..., messages[jU])\n\n  */\n  const signature_result = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.octets_to_signature)(\n    {signature_octets: signature, ciphersuite});\n  const L = messages.length;\n  const R = disclosed_indexes.length;\n  if(R > L) {\n    throw new Error(\n      `\"disclosed_indexes.length\" (${disclosed_indexes.length}) must be ` +\n      `less than or equal to \"messages.length\" (${messages.length}).`);\n  }\n  const U = L - R;\n  if(disclosed_indexes.some(i => isNaN(i) || i < 0 || i >= L)) {\n    throw new Error(\n      `Every index in \"disclosed_indexes\" (${disclosed_indexes}) ` +\n      `must be a number >= 0 and <= ${L}.`);\n  }\n  const undisclosed_indexes = [];\n  const disclosed_messages = [];\n  const undisclosed_messages = [];\n  const disclosed_indexes_set = new Set(disclosed_indexes);\n  // always generate disclosed messages in the same order as messages\n  for(const [i, e] of messages.entries()) {\n    if(disclosed_indexes_set.has(i)) {\n      disclosed_messages.push(e);\n    } else {\n      undisclosed_indexes.push(i);\n      undisclosed_messages.push(e);\n    }\n  }\n\n  /* Algorithm:\n\n  1. random_scalars = calculate_random_scalars(5+U)\n  2. init_res = ProofInit(PK,\n                          signature_result,\n                          generators,\n                          random_scalars,\n                          header,\n                          messages,\n                          undisclosed_indexes,\n                          api_id)\n  3. if init_res is INVALID, return INVALID\n  4. challenge = ProofChallengeCalculate(init_res, disclosed_indexes,\n                                         disclosed_messages, ph)\n  5. if challenge is INVALID, return INVALID\n  6. proof = ProofFinalize(init_res, challenge, e, random_scalars,\n                           undisclosed_messages)\n  7. return proof\n\n  */\n  const random_scalars = mocked_random_scalars_options === undefined ?\n    await (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.calculate_random_scalars)({count: 5 + U, ciphersuite}) :\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.mocked_calculate_random_scalars)({\n      count: 5 + U, ...mocked_random_scalars_options, ciphersuite\n    });\n  const init_res = (0,_proof_js__WEBPACK_IMPORTED_MODULE_1__.ProofInit)({\n    PK, signature_result, generators, random_scalars, header,\n    messages, undisclosed_indexes, api_id, ciphersuite\n  });\n  const challenge = (0,_proof_js__WEBPACK_IMPORTED_MODULE_1__.ProofChallengeCalculate)({\n    init_res, disclosed_indexes, disclosed_messages, ph, api_id, ciphersuite\n  });\n  const [, e] = signature_result;\n  const proof = (0,_proof_js__WEBPACK_IMPORTED_MODULE_1__.ProofFinalize)({\n    init_res, challenge, e_value: e, random_scalars, undisclosed_messages,\n    ciphersuite\n  });\n  return proof;\n}\n\nfunction CoreProofVerify({\n  PK, proof, generators,\n  header = new Uint8Array(), ph = new Uint8Array(),\n  disclosed_messages = [], disclosed_indexes = [],\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Deserialization:\n\n  1. proof_result = octets_to_proof(proof)\n  2. if proof_result is INVALID, return INVALID\n  3. (Abar, Bbar, D, e^, r1^, r3^, commitments, cp) = proof_result\n  4. W = octets_to_pubkey(PK)\n  5. if W is INVALID, return INVALID\n\n  */\n  const proof_result = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.octets_to_proof)({proof_octets: proof, ciphersuite});\n  const [Abar, Bbar] = proof_result;\n  const cp = proof_result.at(-1);\n  const W = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.octets_to_pubkey)({PK, ciphersuite});\n\n  /* Algorithm:\n\n  1. init_res = ProofVerifyInit(PK, proof_result, generators, header,\n                                messages, disclosed_indexes, api_id)\n  2. if init_res is INVALID, return INVALID\n  3. challenge = ProofChallengeCalculate(init_res, disclosed_indexes,\n                                         messages, ph, api_id)\n  4. if challenge is INVALID, return INVALID\n  5. if cp != challenge, return INVALID\n  6. if e(Abar, W) * e(Bbar, -BP2) != Identity_GT, return INVALID\n  7. return VALID\n\n  */\n  const init_res = (0,_proof_js__WEBPACK_IMPORTED_MODULE_1__.ProofVerifyInit)({\n    PK, proof: proof_result, generators, header,\n    disclosed_messages, disclosed_indexes,\n    api_id, ciphersuite\n  });\n  const challenge = (0,_proof_js__WEBPACK_IMPORTED_MODULE_1__.ProofChallengeCalculate)({\n    init_res, disclosed_indexes, disclosed_messages, ph, api_id, ciphersuite\n  });\n  if(cp !== challenge) {\n    // proof challenge does not match\n    return false;\n  }\n  // performs step 6 more efficiently;\n  // note that BP2 will be negated internally to -BP2 to perform the comparison\n  // by multiplying the pairings and checking against Identity_GT as above\n  const {BP2} = ciphersuite;\n  const pair1 = [Abar, W];\n  const pair2 = [Bbar, BP2];\n  return ciphersuite.eCompare({pair1, pair2});\n}\n\nfunction CoreSign({\n  SK, PK, generators, header = new Uint8Array(), messages = [],\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Definitions:\n\n  1. signature_dst, an octet string representing the domain separation\n                    tag: api_id || \"H2S_\" where \"H2S_\" is an ASCII string\n                    comprised of 4 bytes.\n  */\n  const signature_dst = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(api_id, _util_js__WEBPACK_IMPORTED_MODULE_0__.TEXT_ENCODER.encode('H2S_'));\n\n  /* Deserialization:\n\n  1. L = length(messages)\n  2. if length(generators) != L + 1, return INVALID\n  3. (msg_1, ..., msg_L) = messages\n  4. (Q_1, H_1, ..., H_L) = generators\n\n  */\n  const L = messages.length;\n  if(generators.length !== (L + 1)) {\n    throw new Error(\n      `\"generators.length\" (${generators.length}) must equal ` +\n      `\"messages.length\" (${messages.length}) + 1.`);\n  }\n\n  /* Algorithm:\n\n  1. domain = calculate_domain(PK, generators, header, api_id)\n  2. e = hash_to_scalar(serialize((SK, domain, msg_1, ..., msg_L)),\n                        signature_dst)\n  3. B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\n  4. A = B * (1 / (SK + e))\n  5. return signature_to_octets((A, e))\n\n  */\n  // calculate `B` and `domain` at once\n  const {B, domain} = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.calculate_B)({\n    PK, generators, header, messages, api_id, ciphersuite\n  });\n  const e = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hash_to_scalar)({\n    msg_octets: (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.serialize)({\n      input_array: [SK, domain, ...messages], ciphersuite\n    }),\n    dst: signature_dst,\n    ciphersuite\n  });\n  // 4. A = B * (1 / (SK + e))\n  // multiply `B` by the inverse of `SK + e` within the field over `r`\n  const {Fr} = ciphersuite;\n  const A = B.multiply(Fr.inv(Fr.add(SK, e)));\n  // if A == Identity_G1 throw invalid signature error\n  if(ciphersuite.E1.eql(A, ciphersuite.E1.ONE)) {\n    throw new Error('Invalid signature.');\n  }\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.signature_to_octets)({signature: [A, e], ciphersuite});\n}\n\nfunction CoreVerify({\n  PK, signature, generators, header = new Uint8Array(), messages = [],\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Deserialization:\n\n  1. signature_result = octets_to_signature(signature)\n  2. if signature_result is INVALID, return INVALID\n  3. (A, e) = signature_result\n  4. W = octets_to_pubkey(PK)\n  5. if W is INVALID, return INVALID\n  6. L = length(messages)\n  7. if length(generators) != L + 1, return INVALID\n  8. (msg_1, ..., msg_L) = messages\n  9. (Q_1, H_1, ..., H_L) = generators\n\n  */\n  // `signature_result`\n  const [A, e] = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.octets_to_signature)(\n    {signature_octets: signature, ciphersuite});\n  const W = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.octets_to_pubkey)({PK, ciphersuite});\n  const L = messages.length;\n  if(generators.length !== (L + 1)) {\n    throw new Error(\n      `\"generators.length\" (${generators.length}) must equal ` +\n      `\"messages.length\" (${messages.length}) + 1.`);\n  }\n\n  /* Algorithm:\n\n  1. domain = calculate_domain(PK, generators, header, api_id)\n  2. B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\n  3. if e(A, W + BP2 * e) * e(B, -BP2) != Identity_GT, return INVALID\n  4. return VALID\n\n  */\n  const {B} = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.calculate_B)({\n    PK, generators, header, messages, api_id, ciphersuite\n  });\n  // performs step 3 more efficiently;\n  // note that BP2 will be negated internally to -BP2 to perform the comparison\n  // by multiplying the pairings and checking against Identity_GT as above\n  const {BP2} = ciphersuite;\n  const pair1 = [A, W.add(BP2.multiply(e))];\n  const pair2 = [B, BP2];\n  return ciphersuite.eCompare({pair1, pair2});\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/core.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProofGen: () => (/* binding */ ProofGen),\n/* harmony export */   ProofVerify: () => (/* binding */ ProofVerify),\n/* harmony export */   Sign: () => (/* binding */ Sign),\n/* harmony export */   Verify: () => (/* binding */ Verify)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/core.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js\");\n/* harmony import */ var _ciphersuites_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ciphersuites.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\nasync function ProofGen({\n  PK, signature,\n  header = new Uint8Array(),\n  ph = new Uint8Array(),\n  messages = [], disclosed_indexes = [],\n  ciphersuite,\n  // for test suite only\n  mocked_random_scalars_options\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, PK, 'PK');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, signature, 'signature');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, ph, 'ph');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosed_indexes, 'disclosed_indexes');\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_3__.getCiphersuite)(ciphersuite);\n\n  const api_id = _createApiId(ciphersuite.ciphersuite_id);\n\n  /* Algorithm:\n\n  1. message_scalars = messages_to_scalars(messages, api_id)\n  2. generators = create_generators(length(messages)+1, api_id)\n  3. proof = CoreProofGen(PK, signature, generators, header, ph,\n                          message_scalars, disclosed_indexes, api_id)\n  4. if proof is INVALID, return INVALID\n  5. return proof\n\n  */\n  const message_scalars = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.messages_to_scalars)({messages, api_id, ciphersuite});\n  const generators = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.create_generators)({\n    count: messages.length + 1, api_id, ciphersuite\n  });\n  const proof = await (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.CoreProofGen)({\n    PK, signature, generators, header, ph,\n    messages: message_scalars, disclosed_indexes, api_id, ciphersuite,\n    // for test suite only\n    mocked_random_scalars_options\n  });\n  return proof;\n}\n\nasync function ProofVerify({\n  PK, proof, header, ph, disclosed_messages, disclosed_indexes, ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, PK, 'PK');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, proof, 'proof');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, ph, 'ph');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosed_messages, 'disclosed_messages');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosed_indexes, 'disclosed_indexes');\n  if(disclosed_messages.length !== disclosed_indexes.length) {\n    throw new Error(\n      `\"disclosed_messages.length\" (${disclosed_messages.length}) must ` +\n      `equal \"disclosed_indexes.length\" (${disclosed_indexes.length}).`);\n  }\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_3__.getCiphersuite)(ciphersuite);\n\n  const api_id = _createApiId(ciphersuite.ciphersuite_id);\n\n  /* Deserialization:\n\n  1. proof_len_floor = 2 * octet_point_length + 3 * octet_scalar_length\n  2. if length(proof) < proof_len_floor, return INVALID\n  3. U = floor((length(proof) - proof_len_floor) / octet_scalar_length)\n  4. R = length(disclosed_indexes)\n\n  */\n  // note: `proof_len_floor` is checked in `CoreProofVerify`\n  const {octet_point_length, octet_scalar_length} = ciphersuite;\n  // FIX to spec: Should be 3 * point length and 4 * octet length.\n  const proof_len_floor = 3 * octet_point_length + 4 * octet_scalar_length;\n  if(proof.length < proof_len_floor) {\n    throw new Error(\n      `\"proof.length\" (${proof.length}) ` +\n      `must be at least ${proof_len_floor}.`);\n  }\n  // check total proof size is valid\n  const remainder = proof.length - proof_len_floor;\n  if(remainder % octet_scalar_length !== 0) {\n    throw new Error('Invalid proof size.');\n  }\n  const U = remainder / octet_scalar_length;\n  const R = disclosed_indexes.length;\n\n  /* Algorithm:\n\n  1. message_scalars = messages_to_scalars(disclosed_messages, api_id)\n  2. generators = create_generators(U + R + 1, api_id)\n  3. result = CoreProofVerify(PK, proof, generators, header, ph,\n                              message_scalars, disclosed_indexes, api_id)\n  4. return result\n\n  */\n  const message_scalars = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.messages_to_scalars)({\n    messages: disclosed_messages, api_id, ciphersuite\n  });\n  const generators = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.create_generators)({count: U + R + 1, api_id, ciphersuite});\n  const result = (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.CoreProofVerify)({\n    PK, proof, generators, header, ph,\n    disclosed_messages: message_scalars, disclosed_indexes,\n    api_id, ciphersuite\n  });\n  return result;\n}\n\nasync function Sign({\n  SK, PK, header = new Uint8Array(), messages = [], ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertType)('bigint', SK, 'SK');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, PK, 'PK');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_3__.getCiphersuite)(ciphersuite);\n\n  const api_id = _createApiId(ciphersuite.ciphersuite_id);\n\n  /* Algorithm:\n\n  1. message_scalars = messages_to_scalars(messages, api_id)\n  2. generators = create_generators(length(messages)+1, api_id)\n  3. signature = CoreSign(SK, PK, header, message_scalars, generators, api_id)\n  4. if signature is INVALID, return INVALID\n  5. return signature\n\n  */\n  const message_scalars = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.messages_to_scalars)({messages, api_id, ciphersuite});\n  const generators = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.create_generators)({\n    count: messages.length + 1, api_id, ciphersuite\n  });\n  const signature = (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.CoreSign)({\n    SK, PK, header, messages: message_scalars, generators, api_id, ciphersuite\n  });\n  return signature;\n}\n\nasync function Verify({\n  PK, signature, header, messages, ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, PK, 'PK');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, signature, 'signature');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_3__.getCiphersuite)(ciphersuite);\n\n  const api_id = _createApiId(ciphersuite.ciphersuite_id);\n\n  /* Algorithm:\n\n  1. message_scalars = messages_to_scalars(messages, api_id)\n  2. generators = create_generators(length(messages)+1, api_id)\n  3. result = CoreVerify(PK, signature, generators, header,\n                         message_scalars, api_id)\n  4. return result\n\n  */\n  const message_scalars = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.messages_to_scalars)({messages, api_id, ciphersuite});\n  const generators = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.create_generators)({\n    count: messages.length + 1, api_id, ciphersuite\n  });\n  const result = (0,_core_js__WEBPACK_IMPORTED_MODULE_1__.CoreVerify)({\n    PK, signature, generators, header, messages: message_scalars,\n    api_id, ciphersuite\n  });\n  return result;\n}\n\nfunction _createApiId(ciphersuite_id) {\n  /*\n  api_id: the octet string ciphersuite_id || \"H2G_HM2S_\", where\n          ciphersuite_id is defined by the ciphersuite and \"H2G_HM2S_\"is\n          an ASCII string comprised of 9 bytes.\n  */\n  return _util_js__WEBPACK_IMPORTED_MODULE_2__.TEXT_ENCODER.encode(ciphersuite_id + 'H2G_HM2S_');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/interface.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/keypair.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/keypair.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyGen: () => (/* binding */ KeyGen),\n/* harmony export */   SkToPk: () => (/* binding */ SkToPk)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assert.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js\");\n/* harmony import */ var _ciphersuites_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ciphersuites.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\nfunction KeyGen({\n  key_material, key_info = new Uint8Array(), key_dst, ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, key_material, 'key_material');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, key_info, 'key_info');\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_2__.getCiphersuite)(ciphersuite);\n  if(key_dst !== undefined) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, key_dst, 'key_dst');\n  } else {\n    key_dst = _util_js__WEBPACK_IMPORTED_MODULE_1__.TEXT_ENCODER.encode(ciphersuite.ciphersuite_id + 'KEYGEN_DST_');\n  }\n\n  /* Algorithm:\n\n  1. if length(key_material) < 32, return INVALID\n  2. if length(key_info) > 65535, return INVALID\n  3. derive_input = key_material || I2OSP(length(key_info), 2) || key_info\n  4. SK = hash_to_scalar(derive_input, key_dst)\n  5. if SK is INVALID, return INVALID\n  6. return SK\n\n  */\n  if(key_material.length < 32) {\n    throw new Error(\n      `\"key_material.length\" (${key_material.length}) must be at least 32.`);\n  }\n  if(key_info.length > 65535) {\n    throw new Error(\n      `\"key_info.length\" (${key_info.length}) must be <= 65535.`);\n  }\n  const derive_input = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n    key_material, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.i2osp)(key_info.length, 2), key_info);\n  const SK = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.hash_to_scalar)({\n    msg_octets: derive_input, dst: key_dst, ciphersuite\n  });\n  return SK;\n}\n\nfunction SkToPk({SK, ciphersuite} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertType)('bigint', SK, 'SK');\n  ciphersuite = (0,_ciphersuites_js__WEBPACK_IMPORTED_MODULE_2__.getCiphersuite)(ciphersuite);\n\n  /* Algorithm:\n\n  1. W = SK * BP2\n  2. return point_to_octets_E2(W)\n\n  */\n  const {BP2} = ciphersuite;\n  const W = BP2.multiply(SK);\n  return ciphersuite.point_to_octets_E2(W);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/keypair.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/proof.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/proof.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProofChallengeCalculate: () => (/* binding */ ProofChallengeCalculate),\n/* harmony export */   ProofFinalize: () => (/* binding */ ProofFinalize),\n/* harmony export */   ProofInit: () => (/* binding */ ProofInit),\n/* harmony export */   ProofVerifyInit: () => (/* binding */ ProofVerifyInit)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\nfunction ProofChallengeCalculate({\n  init_res,\n  disclosed_indexes = [], disclosed_messages = [], ph = new Uint8Array(),\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /*\n  Definitions:\n\n  1. challenge_dst, an octet string representing the domain separation\n                    tag: api_id || \"H2S_\" where \"H2S_\" is an ASCII string\n                    comprised of 4 bytes.\n  */\n  const challenge_dst = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(api_id, _util_js__WEBPACK_IMPORTED_MODULE_0__.TEXT_ENCODER.encode('H2S_'));\n\n  /* Deserialization:\n\n  1. R = length(disclosed_indexes)\n  2. (i1, ..., iR) = disclosed_indexes\n  3. if length(disclosed_messages) != R, return INVALID\n  3. (msg_i1, ..., msg_iR) = disclosed_messages\n  4. (Abar, Bbar, D, T1, T2, domain) = init_res\n\n  ABORT if:\n\n  1. R > 2^64 - 1\n  2. length(ph) > 2^64 - 1\n\n  */\n  const R = disclosed_indexes.length;\n  const [Abar, Bbar, D, T1, T2, domain] = init_res;\n  if(!Number.isSafeInteger(R)) {\n    throw new Error(\n      `\"disclosed_indexes.length\" (${R}) must be a safe integer.`);\n  }\n  if(!Number.isSafeInteger(ph.length)) {\n    throw new Error(`\"ph.length\" (${ph.length}) must be a safe integer.`);\n  }\n\n  /* Algorithm:\n\n  1. c_arr = (Abar, Bbar, D, T1, T2, R, i1, ..., iR,\n              msg_i1, ..., msg_iR, domain)\n  2. c_octs = serialize(c_arr) || I2OSP(length(ph), 8) || ph\n  3. return hash_to_scalar(c_octs, challenge_dst)\n\n  */\n  const c_arr = [\n    Abar, Bbar, D, T1, T2, R,\n    ...disclosed_indexes, ...disclosed_messages,\n    domain\n  ];\n  const c_octs = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(\n    (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.serialize)({input_array: c_arr, ciphersuite}), (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.i2osp)(ph.length, 8), ph);\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hash_to_scalar)({msg_octets: c_octs, dst: challenge_dst, ciphersuite});\n}\n\nfunction ProofFinalize({\n  init_res, challenge, e_value,\n  random_scalars, undisclosed_messages = [],\n  ciphersuite\n} = {}) {\n  /* Deserialization:\n\n  1. U = length(undisclosed_messages)\n  2. if length(random_scalars) != U + 5, return INVALID\n  3. (r1, r2, e~, r1~, r3~, m~_j1, ..., m~_jU) = random_scalars\n  4. (undisclosed_1, ..., undisclosed_U) = undisclosed_messages\n  5. (Abar, Bbar, D) = (init_res[0], init_res[1], init_res[2])\n\n  */\n  const U = undisclosed_messages.length;\n  if(random_scalars.length !== (U + 5)) {\n    throw new Error(\n      `\"random_scalars.length\" (${random_scalars.length}) must equal ` +\n      `\"undisclosed_messages.length + 5\" (${U + 5}).`);\n  }\n  // `e~` expressed as `e_` here, `m~_j1` as `m_[0]`, etc. ...\n  const [r1, r2, e_, r1_, r3_, ...m_j] = random_scalars;\n  const [Abar, Bbar, D] = init_res;\n\n  /* Algorithm:\n\n  1. r3 = r2^-1 (mod r)\n  2. e^ = e~ + e_value * challenge\n  3. r1^ = r1~ - r1 * challenge\n  4. r3^ = r3~ - r3 * challenge\n  5. for j in (1, ..., U): m^_j = m~_j + undisclosed_j * challenge (mod r)\n  6. proof = (Abar, Bbar, D, e^, r1^, r3^, (m^_j1, ..., m^_jU), challenge)\n  7. return proof_to_octets(proof)\n\n  */\n  // arithmetic here is with scalars only (not points) so perform in field `Fr`\n  const {Fr} = ciphersuite;\n  const r3 = Fr.inv(r2);\n  // `^` expressed as `Hat`\n  const eHat = Fr.add(e_, Fr.mul(e_value, challenge));\n  const r1Hat = Fr.sub(r1_, Fr.mul(r1, challenge));\n  const r3Hat = Fr.sub(r3_, Fr.mul(r3, challenge));\n  // `mHat` constitutes the proof `commitments`\n  const mHat = undisclosed_messages.map(\n    (undisclosed, j) => Fr.add(m_j[j], Fr.mul(undisclosed, challenge)));\n  const proof = [Abar, Bbar, D, eHat, r1Hat, r3Hat, ...mHat, challenge];\n  return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.proof_to_octets)({proof, ciphersuite});\n}\n\nfunction ProofInit({\n  PK, signature_result, generators, random_scalars,\n  header = new Uint8Array(),\n  messages = [], undisclosed_indexes = [],\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Deserialization:\n\n  1.  (A, e) = signature_result\n  2.  L = length(messages)\n  3.  U = length(undisclosed_indexes)\n  4.  (j1, ..., jU) = undisclosed_indexes\n  5.  if length(random_scalars) != U + 5, return INVALID\n  6.  (r1, r2, e~, r1~, r3~, m~_j1, ..., m~_jU) = random_scalars\n  7.  (msg_1, ..., msg_L) = messages\n  8.  if length(generators) != L + 1, return INVALID\n  9.  (Q_1, MsgGenerators) = generators\n  10. (H_1, ..., H_L) = MsgGenerators\n  11. (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\n\n  */\n  const [A, e] = signature_result;\n  const {H} = generators;\n  const U = undisclosed_indexes.length;\n  if(random_scalars.length !== (U + 5)) {\n    throw new Error(\n      `\"random_scalars.length\" (${random_scalars.length}) must equal ` +\n      `\"undisclosed_indexes.length + 5\" (${U + 5}).`);\n  }\n\n  /* Algorithm:\n\n  1. domain = calculate_domain(PK, Q_1, (H_1, ..., H_L), header, api_id)\n  2. B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\n  3. D = B * r2\n  4. Abar = A * (r1 * r2)\n  5. Bbar = D * r1 - Abar * e\n  6. T1 = Abar * e~ + D * r1~\n  7. T2 = D * r3~ + H_j1 * m~_j1 + ... + H_jU * m~_jU\n  8. return (Abar, Bbar, D, T1, T2, domain)\n\n  */\n  // calculate `B` and `domain` at once\n  const {B, domain} = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.calculate_B)({\n    PK, generators, header, messages, api_id, ciphersuite\n  });\n  // `e~` expressed as `e_` here, `m~_j1` as `m_[0]`, etc. ...\n  const [r1, r2, e_, r1_, r3_, ...m_j] = random_scalars;\n  const D = B.multiply(r2);\n  const Abar = A.multiply(ciphersuite.Fr.mul(r1, r2));\n  const Bbar = D.multiply(r1).subtract(Abar.multiply(e));\n  const T1 = Abar.multiply(e_).add(D.multiply(r1_));\n  let T2 = D.multiply(r3_);\n  // for each undisclosed index, add matching generator * ordered random scalar\n  for(const [i, j] of undisclosed_indexes.entries()) {\n    T2 = T2.add(H[j].multiply(m_j[i]));\n  }\n  return [Abar, Bbar, D, T1, T2, domain];\n}\n\nfunction ProofVerifyInit({\n  PK, proof, generators, header = new Uint8Array(),\n  disclosed_messages = [], disclosed_indexes = [],\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Deserialization:\n\n  1.  (Abar, Bbar, D, e^, r1^, r3^, commitments, c) = proof\n  2.  U = length(commitments)\n  3.  R = length(disclosed_indexes)\n  4.  L = R + U\n  5.  (i1, ..., iR) = disclosed_indexes\n  6.  for i in disclosed_indexes, if i < 0 or i > L - 1, return INVALID\n  7.  (j1, ..., jU) = (0, 1, ..., L - 1) \\ disclosed_indexes\n  8.  if length(disclosed_messages) != R, return INVALID\n  9.  (msg_i1, ..., msg_iR) = disclosed_messages\n  10. (m^_j1, ...., m^_jU) = commitments\n  11. if length(generators) != L + 1, return INVALID\n  12. (Q_1, MsgGenerators) = generators\n  13. (H_1, ..., H_L) = MsgGenerators\n  14. (H_i1, ..., H_iR) = (MsgGenerators[i1], ..., MsgGenerators[iR])\n  15. (H_j1, ..., H_jU) = (MsgGenerators[j1], ..., MsgGenerators[jU])\n\n  */\n  // `commitments` constitutes `mHat` and `c` is the challenge\n  const [Abar, Bbar, D, eHat, r1Hat, r3Hat, ...commitments] = proof;\n  const c = commitments.pop();\n  const U = commitments.length;\n  const R = disclosed_indexes.length;\n  const L = R + U;\n  if(disclosed_indexes.some(i => isNaN(i) || i < 0 || i > (L - 1))) {\n    throw new Error(\n      `Every index in \"disclosed_indexes\" must be a number >= 0 and ` +\n      `<= ${L}.`);\n  }\n  if(generators.length !== (L + 1)) {\n    throw new Error(\n      `\"generators.length\" (${generators.length}) must equal the ` +\n      `total number of commitments and disclosed indexes + 1 (${L + 1}).`);\n  }\n  // compute undisclosed indexes\n  const {Q_1, H} = generators;\n  const disclosed_indexes_set = new Set(disclosed_indexes);\n  const undisclosed_indexes = [...H.keys()]\n    .filter(i => !disclosed_indexes_set.has(i));\n\n  /* Algorithm:\n\n  1. domain = calculate_domain(PK, Q_1, (H_1, ..., H_L), header, api_id)\n  2. T1 = Bbar * c + Abar * e^ + D * r1^\n  3. Bv = P1 + Q_1 * domain + H_i1 * msg_i1 + ... + H_iR * msg_iR\n  4. T2 = Bv * c + D * r3^ + H_j1 * m^_j1 + ... +  H_jU * m^_jU\n  5. return (Abar, Bbar, D, T1, T2, domain)\n\n  */\n  const domain = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.calculate_domain)({\n    PK, generators, header, api_id, ciphersuite\n  });\n  const T1 = Bbar.multiply(c).add(Abar.multiply(eHat)).add(D.multiply(r1Hat));\n  const {P1} = ciphersuite;\n  let Bv = P1.add(Q_1.multiply(domain));\n  // for each disclosed message, add matching generator * message\n  for(const [i, msg_i] of disclosed_messages.entries()) {\n    Bv = Bv.add(H[disclosed_indexes[i]].multiply(msg_i));\n  }\n  let T2 = Bv.multiply(c).add(D.multiply(r3Hat));\n  // for each commitment (each for an undisclosed message),\n  // add matching generator * commitment\n  for(const [j, mHat_j] of commitments.entries()) {\n    T2 = T2.add(H[undisclosed_indexes[j]].multiply(mHat_j));\n  }\n  return [Abar, Bbar, D, T1, T2, domain];\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/proof.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TEXT_ENCODER: () => (/* binding */ TEXT_ENCODER),\n/* harmony export */   calculate_B: () => (/* binding */ calculate_B),\n/* harmony export */   calculate_domain: () => (/* binding */ calculate_domain),\n/* harmony export */   calculate_random_scalars: () => (/* binding */ calculate_random_scalars),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes),\n/* harmony export */   create_generators: () => (/* binding */ create_generators),\n/* harmony export */   hash_to_scalar: () => (/* binding */ hash_to_scalar),\n/* harmony export */   i2osp: () => (/* binding */ i2osp),\n/* harmony export */   messages_to_scalars: () => (/* binding */ messages_to_scalars),\n/* harmony export */   mocked_calculate_random_scalars: () => (/* binding */ mocked_calculate_random_scalars),\n/* harmony export */   octets_to_proof: () => (/* binding */ octets_to_proof),\n/* harmony export */   octets_to_pubkey: () => (/* binding */ octets_to_pubkey),\n/* harmony export */   octets_to_signature: () => (/* binding */ octets_to_signature),\n/* harmony export */   os2ip: () => (/* reexport safe */ _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE),\n/* harmony export */   proof_to_octets: () => (/* binding */ proof_to_octets),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   signature_to_octets: () => (/* binding */ signature_to_octets)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"./node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/crypto-browser.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n// re-export helpful utilities\n\n\nconst TEXT_ENCODER = new TextEncoder();\n\n// Note: This file uses naming conventions that match the IETF BBS RFC:\n// https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-05.html\n\nfunction calculate_B({\n  PK, generators, header, messages, api_id, ciphersuite\n} = {}) {\n  // B = P1 + Q_1 * domain + H_1 * msg_1 + ... + H_L * msg_L\n  const {P1} = ciphersuite;\n  const {Q_1, H} = generators;\n  const domain = calculate_domain({\n    PK, generators, header, api_id, ciphersuite\n  });\n  let B = P1.add(Q_1.multiply(domain));\n  let i = 0;\n  for(const message of messages) {\n    B = B.add(H[i++].multiply(message));\n  }\n  return {B, domain};\n}\n\nfunction calculate_domain({\n  PK, generators, header = new Uint8Array(),\n  api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Definitions:\n\n  1. domain_dst, an octet string representing the domain separation tag:\n                 api_id || \"H2S_\" where \"H2S_\" is an ASCII string\n                 comprised of 4 bytes.\n  */\n  const domain_dst = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(api_id, TEXT_ENCODER.encode('H2S_'));\n\n  /* Algorithm:\n\n  1. dom_array = (L, Q_1, H_1, ..., H_L)\n  2. dom_octs = serialize(dom_array) || api_id\n  3. dom_input = PK || dom_octs || I2OSP(length(header), 8) || header\n  4. return hash_to_scalar(dom_input, domain_dst)\n\n  */\n  const {Q_1, H} = generators;\n  const L = H.length;\n  const dom_array = [L, Q_1, ...H];\n  let dom_octs = serialize({input_array: dom_array, ciphersuite});\n  if(api_id.length > 0) {\n    dom_octs = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(dom_octs, api_id);\n  }\n  const dom_input = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(PK, dom_octs, i2osp(header.length, 8), header);\n  return hash_to_scalar({msg_octets: dom_input, dst: domain_dst, ciphersuite});\n}\n\nasync function calculate_random_scalars({count, ciphersuite} = {}) {\n  if(!(Number.isSafeInteger(count) && count >= 0)) {\n    throw new Error('\"count\" must be a non-negative safe integer.');\n  }\n  /* Algorithm:\n\n  1. for i in (1, 2, ..., count):\n  2.     r_i = OS2IP(get_random(expand_len)) mod r\n  3. return (r_1, r_2, ..., r_count)\n\n  */\n  // generate random scalars in parallel\n  const promises = new Array(count);\n  for(let i = 0; i < count; ++i) {\n    promises[i] = _generateRandomScalar(ciphersuite);\n  }\n  return Promise.all(promises);\n}\n\nfunction create_generators({\n  count, api_id = new Uint8Array(), ciphersuite, compress = false\n} = {}) {\n  if(!(Number.isSafeInteger(count) && count > 0)) {\n    throw new Error('\"count\" must be a safe integer >= 1.');\n  }\n\n  /* Definitions:\n\n  1. seed_dst, an octet string representing the domain separation tag:\n                api_id || \"SIG_GENERATOR_SEED_\" where \"SIG_GENERATOR_SEED_\"\n                is an ASCII string comprised of 19 bytes.\n  2. generator_dst, an octet string representing the domain separation\n                    tag: api_id || \"SIG_GENERATOR_DST_\", where\n                    \"SIG_GENERATOR_DST_\" is an ASCII string comprised of\n                    18 bytes.\n  3. generator_seed, an octet string representing the domain separation\n                      tag: api_id || \"MESSAGE_GENERATOR_SEED\", where\n                      \"MESSAGE_GENERATOR_SEED\" is an ASCII string comprised\n                      of 22 bytes.\n  */\n  const seed_dst = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n    api_id, TEXT_ENCODER.encode('SIG_GENERATOR_SEED_'));\n  const generator_dst = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n    api_id, TEXT_ENCODER.encode('SIG_GENERATOR_DST_'));\n  const generator_seed = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n    api_id, TEXT_ENCODER.encode('MESSAGE_GENERATOR_SEED'));\n\n  /* Algorithm:\n\n  1. v = expand_message(generator_seed, seed_dst, expand_len)\n  2. for i in (1, 2, ..., count):\n  3.    v = expand_message(v || I2OSP(i, 8), seed_dst, expand_len)\n  4.    generator_i = hash_to_curve_g1(v, generator_dst)\n  5. return (generator_1, ..., generator_count)\n\n  */\n  const generators = new Array(count);\n  let v = ciphersuite.expand_message(generator_seed, seed_dst);\n  for(let i = 1; i <= count; ++i) {\n    v = ciphersuite.expand_message((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(v, i2osp(i, 8)), seed_dst);\n    let g = ciphersuite.hash_to_curve_g1(v, generator_dst);\n    if(compress) {\n      g = ciphersuite.octets_to_point_E1(ciphersuite.point_to_octets_E1(g));\n    }\n    generators[i - 1] = g;\n  }\n\n  // the first point is referred to as `Q_1`\n  generators.Q_1 = generators[0];\n  // the other points are referred to as `H` or `H_Points`\n  generators.H = generators.slice(1);\n\n  return generators;\n}\n\n/**\n * This hashes an arbitrary message (Uint8Array) to a scalar that is in the\n * multiplicative group of integers mod `r` (where `r` is defined by a\n * particular ciphersuite). In other words, it maps an arbitrary string to a\n * number in a particular range via some specific IETF RFC algorithms.\n *\n * @param {object} options - The options to use.\n * @param {Uint8Array} options.msg_octets - The octet string to be hashed.\n * @param {Uint8Array} options.dst - The domain separation tag.\n * @param {object} options.ciphersuite - The ciphersuite to use.\n *\n * @returns {bigint} - The scalar (hashed result).\n */\nfunction hash_to_scalar({msg_octets, dst, ciphersuite} = {}) {\n  /* Algorithm:\n\n  1. uniform_bytes = expand_message(msg_octets, dst, expand_len)\n  2. return OS2IP(uniform_bytes) mod r\n\n  */\n  // Note: `expand_len` is preset by ciphersuite.\n  const uniform_bytes = ciphersuite.expand_message(msg_octets, dst);\n  return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(uniform_bytes), ciphersuite.r);\n}\n\nfunction i2osp(value, length) {\n  value = BigInt(value);\n  if(!(length > 0 && Number.isSafeInteger(length))) {\n    throw new Error(`\"length\" (${length}) must be a positive safe integer.`);\n  }\n  if(value < 0 || value >= 1n << (8n * BigInt(length))) {\n    throw new Error(`\"value\" (${value}) not in byte range (0, ${length}).`);\n  }\n  const octets = new Uint8Array(length);\n  for(let i = length - 1; i >= 0; --i) {\n    octets[i] = Number(value & 0xffn);\n    value >>= 8n;\n  }\n  return octets;\n}\n\nfunction messages_to_scalars({\n  messages, api_id = new Uint8Array(), ciphersuite\n} = {}) {\n  /* Definitions:\n\n  1. map_dst, an octet string representing the domain separation tag:\n              api_id || \"MAP_MSG_TO_SCALAR_AS_HASH_\" where\n              \"MAP_MSG_TO_SCALAR_AS_HASH_\" is an ASCII string comprised of\n              26 bytes.\n\n  ABORT if:\n\n  1. length(messages) > 2^64 - 1\n\n  */\n  const map_dst = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(\n    api_id, TEXT_ENCODER.encode('MAP_MSG_TO_SCALAR_AS_HASH_'));\n  if(!(Number.isSafeInteger(messages.length))) {\n    throw new Error('\"messages.length\" must be a safe integer.');\n  }\n\n  /* Algorithm:\n\n  1. L =  length(messages)\n  2. for i in (1, ..., L):\n  3.     msg_scalar_i = hash_to_scalar(messages[i], map_dst)\n  4. return (msg_scalar_1, ..., msg_scalar_L)\n\n  */\n  return messages.map(\n    msg_octets => hash_to_scalar({msg_octets, dst: map_dst, ciphersuite}));\n}\n\nfunction mocked_calculate_random_scalars({\n  count, seed, dst, ciphersuite\n} = {}) {\n  if(!(Number.isSafeInteger(count) && count >= 0)) {\n    throw new Error('\"count\" must be a non-negative safe integer.');\n  }\n\n  /* Algorithm:\n\n  1. out_len = expand_len * count\n  2. v = expand_message(SEED, dst, out_len)\n  3. if v is INVALID, return INVALID\n  4. for i in (1, ..., count):\n  5.     start_idx = (i-1) * expand_len\n  6.     end_idx = i * expand_len - 1\n  7.     r_i = OS2IP(v[start_idx..end_idx]) mod r\n  8. return (r_1, ...., r_count)\n  */\n  const {expand_len, r} = ciphersuite;\n  const out_len = expand_len * count;\n  const v = ciphersuite.expand_message(seed, dst, out_len);\n  const scalars = new Array(count);\n  // simplified to use 0-based indexing instead of 1-based from above\n  let start_idx = 0;\n  for(let i = 0; i < count; ++i) {\n    const next_idx = start_idx + expand_len;\n    const octets = v.subarray(start_idx, next_idx);\n    start_idx = next_idx;\n    scalars[i] = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(octets), r);\n  }\n  return scalars;\n}\n\nfunction octets_to_proof({proof_octets, ciphersuite} = {}) {\n  /* Algorithm (3 parts...):\n\n  1.  proof_len_floor = 3 * octet_point_length + 4 * octet_scalar_length\n  2.  if length(proof_octets) < proof_len_floor, return INVALID\n\n  */\n  const {r, octet_point_length, octet_scalar_length} = ciphersuite;\n  const proof_len_floor = 3 * octet_point_length + 4 * octet_scalar_length;\n  if(proof_octets.length < proof_len_floor) {\n    throw new Error(\n      `\"proof_octets.length\" (${proof_octets.length}) ` +\n      `must be at least ${proof_len_floor}.`);\n  }\n  // check total proof size is valid here instead of below\n  const remainder = proof_octets.length - proof_len_floor;\n  if(remainder % octet_scalar_length !== 0) {\n    throw new Error('Invalid proof size.');\n  }\n\n  /* Algorithm continued:\n\n  // Points (i.e., (Abar, Bbar, D) in ProofGen) de-serialization.\n  3.  index = 0\n  // FIX to spec: Should say \"for i in (0, 2)\" to get 3 points, not 2.\n  4.  for i in (0, 1):\n  5.      end_index = index + octet_point_length - 1\n  6.      A_i = octets_to_point_E1(proof_octets[index..end_index])\n  7.      if A_i is INVALID or Identity_G1, return INVALID\n  8.      if subgroup_check_G1(A_i) returns INVALID, return INVALID\n  9.      index += octet_point_length\n\n  */\n  let index = 0;\n  const A = new Array(3);\n  for(let i = 0; i <= 2; ++i) {\n    A[i] = ciphersuite.octets_to_point_E1(\n      proof_octets.subarray(index, index + octet_point_length));\n    if(ciphersuite.E1.eql(A, ciphersuite.E1.ONE)) {\n      throw new Error('Invalid point in proof.');\n    }\n    index += octet_point_length;\n  }\n\n  /* Algorithm continued:\n\n  // Scalars (i.e., (e^, r1^, r3^, m^_j1, ..., m^_jU, c) in\n  // ProofGen) de-serialization.\n  10. j = 0\n  11. while index < length(proof_octets):\n  12.     end_index = index + octet_scalar_length - 1\n  13.     s_j = OS2IP(proof_octets[index..end_index])\n  14.     if s_j = 0 or if s_j >= r, return INVALID\n  15.     index += octet_scalar_length\n  16.     j += 1\n  17. if index != length(proof_octets), return INVALID\n  18. msg_commitments = ()\n  19. if j > 4, set msg_commitments = (s_3, ..., s_(j-2))\n  20. return (A_0, A_1, A_2, s_0, s_1, s_2, msg_commitments, s_(j-1))\n\n  */\n  // no need to track `s_j` outside of loop, just get all scalars\n  const scalars = [];\n  while(index < proof_octets.length) {\n    const s_j = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(\n      proof_octets.subarray(index, index + octet_scalar_length));\n    if(s_j === 0 || s_j >= r) {\n      throw new Error('Invalid scalar in proof.');\n    }\n    scalars.push(s_j);\n    index += octet_scalar_length;\n  }\n  // simplified steps 18-20\n  return [...A, ...scalars];\n}\n\nfunction octets_to_pubkey({PK, ciphersuite} = {}) {\n  /* Algorithm:\n\n  1. W = octets_to_point_E2(PK)\n  2. if W is INVALID, return INVALID\n  3. if subgroup_check_G2(W) is INVALID, return INVALID\n  4. if W == Identity_G2, return INVALID\n  5. return W\n\n  */\n  // conversion handles checking that point is on the curve\n  const W = ciphersuite.octets_to_point_E2(PK);\n  // if W == Identity_E2 throw invalid public key error\n  if(ciphersuite.E2.eql(W, ciphersuite.E2.ONE)) {\n    throw new Error('Invalid public key.');\n  }\n  return W;\n}\n\nfunction octets_to_signature({signature_octets, ciphersuite} = {}) {\n  /* Algorithm:\n\n  1.  expected_len = octet_point_length + octet_scalar_length\n  2.  if length(signature_octets) != expected_len, return INVALID\n  3.  A_octets = signature_octets[0..(octet_point_length - 1)]\n  4.  A = octets_to_point_E1(A_octets)\n  5.  if A is INVALID, return INVALID\n  6.  if A == Identity_G1, return INVALID\n  7.  if subgroup_check_G1(A) returns INVALID, return INVALID\n  8.  index = octet_point_length\n  9.  end_index = index + octet_scalar_length - 1\n  10. e = OS2IP(signature_octets[index..end_index])\n  11. if e = 0 or e >= r, return INVALID\n  12. return (A, e)\n\n  */\n  const {octet_point_length, octet_scalar_length} = ciphersuite;\n  const expected_len = octet_point_length + octet_scalar_length;\n  if(signature_octets.length !== expected_len) {\n    throw new Error(\n      `\"signature_octets.length\" (${signature_octets.length}) ` +\n      `must be ${expected_len}.`);\n  }\n\n  const A_octets = signature_octets.subarray(0, octet_point_length);\n  // conversion handles checking that point is on the curve\n  const A = ciphersuite.octets_to_point_E1(A_octets);\n  // if A == Identity_G1 throw invalid signature error\n  if(ciphersuite.E1.eql(A, ciphersuite.E1.ONE)) {\n    throw new Error('Invalid signature.');\n  }\n  const e = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(signature_octets.subarray(octet_point_length));\n  if(e < 0n || e >= ciphersuite.Fr.ORDER) {\n    throw new Error(\n      `signature \"e\" value must be >= 0 and < (${ciphersuite.Fr.ORDER}).`);\n  }\n  return [A, e];\n}\n\nfunction proof_to_octets({proof, ciphersuite} = {}) {\n  // signature has `(A, e)` where A is a point in G1 and `e` is a non-zero\n  // scalar mod `r`\n  /* Algorithm:\n\n  1. (Abar, Bbar, D, e^, r1^, r3^, (m^_1, ..., m^_U), c) = proof\n  2. return serialize((Abar, Bbar, D, e^, r1^, r3^, m^_1, ..., m^_U, c))\n\n  */\n  return serialize({input_array: proof, ciphersuite});\n}\n\nfunction serialize({input_array, ciphersuite} = {}) {\n  const {G1, G2} = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_3__.bls12_381;\n\n  /* Algorithm:\n\n  1.  let octets_result be an empty octet string.\n  2.  for el in input_array:\n  3.      if el is a point of G1: el_octs = point_to_octets_E1(el)\n  4.      else if el is a point of G2: el_octs = point_to_octets_E2(el)\n  5.      else if el is a scalar: el_octs = I2OSP(el, octet_scalar_length)\n  6.      else if el is an integer between 0 and 2^64 - 1:\n  7.          el_octs = I2OSP(el, 8)\n  8.      else: return INVALID\n  9.      octets_result = octets_result || el_octs\n  10. return octets_result\n\n  */\n  let i = 0;\n  const octets_result = new Array(input_array.length);\n  for(const el of input_array) {\n    let octets;\n    if(el instanceof G1.ProjectivePoint) {\n      octets = ciphersuite.point_to_octets_E1(el);\n    } else if(el instanceof G2.ProjectivePoint) {\n      octets = ciphersuite.point_to_octets_E1(el);\n    } else if(typeof el === 'bigint') {\n      // scalar\n      octets = i2osp(el, ciphersuite.octet_scalar_length);\n    } else if(typeof el === 'number') {\n      // regular integer\n      octets = i2osp(el, 8);\n    } else {\n      throw new Error(\n        `Unknown element \"${el}\" detected during \"serialize()\".`);\n    }\n\n    octets_result[i++] = octets;\n  }\n\n  // return joined octets\n  return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...octets_result);\n}\n\nfunction signature_to_octets({signature, ciphersuite} = {}) {\n  // signature has `(A, e)` where A is a point in G1 and `e` is a non-zero\n  // scalar mod `r`\n  /* Algorithm:\n\n  1. (A, e) = signature\n  2. return serialize((A, e))\n\n  */\n  return serialize({input_array: signature, ciphersuite});\n}\n\nasync function gen_random(expand_len) {\n  return _crypto_js__WEBPACK_IMPORTED_MODULE_0__.webcrypto.getRandomValues(new Uint8Array(expand_len));\n}\n\nasync function _generateRandomScalar(ciphersuite) {\n  const random = await gen_random(ciphersuite.expand_len);\n  return (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_2__.mod)((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(random), ciphersuite.r);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/crypto-browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/crypto-browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   webcrypto: () => (/* binding */ webcrypto)\n/* harmony export */ });\n/*!\n * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.\n */\n// eslint-disable-next-line no-undef\nconst webcrypto = globalThis.crypto;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/crypto-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bbs-signatures/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bbs-signatures/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CIPHERSUITES: () => (/* binding */ CIPHERSUITES),\n/* harmony export */   deriveProof: () => (/* binding */ deriveProof),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   secretKeyToPublicKey: () => (/* binding */ secretKeyToPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verifyProof: () => (/* binding */ verifyProof),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/assert.js\");\n/* harmony import */ var _bbs_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bbs/util.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/util.js\");\n/* harmony import */ var _bbs_keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bbs/keypair.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/keypair.js\");\n/* harmony import */ var _bbs_interface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bbs/interface.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/interface.js\");\n/* harmony import */ var _bbs_ciphersuites_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bbs/ciphersuites.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/bbs/ciphersuites.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./crypto.js */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/crypto-browser.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\n\n// export ciphersuite string constants for external use\nconst CIPHERSUITES = {\n  BLS12381_SHAKE256: 'BLS12-381-SHAKE-256',\n  BLS12381_SHA256: 'BLS12-381-SHA-256'\n};\n\n// generates BLS12-381 key pair\nasync function generateKeyPair({seed, ciphersuite} = {}) {\n  // generate `key_material`\n  ciphersuite = (0,_bbs_ciphersuites_js__WEBPACK_IMPORTED_MODULE_4__.getCiphersuite)(ciphersuite);\n  const key_material = seed ?? await _crypto_js__WEBPACK_IMPORTED_MODULE_5__.webcrypto.getRandomValues(\n    new Uint8Array(ciphersuite.octet_scalar_length));\n\n  // generate `SK` to get `PK`\n  const SK = (0,_bbs_keypair_js__WEBPACK_IMPORTED_MODULE_2__.KeyGen)({key_material, ciphersuite});\n  const PK = (0,_bbs_keypair_js__WEBPACK_IMPORTED_MODULE_2__.SkToPk)({SK, ciphersuite});\n\n  // return `key_material` as secret key and `PK` as public key\n  return {\n    secretKey: (0,_bbs_util_js__WEBPACK_IMPORTED_MODULE_1__.i2osp)(SK, ciphersuite.octet_scalar_length),\n    publicKey: PK\n  };\n}\n\nasync function secretKeyToPublicKey({secretKey, ciphersuite} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, secretKey, 'secretKey');\n  ciphersuite = (0,_bbs_ciphersuites_js__WEBPACK_IMPORTED_MODULE_4__.getCiphersuite)(ciphersuite);\n\n  const SK = _scalarFromSecretKey({secretKey, ciphersuite});\n  const publicKey = (0,_bbs_keypair_js__WEBPACK_IMPORTED_MODULE_2__.SkToPk)({SK, ciphersuite});\n  return publicKey;\n}\n\nasync function sign({\n  secretKey, publicKey, header, messages, ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, secretKey, 'secretKey');\n  ciphersuite = (0,_bbs_ciphersuites_js__WEBPACK_IMPORTED_MODULE_4__.getCiphersuite)(ciphersuite);\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  messages.forEach((m, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, m, `messages[${i}]`));\n\n  // load `SK`\n  const SK = _scalarFromSecretKey({secretKey, ciphersuite});\n\n  // load `PK`\n  if(publicKey !== undefined) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, publicKey, 'publicKey');\n  } else {\n    publicKey = (0,_bbs_keypair_js__WEBPACK_IMPORTED_MODULE_2__.SkToPk)({SK, ciphersuite});\n  }\n\n  return (0,_bbs_interface_js__WEBPACK_IMPORTED_MODULE_3__.Sign)({SK, PK: publicKey, header, messages, ciphersuite});\n}\n\nasync function verifySignature({\n  publicKey, signature, header, messages, ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, publicKey, 'publicKey');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, signature, 'signature');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  messages.forEach((m, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, m, `messages[${i}]`));\n\n  return (0,_bbs_interface_js__WEBPACK_IMPORTED_MODULE_3__.Verify)({PK: publicKey, signature, header, messages, ciphersuite});\n}\n\nasync function deriveProof({\n  publicKey, signature, header, messages,\n  presentationHeader, disclosedMessageIndexes,\n  ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, publicKey, 'publicKey');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, signature, 'signature');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(messages, 'messages');\n  messages.forEach((m, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, m, `messages[${i}]`));\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, presentationHeader, 'presentationHeader');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosedMessageIndexes, 'disclosedMessageIndexes');\n  disclosedMessageIndexes.forEach(\n    (idx, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertType)('number', idx, `disclosedMessageIndexes[${i}]`));\n\n  return (0,_bbs_interface_js__WEBPACK_IMPORTED_MODULE_3__.ProofGen)({\n    PK: publicKey, signature, header, ph: presentationHeader,\n    messages, disclosed_indexes: disclosedMessageIndexes, ciphersuite\n  });\n}\n\nasync function verifyProof({\n  publicKey, proof, header,\n  presentationHeader, disclosedMessages, disclosedMessageIndexes,\n  ciphersuite\n} = {}) {\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, publicKey, 'publicKey');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, proof, 'proof');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, header, 'header');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, presentationHeader, 'presentationHeader');\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosedMessages, 'disclosedMessages');\n  disclosedMessages.forEach(\n    (m, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertInstance)(Uint8Array, m, `disclosedMessages[${i}]`));\n  (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertArray)(disclosedMessageIndexes, 'disclosedMessageIndexes');\n  disclosedMessageIndexes.forEach(\n    (idx, i) => (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.assertType)('number', idx, `disclosedMessageIndexes[${i}]`));\n\n  return (0,_bbs_interface_js__WEBPACK_IMPORTED_MODULE_3__.ProofVerify)({\n    PK: publicKey, proof, header, ph: presentationHeader,\n    disclosed_messages: disclosedMessages,\n    disclosed_indexes: disclosedMessageIndexes,\n    ciphersuite\n  });\n}\n\n// utility function to load a secret scalar from secret key bytes\nfunction _scalarFromSecretKey({secretKey, ciphersuite} = {}) {\n  const {octet_scalar_length, r} = ciphersuite;\n  const sk = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_6__.mod)((0,_bbs_util_js__WEBPACK_IMPORTED_MODULE_1__.os2ip)(secretKey, octet_scalar_length), r);\n  if(sk === 0n) {\n    throw new Error('Invalid secret key scalar value of \"0\".');\n  }\n  return sk;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bbs-signatures/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGORITHMS: () => (/* binding */ ALGORITHMS),\n/* harmony export */   BLS12_381_CURVE: () => (/* binding */ BLS12_381_CURVE),\n/* harmony export */   MULTIBASE_BASE58_HEADER: () => (/* binding */ MULTIBASE_BASE58_HEADER),\n/* harmony export */   MULTICODEC_G1_PUBLIC_KEY_HEADER: () => (/* binding */ MULTICODEC_G1_PUBLIC_KEY_HEADER),\n/* harmony export */   MULTICODEC_G1_SECRET_KEY_HEADER: () => (/* binding */ MULTICODEC_G1_SECRET_KEY_HEADER),\n/* harmony export */   MULTICODEC_G2_PUBLIC_KEY_HEADER: () => (/* binding */ MULTICODEC_G2_PUBLIC_KEY_HEADER),\n/* harmony export */   MULTICODEC_G2_SECRET_KEY_HEADER: () => (/* binding */ MULTICODEC_G2_SECRET_KEY_HEADER),\n/* harmony export */   MULTIKEY_CONTEXT_V1_URL: () => (/* binding */ MULTIKEY_CONTEXT_V1_URL)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\nconst ALGORITHMS = {\n  BBS_BLS12381_SHAKE256: 'BBS-BLS12-381-SHAKE-256',\n  BBS_BLS12381_SHA256: 'BBS-BLS12-381-SHA-256'\n};\n\n// Multikey context v1 URL\nconst MULTIKEY_CONTEXT_V1_URL = 'https://w3id.org/security/multikey/v1';\nconst MULTIBASE_BASE58_HEADER = 'z';\n\n// Multicodec G1-pub header (0xea as varint = 0xea01)\nconst MULTICODEC_G1_PUBLIC_KEY_HEADER = new Uint8Array([0xea, 0x01]);\n// Multicodec G2-pub header (0xeb as varint = 0xeb01)\nconst MULTICODEC_G2_PUBLIC_KEY_HEADER = new Uint8Array([0xeb, 0x01]);\n// unused: Multicodec (G1 + G2)-pub header (0xee as varint = 0xee01)\n\n// Multicodec G1-priv header (0x1309 as varint = 0x8926)\nconst MULTICODEC_G1_SECRET_KEY_HEADER = new Uint8Array([0x89, 0x26]);\n// Multicodec G2-priv header (0x130a as varint = 0x8a26)\nconst MULTICODEC_G2_SECRET_KEY_HEADER = new Uint8Array([0x8a, 0x26]);\n// unused: Multicodec (G1 + G2)-priv header (0x130b as varint = 0x8b26)\n\n// BLS12-381 curves\nconst BLS12_381_CURVE = {\n  G1: 'Bls12381G1',\n  G2: 'Bls12381G2'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bls12-381-multikey/lib/factory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bls12-381-multikey/lib/factory.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBbsSigner: () => (/* binding */ createBbsSigner),\n/* harmony export */   createBbsVerifier: () => (/* binding */ createBbsVerifier)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/bbs-signatures */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/index.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n// exposes sign method\nfunction createBbsSigner({id, secretKey, publicKey, algorithm}) {\n  if(!secretKey) {\n    throw new Error('\"secretKey\" is required for signing.');\n  }\n  const ciphersuite = algorithm.slice('BBS-'.length);\n  const multisign = async function({header, messages} = {}) {\n    return _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_0__.sign({secretKey, publicKey, header, messages, ciphersuite});\n  };\n  return {\n    algorithm,\n    id,\n    // include public key in signer interface so it can be included with\n    // base proofs for easier selective disclosure\n    publicKey,\n    multisign,\n    async sign({data} = {}) {\n      // CBOR-decode data into an array of parameters\n      const params = cborg__WEBPACK_IMPORTED_MODULE_1__.decode(data);\n      if(params.length !== 2) {\n        throw new Error(\n          'Sign \"data\" must be a CBOR-encoded array with two parameters: ' +\n          'the BBS \"header\" and BBS \"messages\".');\n      }\n      const [header, messages] = params;\n      return multisign({header, messages});\n    }\n  };\n}\n\n// exposes verify method\nfunction createBbsVerifier({id, publicKey, algorithm}) {\n  if(!publicKey) {\n    throw new Error('\"publicKey\" is required for verifying.');\n  }\n  const ciphersuite = algorithm.slice('BBS-'.length);\n  return {\n    algorithm,\n    id,\n    async multiverify({proof, header, presentationHeader, messages} = {}) {\n      // `messages` can be a sparse array\n      const disclosedMessageIndexes = messages\n        .map((m, i) => m ? i : undefined)\n        .filter(m => m !== undefined);\n      const disclosedMessages = messages.filter(m => m);\n      return _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_0__.verifyProof({\n        publicKey, proof, header,\n        presentationHeader, disclosedMessages, disclosedMessageIndexes,\n        ciphersuite\n      });\n    },\n    async verify() {\n      throw new Error('\"verify()\" not implemented; use \"multiverify()\".');\n    }\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bls12-381-multikey/lib/factory.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bls12-381-multikey/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bls12-381-multikey/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNamedCurveFromPublicMultikey: () => (/* binding */ getNamedCurveFromPublicMultikey),\n/* harmony export */   getNamedCurveFromSecretMultikey: () => (/* binding */ getNamedCurveFromSecretMultikey),\n/* harmony export */   getPublicKeySize: () => (/* binding */ getPublicKeySize),\n/* harmony export */   getSecretKeySize: () => (/* binding */ getSecretKeySize),\n/* harmony export */   setPublicKeyHeader: () => (/* binding */ setPublicKeyHeader),\n/* harmony export */   setSecretKeyHeader: () => (/* binding */ setSecretKeyHeader)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// retrieves name of appropriate BLS12-381 curve from public Multikey\nfunction getNamedCurveFromPublicMultikey({publicMultikey}) {\n  if(publicMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_PUBLIC_KEY_HEADER[0] &&\n    publicMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_PUBLIC_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1;\n  }\n  if(publicMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_PUBLIC_KEY_HEADER[0] &&\n    publicMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_PUBLIC_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2;\n  }\n  throw new TypeError('Unsupported public multikey header.');\n}\n\n// retrieves name of appropriate BLS12-381 curve from secret Multikey\nfunction getNamedCurveFromSecretMultikey({secretMultikey}) {\n  if(secretMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_SECRET_KEY_HEADER[0] &&\n    secretMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_SECRET_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1;\n  }\n  if(secretMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_SECRET_KEY_HEADER[0] &&\n    secretMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_SECRET_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2;\n  }\n  throw new TypeError('Unsupported secret multikey header.');\n}\n\nfunction getPublicKeySize({curve}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1) {\n    return 48;\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2) {\n    return 96;\n  }\n  throw new TypeError(`Unsupported curve \"${curve}\".`);\n}\n\nfunction getSecretKeySize({curve}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1 || curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2) {\n    return 32;\n  }\n  throw new TypeError(`Unsupported curve \"${curve}\".`);\n}\n\n// sets secret key header bytes on key pair\nfunction setSecretKeyHeader({curve, buffer}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_SECRET_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_SECRET_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_SECRET_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_SECRET_KEY_HEADER[1];\n  } else {\n    throw new TypeError(`Unsupported curve \"${curve}\".`);\n  }\n}\n\n// sets public key header bytes on key pair\nfunction setPublicKeyHeader({curve, buffer}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G1) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_PUBLIC_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G1_PUBLIC_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.BLS12_381_CURVE.G2) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_PUBLIC_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_G2_PUBLIC_KEY_HEADER[1];\n  } else {\n    throw new TypeError(`Unsupported curve \"${curve}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bls12-381-multikey/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGORITHMS: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHMS),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromJwk: () => (/* binding */ fromJwk),\n/* harmony export */   fromRaw: () => (/* binding */ fromRaw),\n/* harmony export */   generateBbsKeyPair: () => (/* binding */ generateBbsKeyPair),\n/* harmony export */   toJwk: () => (/* binding */ toJwk)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/bbs-signatures */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factory.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/factory.js\");\n/* harmony import */ var _serialize_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./serialize.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/serialize.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n// re-export algorithms\n\nconst ALL_ALGORITHMS = new Set([...Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHMS)]);\n\n// generates BLS12-381 key pair for BBS signatures\nasync function generateBbsKeyPair({\n  id, controller, algorithm, seed\n} = {}) {\n  if(!ALL_ALGORITHMS.has(algorithm)) {\n    throw new Error(`Unknown algorithm \"${algorithm}\".`);\n  }\n  const ciphersuite = algorithm.slice('BBS-'.length);\n  const keyPair = await _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_1__.generateKeyPair({seed, ciphersuite});\n  const keyPairInterface = await _createKeyPairInterface({\n    keyPair: {...keyPair, curve: _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLS12_381_CURVE.G2}, options: {algorithm}\n  });\n  const exportedKeyPair = await keyPairInterface.export({publicKey: true});\n  const {publicKeyMultibase} = exportedKeyPair;\n  if(controller && !id) {\n    id = `${controller}#${publicKeyMultibase}`;\n  }\n  keyPairInterface.id = id;\n  keyPairInterface.controller = controller;\n  return keyPairInterface;\n}\n\n// imports key pair from JSON Multikey\nasync function from(multikeyLike, options = {\n  // default algorithm\n  algorithm: _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHMS.BBS_BLS12381_SHA256\n}) {\n  // backwards compatibility\n  const multikey = {...multikeyLike};\n  if(multikey.type !== 'Multikey') {\n    // attempt loading from JWK if `publicKeyJwk` is present\n    if(multikey.publicKeyJwk) {\n      return fromJwk({jwk: multikey.publicKeyJwk, secretKey: false});\n    }\n  }\n  if(!multikey.type) {\n    multikey.type = 'Multikey';\n  }\n  if(!multikey['@context']) {\n    multikey['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL;\n  }\n  if(multikey.controller && !multikey.id) {\n    multikey.id =\n      `${multikeyLike.controller}#${multikeyLike.publicKeyMultibase}`;\n  }\n  _assertMultikey(multikey);\n  return _createKeyPairInterface({keyPair: multikey, options});\n}\n\n// imports key pair from JWK\nasync function fromJwk({jwk, secretKey = false} = {}) {\n  const multikey = {\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL,\n    type: 'Multikey',\n    publicKeyMultibase: (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.jwkToPublicKeyMultibase)({jwk})\n  };\n  if(secretKey && jwk.d) {\n    multikey.secretKeyMultibase = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.jwkToSecretKeyMultibase)({jwk});\n  }\n  // default to `BBS-BLS12-381-SHA-256` when coming from JWK\n  const algorithm = !jwk.alg || jwk.alg.startsWith('BBS-DRAFT-') ?\n    _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHMS.BBS_BLS12381_SHA256 : jwk.alg;\n  const options = {algorithm};\n  return from(multikey, options);\n}\n\n// converts key pair to JWK\nasync function toJwk({keyPair, secretKey = false} = {}) {\n  const jwk = {\n    kty: 'OKP',\n    alg: keyPair.algorithm,\n    crv: keyPair.curve,\n    x: base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(keyPair.publicKey)\n  };\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n  if(useSecretKey) {\n    jwk.d = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(keyPair.secretKey);\n  }\n  return jwk;\n}\n\n// raw import from secretKey and publicKey bytes\nasync function fromRaw({algorithm, curve, secretKey, publicKey} = {}) {\n  if(algorithm) {\n    if(!ALL_ALGORITHMS.has(algorithm)) {\n      throw new Error(`Unknown algorithm \"${algorithm}\".`);\n    }\n    if(curve) {\n      if(curve !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLS12_381_CURVE.G2) {\n        throw new Error(`Curve \"${curve}\" must be \"${_constants_js__WEBPACK_IMPORTED_MODULE_2__.BLS12_381_CURVE.G2}\".`);\n      }\n    } else {\n      curve = _constants_js__WEBPACK_IMPORTED_MODULE_2__.BLS12_381_CURVE.G2;\n    }\n  }\n  if(typeof curve !== 'string') {\n    throw new TypeError('\"curve\" must be a string.');\n  }\n  if(secretKey && !(secretKey instanceof Uint8Array)) {\n    throw new TypeError('\"secretKey\" must be a Uint8Array.');\n  }\n  if(!(publicKey instanceof Uint8Array)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array.');\n  }\n  const jwk = await toJwk({\n    keyPair: {\n      algorithm: algorithm ?? _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHMS.BBS_BLS12381_SHA256,\n      curve,\n      publicKey,\n      secretKey\n    },\n    secretKey: !!secretKey\n  });\n  return fromJwk({jwk, secretKey: !!secretKey});\n}\n\n// augments key pair with useful metadata and utilities\nasync function _createKeyPairInterface({keyPair, options = {}}) {\n  if(typeof options?.algorithm !== 'string') {\n    throw new TypeError('\"options.algorithm\" must be a string.');\n  }\n  const {algorithm} = options;\n  if(!ALL_ALGORITHMS.has(algorithm)) {\n    throw new Error(`Unknown algorithm \"${algorithm}\".`);\n  }\n\n  // import key pair if `curve`, `publicKey`, or `secretKey` are not set\n  if(!(keyPair.curve && keyPair.publicKey && keyPair.secretKey)) {\n    keyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.importKeyPair)(keyPair, {algorithm});\n  }\n  const exportFn = async ({\n    publicKey = true, secretKey = false, includeContext = true, raw = false\n  } = {}) => {\n    if(raw) {\n      const jwk = await toJwk({keyPair, secretKey});\n      const result = {curve: keyPair.curve};\n      if(publicKey) {\n        result.publicKey = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.jwkToPublicKeyBytes)({jwk});\n      }\n      if(secretKey) {\n        result.secretKey = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.jwkToSecretKeyBytes)({jwk});\n      }\n      return result;\n    }\n    return (0,_serialize_js__WEBPACK_IMPORTED_MODULE_4__.exportKeyPair)({keyPair, publicKey, secretKey, includeContext});\n  };\n  const {publicKeyMultibase, secretKeyMultibase} = await exportFn({\n    publicKey: true, secretKey: true, includeContext: true\n  });\n  keyPair = {\n    ...keyPair,\n    algorithm,\n    publicKeyMultibase,\n    secretKeyMultibase,\n    export: exportFn,\n    signer() {\n      const {id, secretKey, publicKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_3__.createBbsSigner)({id, secretKey, publicKey, algorithm});\n    },\n    // derives a BBS proof from a BBS signature\n    async deriveProof({\n      signature, header, messages,\n      presentationHeader, disclosedMessageIndexes\n    }) {\n      const {algorithm, publicKey} = keyPair;\n      const ciphersuite = algorithm.slice('BBS-'.length);\n      return _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_1__.deriveProof({\n        publicKey, signature, header, messages,\n        presentationHeader, disclosedMessageIndexes,\n        ciphersuite\n      });\n    },\n    verifier() {\n      const {id, publicKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_3__.createBbsVerifier)({id, publicKey, algorithm});\n    }\n  };\n\n  return keyPair;\n}\n\n// checks if key pair is in Multikey format\nfunction _assertMultikey(key) {\n  if(!(key && typeof key === 'object')) {\n    throw new TypeError('\"key\" must be an object.');\n  }\n  if(key.type !== 'Multikey') {\n    throw new TypeError('\"key\" must be a Multikey with type \"Multikey\".');\n  }\n  if(!(key['@context'] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL ||\n    (Array.isArray(key['@context']) &&\n    key['@context'].includes(_constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL)))) {\n    throw new TypeError(\n      '\"key\" must be a Multikey with context ' +\n      `\"${_constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bls12-381-multikey/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/bls12-381-multikey/lib/serialize.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/bls12-381-multikey/lib/serialize.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportKeyPair: () => (/* binding */ exportKeyPair),\n/* harmony export */   importKeyPair: () => (/* binding */ importKeyPair),\n/* harmony export */   jwkToPublicKeyBytes: () => (/* binding */ jwkToPublicKeyBytes),\n/* harmony export */   jwkToPublicKeyMultibase: () => (/* binding */ jwkToPublicKeyMultibase),\n/* harmony export */   jwkToSecretKeyBytes: () => (/* binding */ jwkToSecretKeyBytes),\n/* harmony export */   jwkToSecretKeyMultibase: () => (/* binding */ jwkToSecretKeyMultibase),\n/* harmony export */   rawToPublicKeyMultibase: () => (/* binding */ rawToPublicKeyMultibase),\n/* harmony export */   rawToSecretKeyMultibase: () => (/* binding */ rawToSecretKeyMultibase)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/bbs-signatures */ \"./node_modules/@digitalbazaar/bbs-signatures/lib/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/constants.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/bls12-381-multikey/lib/helpers.js\");\n/* harmony import */ var _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/bls12-381 */ \"./node_modules/@noble/curves/esm/bls12-381.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\n\nconst G1Point = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_5__.bls12_381.G1.ProjectivePoint;\nconst G2Point = _noble_curves_bls12_381__WEBPACK_IMPORTED_MODULE_5__.bls12_381.G2.ProjectivePoint;\n\n// exports key pair\nasync function exportKeyPair({\n  keyPair, secretKey, publicKey, includeContext\n} = {}) {\n  if(!(publicKey || secretKey)) {\n    throw new TypeError(\n      'Export requires specifying either \"publicKey\" or \"secretKey\".');\n  }\n\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n\n  // export as Multikey\n  const exported = {};\n  if(includeContext) {\n    exported['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIKEY_CONTEXT_V1_URL;\n  }\n  exported.id = keyPair.id;\n  exported.type = 'Multikey';\n  exported.controller = keyPair.controller;\n\n  if(publicKey) {\n    exported.publicKeyMultibase = rawToPublicKeyMultibase(keyPair);\n  }\n  if(useSecretKey) {\n    exported.secretKeyMultibase = rawToSecretKeyMultibase(keyPair);\n  }\n\n  return exported;\n}\n\n// imports key pair\nasync function importKeyPair({\n  id, controller, secretKeyMultibase, publicKeyMultibase\n}, {algorithm}) {\n  if(!(publicKeyMultibase || secretKeyMultibase)) {\n    throw new TypeError(\n      'Either \"publicKeyMultibase\" or \"secretKeyMultibase\" are required.');\n  }\n\n  const keyPair = {\n    id, controller, algorithm, curve: undefined, publicKey: undefined\n  };\n\n  // import secret key if given\n  let secretMultikey;\n  if(secretKeyMultibase) {\n    if(!(typeof secretKeyMultibase === 'string' &&\n    secretKeyMultibase[0] === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER)) {\n      throw new TypeError(\n        '\"secretKeyMultibase\" must be a multibase, base58-encoded string.');\n    }\n    // get raw secret key\n    secretMultikey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(secretKeyMultibase.slice(1));\n    keyPair.curve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromSecretMultikey)({secretMultikey});\n    keyPair.secretKey = secretMultikey.slice(2);\n  }\n\n  // import public key\n  if(!publicKeyMultibase) {\n    // generate `publicKey` from `secretKey`\n    const ciphersuite = algorithm.slice('BBS-'.length);\n    const {secretKey} = keyPair;\n    const publicKey = await _digitalbazaar_bbs_signatures__WEBPACK_IMPORTED_MODULE_2__.secretKeyToPublicKey({secretKey, ciphersuite});\n    keyPair.publicKey = publicKey;\n  } else if(typeof publicKeyMultibase === 'string' &&\n    publicKeyMultibase[0] === _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER) {\n    // get curve and raw public key\n    const publicMultikey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(publicKeyMultibase.slice(1));\n    keyPair.curve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromPublicMultikey)({publicMultikey});\n    keyPair.publicKey = publicMultikey.slice(2);\n\n    // ensure secret key multikey header appropriately matches the\n    // public key multikey header\n    if(secretMultikey) {\n      _ensureMultikeyHeadersMatch({secretMultikey, publicMultikey});\n    }\n  } else {\n    throw new TypeError(\n      '\"publicKeyMultibase\" must be a multibase, base58-encoded string.');\n  }\n\n  return keyPair;\n}\n\nfunction jwkToPublicKeyBytes({jwk} = {}) {\n  if(jwk?.kty !== 'OKP') {\n    throw new TypeError('\"jwk.kty\" must be \"OKP\".');\n  }\n  const {crv: curve} = jwk;\n  const publicKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getPublicKeySize)({curve});\n\n  // JWK can have just `x` with the full compressed public key or\n  // `x` and `y` (despite using a type of `OKP`), so we handle both\n  let publicKey;\n  const x = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.x);\n  if(jwk.y) {\n    // convert coordinates to compressed public key bytes\n    const y = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.y);\n    publicKey = _coordinatesToPublicKey({curve, x, y});\n  } else {\n    // `x` has compressed public key bytes\n    publicKey = Uint8Array.from(x);\n  }\n  if(publicKey.length !== publicKeySize) {\n    throw new Error(\n      `Invalid public key size (${publicKey.length}); ` +\n      `expected ${publicKeySize}.`);\n  }\n  return publicKey;\n}\n\nfunction jwkToPublicKeyMultibase({jwk} = {}) {\n  const {crv: curve} = jwk;\n  const publicKey = jwkToPublicKeyBytes({jwk});\n\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + publicKey.length);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setPublicKeyHeader)({curve, buffer: multikey});\n\n  // write compressed public key\n  multikey.set(publicKey, 2);\n  const publicKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return publicKeyMultibase;\n}\n\nfunction jwkToSecretKeyBytes({jwk} = {}) {\n  if(jwk?.kty !== 'OKP') {\n    throw new TypeError('\"jwk.kty\" must be \"OKP\".');\n  }\n  const {crv: curve} = jwk;\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  // if `jwk` has `y`, then assume `d` is little endian encoded, otherwise,\n  // assume it is big endian encoded (as both of these JWK expressions have\n  // been documented)\n  const secretKey = Uint8Array.from(base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.d));\n  if(jwk.y) {\n    // little endian encoding\n    secretKey.reverse();\n  }\n  if(secretKey.length !== secretKeySize) {\n    throw new Error(\n      `Invalid secret key size (${secretKey.length}); ` +\n      `expected ${secretKeySize}.`);\n  }\n  return secretKey;\n}\n\nfunction jwkToSecretKeyMultibase({jwk} = {}) {\n  const secretKey = jwkToSecretKeyBytes({jwk});\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + secretKey.length);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setSecretKeyHeader)({curve: jwk.crv, buffer: multikey});\n  // write `secretKey`\n  multikey.set(secretKey, 2);\n  const secretKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return secretKeyMultibase;\n}\n\nfunction rawToPublicKeyMultibase({curve, publicKey} = {}) {\n  const publicKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getPublicKeySize)({curve});\n  if(publicKey.length !== publicKeySize) {\n    throw new Error(\n      `Invalid public key size (${publicKey.length}); ` +\n      `expected ${publicKeySize}.`);\n  }\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + publicKeySize);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setPublicKeyHeader)({curve, buffer: multikey});\n  // write `publicKey`\n  multikey.set(publicKey, 2);\n  const publicKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return publicKeyMultibase;\n}\n\nfunction rawToSecretKeyMultibase({curve, secretKey} = {}) {\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  if(secretKey.length !== secretKeySize) {\n    throw new Error(\n      `Invalid secret key size (${secretKey.length}); ` +\n      `expected ${secretKeySize}.`);\n  }\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + secretKeySize);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setSecretKeyHeader)({curve, buffer: multikey});\n  // write `secretKey`\n  multikey.set(secretKey, 2);\n  const secretKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_3__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return secretKeyMultibase;\n}\n\n// convert affine coordinates to compressed public key\nfunction _coordinatesToPublicKey({curve, x, y}) {\n  const combined = (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.concatBytes)(x, y);\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLS12_381_CURVE.G1) {\n    return G1Point.fromHex(combined).toRawBytes(true);\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_3__.BLS12_381_CURVE.G2) {\n    return G2Point.fromHex(combined).toRawBytes(true);\n  }\n  throw new TypeError(`Unsupported curve \"${curve}\".`);\n}\n\n// ensures that public key header matches secret key header\nfunction _ensureMultikeyHeadersMatch({secretMultikey, publicMultikey}) {\n  const publicCurve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromPublicMultikey)({publicMultikey});\n  const secretCurve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromSecretMultikey)({secretMultikey});\n  if(publicCurve !== secretCurve) {\n    throw new Error(\n      `Public key curve ('${publicCurve}') does not match ` +\n      `secret key curve ('${secretCurve}').`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/bls12-381-multikey/lib/serialize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/credentials-v2-context/js/context.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/credentials-v2-context/js/context.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n// Use JSON style for context\n/* eslint quotes: ['error', 'double'] */\n/* eslint quote-props: ['error', 'always'] */\n/* eslint-disable max-len */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  \"@context\": {\n    \"@protected\": true,\n    \"@vocab\": \"https://www.w3.org/ns/credentials/issuer-dependent#\",\n\n    \"id\": \"@id\",\n    \"type\": \"@type\",\n\n    \"kid\": {\n      \"@id\": \"https://www.iana.org/assignments/jose#kid\",\n      \"@type\": \"@id\"\n    },\n    \"iss\": {\n      \"@id\": \"https://www.iana.org/assignments/jose#iss\",\n      \"@type\": \"@id\"\n    },\n    \"sub\": {\n      \"@id\": \"https://www.iana.org/assignments/jose#sub\",\n      \"@type\": \"@id\"\n    },\n    \"jku\": {\n      \"@id\": \"https://www.iana.org/assignments/jose#jku\",\n      \"@type\": \"@id\"\n    },\n    \"x5u\": {\n      \"@id\": \"https://www.iana.org/assignments/jose#x5u\",\n      \"@type\": \"@id\"\n    },\n    \"aud\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#aud\",\n      \"@type\": \"@id\"\n    },\n    \"exp\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#exp\",\n      \"@type\": \"https://www.w3.org/2001/XMLSchema#nonNegativeInteger\"\n    },\n    \"nbf\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#nbf\",\n      \"@type\": \"https://www.w3.org/2001/XMLSchema#nonNegativeInteger\"\n    },\n    \"iat\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#iat\",\n      \"@type\": \"https://www.w3.org/2001/XMLSchema#nonNegativeInteger\"\n    },\n    \"cnf\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#cnf\",\n      \"@context\": {\n        \"@protected\": true,\n        \"kid\": {\n          \"@id\": \"https://www.iana.org/assignments/jwt#kid\",\n          \"@type\": \"@id\"\n        },\n        \"jwk\": {\n          \"@id\": \"https://www.iana.org/assignments/jwt#jwk\",\n          \"@type\": \"@json\"\n        }\n      }\n    },\n    \"_sd_alg\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#_sd_alg\"\n    },\n    \"_sd\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#_sd\"\n    },\n    \"...\": {\n      \"@id\": \"https://www.iana.org/assignments/jwt#...\"\n    },\n\n    \"digestSRI\": {\n      \"@id\": \"https://www.w3.org/2018/credentials#digestSRI\",\n      \"@type\": \"https://www.w3.org/2018/credentials#sriString\"\n    },\n    \"digestMultibase\": {\n      \"@id\": \"https://w3id.org/security#digestMultibase\",\n      \"@type\": \"https://w3id.org/security#multibase\"\n    },\n\n    \"encodingFormat\": {\n      \"@id\": \"https://schema.org/encodingFormat\"\n    },\n\n    \"description\": \"https://schema.org/description\",\n    \"name\": \"https://schema.org/name\",\n\n    \"EnvelopedVerifiableCredential\":\n      \"https://www.w3.org/2018/credentials#EnvelopedVerifiableCredential\",\n\n    \"VerifiableCredential\": {\n      \"@id\": \"https://www.w3.org/2018/credentials#VerifiableCredential\",\n      \"@context\": {\n        \"@protected\": true,\n\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n\n        \"credentialSchema\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#credentialSchema\",\n          \"@type\": \"@id\"\n        },\n        \"credentialStatus\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#credentialStatus\",\n          \"@type\": \"@id\"\n        },\n        \"credentialSubject\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#credentialSubject\",\n          \"@type\": \"@id\"\n        },\n        \"description\": \"https://schema.org/description\",\n        \"evidence\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#evidence\",\n          \"@type\": \"@id\"\n        },\n        \"validFrom\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#validFrom\",\n          \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\"\n        },\n        \"validUntil\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#validUntil\",\n          \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\"\n        },\n        \"issuer\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#issuer\",\n          \"@type\": \"@id\"\n        },\n        \"name\": \"https://schema.org/name\",\n        \"proof\": {\n          \"@id\": \"https://w3id.org/security#proof\",\n          \"@type\": \"@id\",\n          \"@container\": \"@graph\"\n        },\n        \"refreshService\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#refreshService\",\n          \"@type\": \"@id\"\n        },\n        \"termsOfUse\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#termsOfUse\",\n          \"@type\": \"@id\"\n        },\n        \"confidenceMethod\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#confidenceMethod\",\n          \"@type\": \"@id\"\n        },\n        \"relatedResource\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#relatedResource\",\n          \"@type\": \"@id\"\n        }\n      }\n    },\n\n    \"VerifiablePresentation\": {\n      \"@id\": \"https://www.w3.org/2018/credentials#VerifiablePresentation\",\n      \"@context\": {\n        \"@protected\": true,\n\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n        \"holder\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#holder\",\n          \"@type\": \"@id\"\n        },\n        \"proof\": {\n          \"@id\": \"https://w3id.org/security#proof\",\n          \"@type\": \"@id\",\n          \"@container\": \"@graph\"\n        },\n        \"verifiableCredential\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#verifiableCredential\",\n          \"@type\": \"@id\",\n          \"@container\": \"@graph\",\n          \"@context\": null\n        },\n        \"termsOfUse\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#termsOfUse\",\n          \"@type\": \"@id\"\n        }\n      }\n    },\n\n    \"JsonSchemaCredential\": \"https://www.w3.org/2018/credentials#JsonSchemaCredential\",\n\n    \"JsonSchema\": {\n      \"@id\": \"https://www.w3.org/2018/credentials#JsonSchema\",\n      \"@context\": {\n        \"@protected\": true,\n\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n\n        \"jsonSchema\": {\n          \"@id\": \"https://www.w3.org/2018/credentials#jsonSchema\",\n          \"@type\": \"@json\"\n        }\n      }\n    },\n\n    \"BitstringStatusListCredential\": \"https://www.w3.org/ns/credentials/status#BitstringStatusListCredential\",\n\n    \"BitstringStatusList\": {\n      \"@id\": \"https://www.w3.org/ns/credentials/status#BitstringStatusList\",\n      \"@context\": {\n        \"@protected\": true,\n\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n\n        \"statusPurpose\":\n          \"https://www.w3.org/ns/credentials/status#statusPurpose\",\n        \"encodedList\": {\n          \"@id\": \"https://www.w3.org/ns/credentials/status#encodedList\",\n          \"@type\": \"https://w3id.org/security#multibase\"\n        },\n        \"ttl\": \"https://www.w3.org/ns/credentials/status#ttl\",\n        \"statusReference\": \"https://www.w3.org/ns/credentials/status#statusReference\",\n        \"statusSize\": \"https://www.w3.org/ns/credentials/status#statusSize\",\n        \"statusMessage\": {\n          \"@id\": \"https://www.w3.org/ns/credentials/status#statusMessage\",\n          \"@context\": {\n            \"@protected\": true,\n\n            \"id\": \"@id\",\n            \"type\": \"@type\",\n\n            \"status\": \"https://www.w3.org/ns/credentials/status#status\",\n            \"message\": \"https://www.w3.org/ns/credentials/status#message\"\n          }\n        }\n      }\n    },\n\n    \"BitstringStatusListEntry\": {\n      \"@id\":\n        \"https://www.w3.org/ns/credentials/status#BitstringStatusListEntry\",\n      \"@context\": {\n        \"@protected\": true,\n\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n\n        \"statusPurpose\":\n          \"https://www.w3.org/ns/credentials/status#statusPurpose\",\n        \"statusListIndex\":\n          \"https://www.w3.org/ns/credentials/status#statusListIndex\",\n        \"statusListCredential\": {\n          \"@id\":\n            \"https://www.w3.org/ns/credentials/status#statusListCredential\",\n          \"@type\": \"@id\"\n        }\n      }\n    },\n\n    \"DataIntegrityProof\": {\n      \"@id\": \"https://w3id.org/security#DataIntegrityProof\",\n      \"@context\": {\n        \"@protected\": true,\n        \"id\": \"@id\",\n        \"type\": \"@type\",\n        \"challenge\": \"https://w3id.org/security#challenge\",\n        \"created\": {\n          \"@id\": \"http://purl.org/dc/terms/created\",\n          \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\"\n        },\n        \"domain\": \"https://w3id.org/security#domain\",\n        \"expires\": {\n          \"@id\": \"https://w3id.org/security#expiration\",\n          \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\"\n        },\n        \"nonce\": \"https://w3id.org/security#nonce\",\n        \"previousProof\": {\n          \"@id\": \"https://w3id.org/security#previousProof\",\n          \"@type\": \"@id\"\n        },\n        \"proofPurpose\": {\n          \"@id\": \"https://w3id.org/security#proofPurpose\",\n          \"@type\": \"@vocab\",\n          \"@context\": {\n            \"@protected\": true,\n            \"id\": \"@id\",\n            \"type\": \"@type\",\n            \"assertionMethod\": {\n              \"@id\": \"https://w3id.org/security#assertionMethod\",\n              \"@type\": \"@id\",\n              \"@container\": \"@set\"\n            },\n            \"authentication\": {\n              \"@id\": \"https://w3id.org/security#authenticationMethod\",\n              \"@type\": \"@id\",\n              \"@container\": \"@set\"\n            },\n            \"capabilityInvocation\": {\n              \"@id\": \"https://w3id.org/security#capabilityInvocationMethod\",\n              \"@type\": \"@id\",\n              \"@container\": \"@set\"\n            },\n            \"capabilityDelegation\": {\n              \"@id\": \"https://w3id.org/security#capabilityDelegationMethod\",\n              \"@type\": \"@id\",\n              \"@container\": \"@set\"\n            },\n            \"keyAgreement\": {\n              \"@id\": \"https://w3id.org/security#keyAgreementMethod\",\n              \"@type\": \"@id\",\n              \"@container\": \"@set\"\n            }\n          }\n        },\n        \"cryptosuite\": {\n          \"@id\": \"https://w3id.org/security#cryptosuite\",\n          \"@type\": \"https://w3id.org/security#cryptosuiteString\"\n        },\n        \"proofValue\": {\n          \"@id\": \"https://w3id.org/security#proofValue\",\n          \"@type\": \"https://w3id.org/security#multibase\"\n        },\n        \"verificationMethod\": {\n          \"@id\": \"https://w3id.org/security#verificationMethod\",\n          \"@type\": \"@id\"\n        }\n      }\n    }\n  }\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/credentials-v2-context/js/context.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/credentials-v2-context/js/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/credentials-v2-context/js/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTEXT: () => (/* binding */ CONTEXT),\n/* harmony export */   CONTEXT_URL: () => (/* binding */ CONTEXT_URL),\n/* harmony export */   appContextMap: () => (/* binding */ appContextMap),\n/* harmony export */   constants: () => (/* binding */ constants),\n/* harmony export */   contexts: () => (/* binding */ contexts)\n/* harmony export */ });\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \"./node_modules/@digitalbazaar/credentials-v2-context/js/context.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = {\n  // default context output filename under ./contexts/\n  CONTEXT_FILENAME: 'credentials-v2.jsonld',\n  // default context well known URL id\n  CONTEXT_URL: 'https://www.w3.org/ns/credentials/v2',\n  // default context CBOR-LD codec id\n  // value between 0x0 and 0x7FFF for globally registered term codec values\n  // or >= 0x8000 for app-specific local terms\n  CBORLD_VALUE: 0x0\n};\n\n// map of all context URLs to context data\nconst contexts = new Map();\ncontexts.set(constants.CONTEXT_URL, _context_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n// map of all context URLs to CBOR-LD codec ids\nconst appContextMap = new Map();\nappContextMap.set(constants.CONTEXT_URL, constants.CBORLD_VALUE);\n\nconst CONTEXT = _context_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nconst CONTEXT_URL = constants.CONTEXT_URL;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/credentials-v2-context/js/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataIntegrityProof: () => (/* binding */ DataIntegrityProof)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@digitalbazaar/data-integrity/lib/util.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var _sha256digest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sha256digest.js */ \"./node_modules/@digitalbazaar/data-integrity/lib/sha256digest-browser.js\");\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\nconst {suites: {LinkedDataProof}} = jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__;\n\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n// multibase base64url no pad header\nconst MULTIBASE_BASE64URL_HEADER = 'u';\nconst DATA_INTEGRITY_CONTEXT_V2 = 'https://w3id.org/security/data-integrity/v2';\nconst DATA_INTEGRITY_CONTEXT_V1 = 'https://w3id.org/security/data-integrity/v1';\nconst PROOF_TYPE = 'DataIntegrityProof';\n// VCDM 2.0 core context\nconst VC_2_0_CONTEXT = 'https://www.w3.org/ns/credentials/v2';\n\nclass DataIntegrityProof extends LinkedDataProof {\n  constructor({signer, date, cryptosuite, legacyContext = false} = {}) {\n    super({type: PROOF_TYPE});\n    const {\n      canonize, createVerifier, name, requiredAlgorithm,\n      derive, createProofValue, createVerifyData\n    } = cryptosuite;\n    // `createVerifier` is required\n    if(!(createVerifier && typeof createVerifier === 'function')) {\n      throw new TypeError(\n        '\"cryptosuite.createVerifier\" must be a function.');\n    }\n    // assert optional functions\n    if(derive && typeof derive !== 'function') {\n      throw new TypeError(\n        '\"cryptosuite.derive\" must be a function.');\n    }\n    if(createProofValue && typeof createProofValue !== 'function') {\n      throw new TypeError(\n        '\"cryptosuite.createProofValue\" must be a function.');\n    }\n    if(createVerifyData && typeof createVerifyData !== 'function') {\n      throw new TypeError(\n        '\"cryptosuite.createVerifyData\" must be a function.');\n    }\n    this.contextUrl = DATA_INTEGRITY_CONTEXT_V2;\n    if(legacyContext) {\n      this.contextUrl = DATA_INTEGRITY_CONTEXT_V1;\n    }\n    this.canonize = canonize;\n    this.createVerifier = createVerifier;\n    this.cryptosuite = name;\n    // save internal reference to cryptosuite instance\n    this._cryptosuite = cryptosuite;\n    this.requiredAlgorithm = requiredAlgorithm;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    } else if(date === null) {\n      this.date = null;\n    }\n\n    const vm = _processSignatureParams({signer, requiredAlgorithm});\n    this.verificationMethod = vm.verificationMethod;\n    this.signer = vm.signer;\n  }\n\n  /**\n   * Adds a signature (proofValue) field to the proof object. Called by\n   * LinkedDataSignature.createProof().\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array|object} options.verifyData - Data to be signed\n   *   (extracted from document, according to the suite's spec).\n   * @param {object} options.proof - Proof object (containing the proofPurpose,\n   *   verificationMethod, etc).\n   *\n   * @returns {Promise<object>} Resolves with the proof containing the signature\n   *   value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n\n    const signatureBytes = await this.signer.sign({data: verifyData});\n    proof.proofValue =\n      MULTIBASE_BASE58BTC_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(signatureBytes);\n\n    return proof;\n  }\n\n  /**\n   * Verifies the proof signature against the given data.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array|object} options.verifyData - Verify data as produced\n   *   from `createVerifyData`.\n   * @param {object} options.verificationMethod - Key object.\n   * @param {object} options.proof - The proof to be verified.\n   *\n   * @returns {Promise<boolean>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    const verifier = await this.createVerifier({verificationMethod});\n    const isSupportedAlgorithm = Array.isArray(this.requiredAlgorithm) ?\n      this.requiredAlgorithm.includes(verifier.algorithm) :\n      this.requiredAlgorithm === verifier.algorithm;\n\n    if(!isSupportedAlgorithm) {\n      const supportedAlgorithms = Array.isArray(this.requiredAlgorithm) ?\n        this.requiredAlgorithm.join(', ') : this.requiredAlgorithm;\n      const messageSuffix = Array.isArray(this.requiredAlgorithm) ?\n        `is not a supported algorithm for the cryptosuite. The supported ` +\n        `algorithms are: \"${supportedAlgorithms}\".` :\n        `does not match the required algorithm for the cryptosuite ` +\n        `\"${supportedAlgorithms}\".`;\n      const message = `The verifier's algorithm \"${verifier.algorithm}\" ` +\n        `${messageSuffix}`;\n      throw new Error(message);\n    }\n\n    const {proofValue} = proof;\n    if(!(proofValue && typeof proofValue === 'string')) {\n      throw new TypeError(\n        'The proof does not include a valid \"proofValue\" property.');\n    }\n    const multibaseHeader = proofValue[0];\n    let signature;\n    if(multibaseHeader === MULTIBASE_BASE58BTC_HEADER) {\n      signature = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(proofValue.slice(1));\n    } else if(multibaseHeader === MULTIBASE_BASE64URL_HEADER) {\n      signature = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(proofValue.slice(1));\n    } else {\n      throw new Error(\n        'Only base58btc or base64url multibase encoding is supported.');\n    }\n    return verifier.verify({data: verifyData, signature});\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to create a proof for.\n   * @param {object} options.purpose - The `ProofPurpose` instance to use.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {Function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({document, purpose, proofSet, documentLoader}) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = _util_js__WEBPACK_IMPORTED_MODULE_2__.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n    proof.verificationMethod = this.verificationMethod;\n    proof.cryptosuite = this.cryptosuite;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document, proof, purpose, proofSet, documentLoader\n    });\n\n    // allow purpose to update the proof; any terms added to `proof` must have\n    // be compatible with its context\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader});\n\n    // create data to sign\n    let verifyData;\n    // use custom cryptosuite `createVerifyData` if available\n    if(this._cryptosuite.createVerifyData) {\n      verifyData = await this._cryptosuite.createVerifyData({\n        cryptosuite: this._cryptosuite,\n        document, proof, proofSet, documentLoader,\n        dataIntegrityProof: this\n      });\n    } else {\n      verifyData = await this.createVerifyData(\n        {document, proof, proofSet, documentLoader});\n    }\n\n    // use custom `createProofValue` if available\n    if(this._cryptosuite.createProofValue) {\n      proof.proofValue = await this._cryptosuite.createProofValue({\n        cryptosuite: this._cryptosuite,\n        verifyData, document, proof, proofSet,\n        documentLoader, dataIntegrityProof: this\n      });\n    } else {\n      // default to simple signing of data\n      proof = await this.sign(\n        {verifyData, document, proof, proofSet, documentLoader});\n    }\n\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to derive from.\n   * @param {object} options.purpose - The `ProofPurpose` instance to use.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {Function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the new document with a new\n   *   `proof` field.\n   */\n  async derive({document, purpose, proofSet, documentLoader}) {\n    // delegate entirely to cryptosuite instance\n    if(!this._cryptosuite.derive) {\n      throw new Error('\"cryptosuite.derive\" not provided.');\n    }\n    return this._cryptosuite.derive({\n      cryptosuite: this._cryptosuite, document, purpose, proofSet,\n      documentLoader, dataIntegrityProof: this\n    });\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to update.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to verify.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {object} options.document - The document to create a proof for.\n   * @param {Function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, proofSet, document, documentLoader}) {\n    try {\n      // create data to verify\n      let verifyData;\n      // use custom cryptosuite `createVerifyData` if available\n      if(this._cryptosuite.createVerifyData) {\n        verifyData = await this._cryptosuite.createVerifyData({\n          cryptosuite: this._cryptosuite,\n          document, proof, proofSet, documentLoader,\n          dataIntegrityProof: this\n        });\n      } else {\n        verifyData = await this.createVerifyData(\n          {document, proof, proofSet, documentLoader});\n      }\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod({\n        proof, documentLoader\n      });\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, proof\n      });\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to create verify data for.\n   * @param {object} options.proof - The proof to create verify data for.\n   * @param {Function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<Uint8Array|object>} Resolves to the verify data to\n   *   be passed to `sign` or `verifySignature`.\n   */\n  async createVerifyData({document, proof, documentLoader}) {\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader})\n            .then(c14nDocument => (0,_sha256digest_js__WEBPACK_IMPORTED_MODULE_4__.sha256digest)({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(proof, {document, documentLoader})\n        .then(c14nProofOptions => (0,_sha256digest_js__WEBPACK_IMPORTED_MODULE_4__.sha256digest)({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n    // concatenate hash of c14n proof options and hash of c14n document\n    return _util_js__WEBPACK_IMPORTED_MODULE_2__.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof for which to get the\n   *   verification method.\n   * @param {Function} options.documentLoader - The document loader to use.\n   *\n   * @returns {object} - The verificationMethod.\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    const result = await documentLoader(verificationMethod);\n    if(!result) {\n      throw new Error(\n        `Unable to load verification method \"${verificationMethod}\".`);\n    }\n\n    const {document} = result;\n    verificationMethod = typeof document === 'string' ?\n      JSON.parse(document) : document;\n    return verificationMethod;\n  }\n\n  async canonizeProof(proof, {documentLoader, document}) {\n    // `proofValue` must not be included in the proof options\n    proof = {\n      '@context': document['@context'],\n      ...proof\n    };\n    this.ensureSuiteContext({document: proof, addSuiteContext: true});\n    delete proof.proofValue;\n    return this.canonize(proof, {documentLoader, skipExpansion: false});\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to match.\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    const {type, cryptosuite} = proof;\n    return type === this.type && cryptosuite === this.cryptosuite;\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl}) ||\n      _includesContext({document, contextUrl: VC_2_0_CONTEXT})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n          `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n}\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @param {object} options - The options to use.\n * @param {object} options.signer - The signer to use.\n * @param {Array|string} options.requiredAlgorithm - The required algorithm.\n * @returns {{verificationMethod: string\n *   signer: {sign: Function, id: string, algorithm: string}}}} - Validated and\n *   initialized signature-related parameters.\n */\nfunction _processSignatureParams({signer, requiredAlgorithm}) {\n  const vm = {\n    verificationMethod: undefined,\n    signer: undefined\n  };\n\n  if(!signer) {\n    return vm;\n  }\n\n  if(typeof signer.sign !== 'function') {\n    throw new TypeError('A signer API has not been specified.');\n  }\n  const isSupportedAlgorithm = Array.isArray(requiredAlgorithm) ?\n    requiredAlgorithm.includes(signer.algorithm) :\n    requiredAlgorithm === signer.algorithm;\n\n  if(!isSupportedAlgorithm) {\n    const supportedAlgorithms = Array.isArray(requiredAlgorithm) ?\n      requiredAlgorithm.join(', ') : requiredAlgorithm;\n    const messageSuffix = Array.isArray(requiredAlgorithm) ?\n      `is not a supported algorithm for the cryptosuite. The supported ` +\n      `algorithms are: \"${supportedAlgorithms}\".` :\n      `does not match the required algorithm for the cryptosuite ` +\n      `\"${supportedAlgorithms}\".`;\n    const message = `The signer's algorithm \"${signer.algorithm}\" ` +\n      `${messageSuffix}`;\n    throw new Error(message);\n  }\n\n  vm.signer = signer;\n  vm.verificationMethod = signer.id;\n\n  return vm;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/data-integrity/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@digitalbazaar/data-integrity/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DataIntegrityProof: () => (/* reexport safe */ _DataIntegrityProof_js__WEBPACK_IMPORTED_MODULE_0__.DataIntegrityProof)\n/* harmony export */ });\n/* harmony import */ var _DataIntegrityProof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataIntegrityProof.js */ \"./node_modules/@digitalbazaar/data-integrity/lib/DataIntegrityProof.js\");\n/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/data-integrity/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/data-integrity/lib/sha256digest-browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/data-integrity/lib/sha256digest-browser.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256digest: () => (/* binding */ sha256digest)\n/* harmony export */ });\n/*\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n/* eslint-env browser */\nconst crypto = self && (self.crypto || self.msCrypto);\n\n/**\n * Hashes a string of data using SHA-256.\n *\n * @param {string} string - The string to hash.\n *\n * @returns {Uint8Array} The hash digest.\n */\nasync function sha256digest({string}) {\n  const bytes = new TextEncoder().encode(string);\n  return new Uint8Array(await crypto.subtle.digest('SHA-256', bytes));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/data-integrity/lib/sha256digest-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/data-integrity/lib/util.js":
/*!****************************************************************!*\
  !*** ./node_modules/@digitalbazaar/data-integrity/lib/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   w3cDate: () => (/* binding */ w3cDate)\n/* harmony export */ });\n\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * Converts the given date into W3C datetime format (eg: 2011-03-09T21:55:41Z).\n *\n * @param {Date|number|string} date - The date to convert.\n *\n * @returns {string} The date in W3C datetime format.\n */\nconst w3cDate = date => {\n  if(date === undefined || date === null) {\n    date = new Date();\n  } else if(typeof date === 'number' || typeof date === 'string') {\n    date = new Date(date);\n  }\n  const str = date.toISOString();\n  return str.slice(0, - 5) + 'Z';\n};\n\n/**\n * Concatenates two Uint8Arrays.\n *\n * @param {Uint8Array} b1 - The first buffer to concat.\n * @param {Uint8Array} b2 - The second buffer to concat.\n *\n * @returns {Uint8Array} The result.\n */\nconst concat = (b1, b2) => {\n  const rval = new Uint8Array(b1.length + b2.length);\n  rval.set(b1, 0);\n  rval.set(b2, b1.length);\n  return rval;\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/data-integrity/lib/util.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalize: () => (/* binding */ canonicalize),\n/* harmony export */   canonizeProof: () => (/* binding */ canonizeProof),\n/* harmony export */   createHmacIdLabelMapFunction: () => (/* binding */ createHmacIdLabelMapFunction),\n/* harmony export */   createLabelMapFunction: () => (/* binding */ createLabelMapFunction),\n/* harmony export */   hashCanonizedProof: () => (/* binding */ hashCanonizedProof),\n/* harmony export */   labelReplacementCanonicalizeJsonLd: () => (/* binding */ labelReplacementCanonicalizeJsonLd),\n/* harmony export */   labelReplacementCanonicalizeNQuads: () => (/* binding */ labelReplacementCanonicalizeNQuads),\n/* harmony export */   relabelBlankNodes: () => (/* binding */ relabelBlankNodes),\n/* harmony export */   stripBlankNodePrefixes: () => (/* binding */ stripBlankNodePrefixes)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hash.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js\");\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\nasync function labelReplacementCanonicalizeJsonLd({\n  document, labelMapFactoryFunction, options\n} = {}) {\n  const {nquads} = await _labelReplacementCanonicalizeNQuads(\n    {document, labelMapFactoryFunction, options});\n  return nquads;\n}\n\nasync function labelReplacementCanonicalizeNQuads({\n  nquads, labelMapFactoryFunction, options\n} = {}) {\n  return _labelReplacementCanonicalizeNQuads(\n    {nquads, labelMapFactoryFunction, options});\n}\n\nfunction relabelBlankNodes({nquads, labelMap} = {}) {\n  const replacer = (m, s1, label) => '_:' + labelMap.get(label);\n  return nquads.map(e => e.replace(/(_:([^\\s]+))/g, replacer));\n}\n\nfunction createHmacIdLabelMapFunction({hmac} = {}) {\n  return async ({canonicalIdMap}) => {\n    const bnodeIdMap = new Map();\n    for(const [input, c14nLabel] of canonicalIdMap) {\n      const utf8Bytes = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.stringToUtf8Bytes)(c14nLabel);\n      const hashed = await hmac.sign(utf8Bytes);\n      // multibase prefix of `u` is important to make bnode ID syntax-legal\n      // see: https://www.w3.org/TR/n-quads/#BNodes\n      bnodeIdMap.set(input, `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(hashed)}`);\n    }\n    return bnodeIdMap;\n  };\n}\n\nfunction createLabelMapFunction({labelMap} = {}) {\n  return async ({canonicalIdMap}) => {\n    const bnodeIdMap = new Map();\n    for(const [input, c14nLabel] of canonicalIdMap) {\n      bnodeIdMap.set(input, labelMap.get(c14nLabel));\n    }\n    return bnodeIdMap;\n  };\n}\n\nasync function canonicalize(input, options) {\n  if(!(options && typeof options === 'object')) {\n    throw new TypeError('\"options\" must be an object.');\n  }\n  return jsonld__WEBPACK_IMPORTED_MODULE_2__.canonize(input, {\n    algorithm: 'URDNA2015',\n    format: 'application/n-quads',\n    safe: true,\n    ...options\n  });\n}\n\nasync function canonizeProof({document, proof, options} = {}) {\n  proof = {\n    '@context': document['@context'],\n    ...proof\n  };\n  delete proof.proofValue;\n  return canonicalize(proof, options);\n}\n\nasync function hashCanonizedProof({\n  document, proof, options, hasher\n} = {}) {\n  if(!hasher) {\n    // create default `hasher` if not specified\n    hasher = (0,_hash_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)();\n  }\n  const canonized = await canonizeProof({document, proof, options});\n  return hasher.hash((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.stringToUtf8Bytes)(canonized));\n}\n\n// utility function for use with implementations do not do strip `_:` prefixes\nfunction stripBlankNodePrefixes(map) {\n  let checked = false;\n  const stripped = new Map();\n  for(const [key, value] of map) {\n    if(!checked) {\n      checked = true;\n      if(!key.startsWith('_:')) {\n        // map doesn't use prefixes, return it\n        return map;\n      }\n    }\n    stripped.set(key.slice(2), value.slice(2));\n  }\n  return stripped;\n}\n\nasync function _labelReplacementCanonicalizeNQuads({\n  document, nquads, labelMapFactoryFunction, options\n} = {}) {\n  let canonicalIdMap = new Map();\n  let canonicalNQuads;\n  if(document) {\n    canonicalNQuads = await canonicalize(\n      document, {...options, canonicalIdMap});\n  } else {\n    canonicalNQuads = await canonicalize(\n      nquads.join(''),\n      {...options, inputFormat: 'application/n-quads', canonicalIdMap});\n  }\n\n  // ensure labels in map do not include `_:` prefix\n  canonicalIdMap = stripBlankNodePrefixes(canonicalIdMap);\n\n  // create label map\n  const labelMap = await labelMapFactoryFunction({canonicalIdMap});\n\n  /* Note: In this current implementation, the replacement label map is\n  replaced with one that maps the C14N labels to the new labels instead of\n  the input labels to the new labels. This is because the C14N labels are\n  already in use in the N-Quads that are updated. */\n  const c14nToNewLabelMap = new Map();\n  for(const [input, newLabel] of labelMap) {\n    c14nToNewLabelMap.set(canonicalIdMap.get(input), newLabel);\n  }\n  const replacer = (m, s1, label) => '_:' + c14nToNewLabelMap.get(label);\n\n  // FIXME: see if `relabelBlankNodes` can be reused\n  const outputNQuads = canonicalNQuads.split('\\n').slice(0, -1)\n    .map(e => e.replace(/(_:([^\\s]+))/g, replacer) + '\\n')\n    // FIXME: sort should be by unicode code point, not utf-16 code unit\n    .sort();\n\n  return {nquads: outputNQuads, labelMap};\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/group.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/group.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalizeAndGroup: () => (/* binding */ canonicalizeAndGroup)\n/* harmony export */ });\n/* harmony import */ var _skolemize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./skolemize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js\");\n/* harmony import */ var _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canonicalize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js\");\n/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./select.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/select.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\nasync function canonicalizeAndGroup({\n  document, labelMapFactoryFunction, groups, options\n} = {}) {\n  // 1. Skolemize JSON-LD `document`.\n  const skolemized = await (0,_skolemize_js__WEBPACK_IMPORTED_MODULE_0__.skolemizeCompactJsonLd)({document, options});\n\n  // 2. Get deskolemized N-Quads for the whole document.\n  const deskolemizedNQuads = await (0,_skolemize_js__WEBPACK_IMPORTED_MODULE_0__.toDeskolemizedNQuads)(\n    {document: skolemized.expanded, options});\n\n  // 3. Get canonicalized N-Quads and label map to convert deskolemized\n  //   N-Quads to canonical N-Quads.\n  const {labelMap, nquads} = await (0,_canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.labelReplacementCanonicalizeNQuads)({\n    nquads: deskolemizedNQuads, labelMapFactoryFunction, options\n  });\n\n  // 4. In parallel, produce each selection of canonical N-Quads using the\n  //   JSON pointers from each named group.\n  const selections = new Map();\n  const entries = [...Object.entries(groups)];\n  await Promise.all(entries.map(async ([name, pointers]) => {\n    selections.set(name, await (0,_select_js__WEBPACK_IMPORTED_MODULE_2__.selectCanonicalNQuads)(\n      {document: skolemized.compact, pointers, labelMap, options}));\n  }));\n\n  // 5. Group matching and non-matching N-Quads for each selection.\n  const results = {};\n  for(const [name, selectionResult] of selections) {\n    const matching = new Map();\n    const nonMatching = new Map();\n    const {nquads: selectedNQuads, deskolemizedNQuads} = selectionResult;\n    nquads.forEach((nq, index) => selectedNQuads.includes(nq) ?\n      matching.set(index, nq) : nonMatching.set(index, nq));\n    results[name] = {matching, nonMatching, deskolemizedNQuads};\n  }\n\n  // 6. Return group results, skolem data, label map, and canonical N-Quads.\n  return {groups: results, skolemized, deskolemizedNQuads, labelMap, nquads};\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/group.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher)\n/* harmony export */ });\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/platform-browser.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Creates a one-shot hasher interface.\n *\n * @param {object} options - The options to use.\n * @param {string} options.algorithm - The key algorithm, e.g., 'sha256'.\n *\n * @returns {object} The hasher interface.\n */\nfunction createHasher({algorithm = 'sha256'} = {}) {\n  if(algorithm !== 'sha256') {\n    throw new Error(`Unsupported algorithm \"${algorithm}\".`);\n  }\n\n  return {\n    async hash(bytes) {\n      return new Uint8Array(await _platform_js__WEBPACK_IMPORTED_MODULE_0__.crypto.subtle.digest('SHA-256', bytes));\n    }\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringToUtf8Bytes: () => (/* binding */ stringToUtf8Bytes)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst TEXT_ENCODER = new TextEncoder();\n\nfunction stringToUtf8Bytes(str) {\n  return TEXT_ENCODER.encode(str);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/hmac-browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/hmac-browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHmac: () => (/* binding */ createHmac)\n/* harmony export */ });\n/* harmony import */ var _platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./platform.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/platform-browser.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Creates a one-shot hmac interface from a raw or new HMAC key.\n *\n * @param {object} options - The options to use.\n * @param {string} options.algorithm - The key algorithm, e.g., 'HS256'.\n * @param {Uint8Array} options.key - The key or `null` to generate one.\n *\n * @returns {object} The hmac interface.\n */\nasync function createHmac({algorithm = 'HS256', key} = {}) {\n  if(algorithm !== 'HS256') {\n    throw new Error(`Unsupported algorithm \"${algorithm}\".`);\n  }\n  if(!(key === null || key instanceof Uint8Array)) {\n    throw new TypeError('\"key\" must be null or a Uint8Array.');\n  }\n\n  if(key === null) {\n    // generate 32-byte key\n    key = await _platform_js__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(32));\n  }\n\n  // import key as a CryptoKey\n  const extractable = true;\n  key = await _platform_js__WEBPACK_IMPORTED_MODULE_0__.crypto.subtle.importKey(\n    'raw', key, {name: 'HMAC', hash: {name: 'SHA-256'}}, extractable,\n    ['sign', 'verify']);\n\n  return {\n    async export() {\n      return new Uint8Array(\n        await _platform_js__WEBPACK_IMPORTED_MODULE_0__.crypto.subtle.exportKey('raw', key));\n    },\n    async sign(bytes) {\n      return new Uint8Array(\n        await _platform_js__WEBPACK_IMPORTED_MODULE_0__.crypto.subtle.sign(key.algorithm, key, bytes));\n    }\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/hmac-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonicalize: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.canonicalize),\n/* harmony export */   canonicalizeAndGroup: () => (/* reexport safe */ _group_js__WEBPACK_IMPORTED_MODULE_2__.canonicalizeAndGroup),\n/* harmony export */   canonizeProof: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.canonizeProof),\n/* harmony export */   createHasher: () => (/* reexport safe */ _hash_js__WEBPACK_IMPORTED_MODULE_3__.createHasher),\n/* harmony export */   createHmac: () => (/* reexport safe */ _hmac_js__WEBPACK_IMPORTED_MODULE_4__.createHmac),\n/* harmony export */   createHmacIdLabelMapFunction: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.createHmacIdLabelMapFunction),\n/* harmony export */   createLabelMapFunction: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.createLabelMapFunction),\n/* harmony export */   deskolemizeNQuads: () => (/* reexport safe */ _skolemize_js__WEBPACK_IMPORTED_MODULE_0__.deskolemizeNQuads),\n/* harmony export */   hashCanonizedProof: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.hashCanonizedProof),\n/* harmony export */   hashMandatory: () => (/* reexport safe */ _mandatory_js__WEBPACK_IMPORTED_MODULE_5__.hashMandatory),\n/* harmony export */   labelReplacementCanonicalizeJsonLd: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.labelReplacementCanonicalizeJsonLd),\n/* harmony export */   labelReplacementCanonicalizeNQuads: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.labelReplacementCanonicalizeNQuads),\n/* harmony export */   parsePointer: () => (/* reexport safe */ _pointer_js__WEBPACK_IMPORTED_MODULE_7__.parsePointer),\n/* harmony export */   relabelBlankNodes: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.relabelBlankNodes),\n/* harmony export */   selectCanonicalNQuads: () => (/* reexport safe */ _select_js__WEBPACK_IMPORTED_MODULE_6__.selectCanonicalNQuads),\n/* harmony export */   selectJsonLd: () => (/* reexport safe */ _select_js__WEBPACK_IMPORTED_MODULE_6__.selectJsonLd),\n/* harmony export */   skolemizeCompactJsonLd: () => (/* reexport safe */ _skolemize_js__WEBPACK_IMPORTED_MODULE_0__.skolemizeCompactJsonLd),\n/* harmony export */   skolemizeExpandedJsonLd: () => (/* reexport safe */ _skolemize_js__WEBPACK_IMPORTED_MODULE_0__.skolemizeExpandedJsonLd),\n/* harmony export */   skolemizeNQuads: () => (/* reexport safe */ _skolemize_js__WEBPACK_IMPORTED_MODULE_0__.skolemizeNQuads),\n/* harmony export */   stringToUtf8Bytes: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_8__.stringToUtf8Bytes),\n/* harmony export */   stripBlankNodePrefixes: () => (/* reexport safe */ _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__.stripBlankNodePrefixes),\n/* harmony export */   toDeskolemizedNQuads: () => (/* reexport safe */ _skolemize_js__WEBPACK_IMPORTED_MODULE_0__.toDeskolemizedNQuads)\n/* harmony export */ });\n/* harmony import */ var _skolemize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./skolemize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js\");\n/* harmony import */ var _canonicalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canonicalize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/group.js\");\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hash.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/hmac-browser.js\");\n/* harmony import */ var _mandatory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mandatory.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/mandatory.js\");\n/* harmony import */ var _select_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./select.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/select.js\");\n/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pointer.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/pointer.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/mandatory.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/mandatory.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashMandatory: () => (/* binding */ hashMandatory)\n/* harmony export */ });\n/* harmony import */ var _hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hash.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/hash-browser.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/helpers.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\nasync function hashMandatory({mandatory, hasher} = {}) {\n  if(!hasher) {\n    // create default `hasher` if not specified\n    hasher = (0,_hash_js__WEBPACK_IMPORTED_MODULE_0__.createHasher)();\n  }\n\n  // 1. Hash mandatory N-Quads in order to produce `mandatoryHash`.\n  const mandatoryHash = await hasher.hash(\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.stringToUtf8Bytes)(mandatory.join('')));\n  return {mandatoryHash};\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/mandatory.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/platform-browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/platform-browser.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n// WebCrypto\nconst crypto = globalThis.crypto;\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/platform-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/pointer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/pointer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePointer: () => (/* binding */ parsePointer)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n// JSON pointer escape sequences\n// ~0 => '~'\n// ~1 => '/'\nconst POINTER_ESCAPE_REGEX = /~[01]/g;\n\nfunction parsePointer(pointer) {\n  // see RFC 6901: https://www.rfc-editor.org/rfc/rfc6901.html\n  const parsed = [];\n  const paths = pointer.split('/').slice(1);\n  for(const path of paths) {\n    if(!path.includes('~')) {\n      // convert any numerical path to a number as an array index\n      const index = parseInt(path, 10);\n      parsed.push(isNaN(index) ? path : index);\n    } else {\n      parsed.push(path.replace(POINTER_ESCAPE_REGEX, _unescapePointerPath));\n    }\n  }\n  return parsed;\n}\n\nfunction _unescapePointerPath(m) {\n  if(m === '~1') {\n    return '/';\n  }\n  if(m === '~0') {\n    return '~';\n  }\n  throw new Error(`Invalid JSON pointer escape sequence \"${m}\".`);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/pointer.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/select.js":
/*!********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/select.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   selectCanonicalNQuads: () => (/* binding */ selectCanonicalNQuads),\n/* harmony export */   selectJsonLd: () => (/* binding */ selectJsonLd)\n/* harmony export */ });\n/* harmony import */ var klona__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! klona */ \"./node_modules/klona/dist/index.mjs\");\n/* harmony import */ var _pointer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pointer.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/pointer.js\");\n/* harmony import */ var _canonicalize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canonicalize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/canonicalize.js\");\n/* harmony import */ var _skolemize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./skolemize.js */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\nfunction selectJsonLd({document, pointers, includeTypes = true} = {}) {\n  if(!(document && typeof document === 'object')) {\n    throw new TypeError('\"document\" must be an object.');\n  }\n  if(!Array.isArray(pointers)) {\n    throw new TypeError('\"pointers\" must be an array.');\n  }\n  if(pointers.length === 0) {\n    // no pointers, so no frame\n    return null;\n  }\n\n  // track arrays to make them dense after selection\n  const arrays = [];\n\n  // perform selection\n  const selectionDocument = {'@context': (0,klona__WEBPACK_IMPORTED_MODULE_0__.klona)(document['@context'])};\n  _initSelection(\n    {selection: selectionDocument, source: document, includeTypes});\n  for(const pointer of pointers) {\n    // parse pointer into individual paths\n    const paths = (0,_pointer_js__WEBPACK_IMPORTED_MODULE_1__.parsePointer)(pointer);\n    if(paths.length === 0) {\n      // whole document selected\n      return (0,klona__WEBPACK_IMPORTED_MODULE_0__.klona)(document);\n    }\n    _selectPaths({\n      document, pointer, paths, selectionDocument, arrays, includeTypes\n    });\n  }\n\n  // make any sparse arrays dense\n  for(const array of arrays) {\n    let i = 0;\n    while(i < array.length) {\n      if(array[i] === undefined) {\n        array.splice(i, 1);\n        continue;\n      }\n      i++;\n    }\n  }\n\n  return selectionDocument;\n}\n\nasync function selectCanonicalNQuads({\n  document, pointers, labelMap, options\n} = {}) {\n  // 1. Perform selection on compact, skolemized JSON-LD using JSON pointers.\n  const selection = selectJsonLd({document, pointers});\n\n  // 2. Get deskolemized N-Quads for the selection.\n  const deskolemizedNQuads = await (0,_skolemize_js__WEBPACK_IMPORTED_MODULE_3__.toDeskolemizedNQuads)(\n    {document: selection, options});\n\n  // 3. Relabel blank nodes with canonical labels using the label map.\n  const nquads = (0,_canonicalize_js__WEBPACK_IMPORTED_MODULE_2__.relabelBlankNodes)({nquads: deskolemizedNQuads, labelMap});\n\n  // 4. Return selected canonical N-Quads.\n  return {selection, deskolemizedNQuads, nquads};\n}\n\nfunction _selectPaths({\n  document, pointer, paths, selectionDocument, arrays, includeTypes\n} = {}) {\n  // make pointer path in selection document\n  let parentValue = document;\n  let value = parentValue;\n  let selectedParent = selectionDocument;\n  let selectedValue = selectedParent;\n  for(const path of paths) {\n    selectedParent = selectedValue;\n    parentValue = value;\n\n    // get next document value\n    value = parentValue[path];\n    if(value === undefined) {\n      throw new TypeError(\n        `JSON pointer \"${pointer}\" does not match document.`);\n    }\n\n    // get next value selection\n    selectedValue = selectedParent[path];\n    if(selectedValue === undefined) {\n      if(Array.isArray(value)) {\n        selectedValue = [];\n        arrays.push(selectedValue);\n      } else {\n        selectedValue = _initSelection({source: value, includeTypes});\n      }\n      selectedParent[path] = selectedValue;\n    }\n  }\n\n  // path traversal complete, compute selected value\n  if(typeof value !== 'object') {\n    // literal selected\n    selectedValue = value;\n  } else if(Array.isArray(value)) {\n    // full array selected\n    selectedValue = (0,klona__WEBPACK_IMPORTED_MODULE_0__.klona)(value);\n  } else {\n    // object selected, blend with `id` / `type` / `@context`\n    selectedValue = {...selectedValue, ...(0,klona__WEBPACK_IMPORTED_MODULE_0__.klona)(value)};\n  }\n\n  // add selected value to selected parent\n  selectedParent[paths.at(-1)] = selectedValue;\n}\n\nfunction _initSelection({selection = {}, source, includeTypes}) {\n  // must include non-blank node IDs\n  if(source.id && !source.id.startsWith('_:')) {\n    selection.id = source.id;\n  }\n  // include types if directed to do so\n  if(includeTypes && source.type) {\n    selection.type = source.type;\n  }\n  return selection;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/select.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deskolemizeNQuads: () => (/* binding */ deskolemizeNQuads),\n/* harmony export */   skolemizeCompactJsonLd: () => (/* binding */ skolemizeCompactJsonLd),\n/* harmony export */   skolemizeExpandedJsonLd: () => (/* binding */ skolemizeExpandedJsonLd),\n/* harmony export */   skolemizeNQuads: () => (/* binding */ skolemizeNQuads),\n/* harmony export */   toDeskolemizedNQuads: () => (/* binding */ toDeskolemizedNQuads)\n/* harmony export */ });\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/* harmony import */ var klona__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! klona */ \"./node_modules/klona/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n// FIXME: consider accepting optional skolem `prefix` to use instead of\n// `urn:bnid` to help avoid paranoid clashes\nfunction deskolemizeNQuads({nquads} = {}) {\n  const mutated = [];\n  for(const nq of nquads) {\n    if(!nq.includes('<urn:bnid:')) {\n      mutated.push(nq);\n    } else {\n      mutated.push(nq.replace(/(<urn:bnid:([^>]+)>)/g, '_:$2'));\n    }\n  }\n  return mutated;\n}\n\n// FIXME: consider accepting optional skolem `prefix` to use instead of\n// `urn:bnid` to help avoid paranoid clashes\nfunction skolemizeNQuads({nquads} = {}) {\n  // FIXME:\n  // replacer = (m, s1, s2) => `<{$prefix}${s2}>`;\n\n  const mutated = [];\n  for(const nq of nquads) {\n    if(!nq.includes('_:')) {\n      mutated.push(nq);\n    } else {\n      mutated.push(nq.replace(/(_:([^\\s]+))/g, '<urn:bnid:$2>'));\n    }\n  }\n  return mutated;\n}\n\n// FIXME: consider accepting optional skolem `prefix` to use instead of\n// `urn:bnid` to help avoid paranoid clashes\nasync function skolemizeCompactJsonLd({document, options} = {}) {\n  if(!(typeof document === 'object' && document?.['@context'])) {\n    throw new TypeError(\n      '\"document\" must be an object representing a compact JSON-LD document ' +\n      'with an \"@context\".');\n  }\n\n  // 1. Expand `document`.\n  const expanded = await jsonld__WEBPACK_IMPORTED_MODULE_0__.expand(document, {safe: true, ...options});\n\n  // 2. Skolemize expanded document.\n  const skolemized = {expanded: null, compact: null};\n  skolemized.expanded = skolemizeExpandedJsonLd({expanded, options});\n\n  // 3. Generate skolemized compact document.\n  skolemized.compact = await jsonld__WEBPACK_IMPORTED_MODULE_0__.compact(\n    skolemized.expanded, document['@context'], {safe: true, ...options});\n\n  // 4. Return expanded and compact skolemized forms of `document`.\n  return skolemized;\n}\n\n// FIXME: consider accepting optional skolem `prefix` to use instead of\n// `urn:bnid` to help avoid paranoid clashes\nfunction skolemizeExpandedJsonLd({\n  expanded, labeler = {prefix: `urn:bnid:`, random: (0,uuid__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), count: 0}\n} = {}) {\n  const skolemized = [];\n  for(const element of expanded) {\n    // copy literals directly\n    if(typeof element !== 'object' || element?.['@value'] !== undefined) {\n      skolemized.push((0,klona__WEBPACK_IMPORTED_MODULE_1__.klona)(element));\n      continue;\n    }\n\n    // non-literal, must recurse...\n    const skolemizedNode = {};\n    for(const property in element) {\n      const value = element[property];\n      skolemizedNode[property] = Array.isArray(value) ?\n        skolemizeExpandedJsonLd({expanded: value, labeler}) :\n        skolemizeExpandedJsonLd({expanded: [value], labeler})[0];\n    }\n\n    // skolemize node\n    if(skolemizedNode['@id'] === undefined) {\n      // generate randomized skolem ID\n      skolemizedNode['@id'] =\n        `${labeler.prefix}_${labeler.random}_${labeler.count++}`;\n    } else if(skolemizedNode['@id'].startsWith('_:')) {\n      // preserve existing bnode identifier in skolem ID; it may be shared\n      skolemizedNode['@id'] =\n        `${labeler.prefix}${skolemizedNode['@id'].slice(2)}`;\n    }\n\n    skolemized.push(skolemizedNode);\n  }\n\n  return skolemized;\n}\n\nasync function toDeskolemizedNQuads({document, options} = {}) {\n  // 1. Convert skolemized doc to RDF to produce skolemized N-Quads.\n  const rdfOptions = {safe: true, ...options, format: 'application/n-quads'};\n  const rdf = await jsonld__WEBPACK_IMPORTED_MODULE_0__.toRDF(document, rdfOptions);\n\n  // 2. Split N-Quads into arrays for deskolemization.\n  const skolemized = rdf.split('\\n').slice(0, -1).map(nq => nq + '\\n');\n\n  // 3. Return deskolemize N-Quads.\n  return deskolemizeNQuads({nquads: skolemized});\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/di-sd-primitives/lib/skolemize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALGORITHM: () => (/* binding */ ALGORITHM),\n/* harmony export */   ECDSA_2019_SECP_256_KEY_TYPE: () => (/* binding */ ECDSA_2019_SECP_256_KEY_TYPE),\n/* harmony export */   ECDSA_2019_SECP_384_KEY_TYPE: () => (/* binding */ ECDSA_2019_SECP_384_KEY_TYPE),\n/* harmony export */   ECDSA_2019_SECP_521_KEY_TYPE: () => (/* binding */ ECDSA_2019_SECP_521_KEY_TYPE),\n/* harmony export */   ECDSA_2019_SUITE_CONTEXT_V1_URL: () => (/* binding */ ECDSA_2019_SUITE_CONTEXT_V1_URL),\n/* harmony export */   ECDSA_CURVE: () => (/* binding */ ECDSA_CURVE),\n/* harmony export */   ECDSA_HASH: () => (/* binding */ ECDSA_HASH),\n/* harmony export */   EXTRACTABLE: () => (/* binding */ EXTRACTABLE),\n/* harmony export */   MULTIBASE_BASE58_HEADER: () => (/* binding */ MULTIBASE_BASE58_HEADER),\n/* harmony export */   MULTICODEC_P256_PUBLIC_KEY_HEADER: () => (/* binding */ MULTICODEC_P256_PUBLIC_KEY_HEADER),\n/* harmony export */   MULTICODEC_P256_SECRET_KEY_HEADER: () => (/* binding */ MULTICODEC_P256_SECRET_KEY_HEADER),\n/* harmony export */   MULTICODEC_P384_PUBLIC_KEY_HEADER: () => (/* binding */ MULTICODEC_P384_PUBLIC_KEY_HEADER),\n/* harmony export */   MULTICODEC_P384_SECRET_KEY_HEADER: () => (/* binding */ MULTICODEC_P384_SECRET_KEY_HEADER),\n/* harmony export */   MULTICODEC_P521_PUBLIC_KEY_HEADER: () => (/* binding */ MULTICODEC_P521_PUBLIC_KEY_HEADER),\n/* harmony export */   MULTICODEC_P521_SECRET_KEY_HEADER: () => (/* binding */ MULTICODEC_P521_SECRET_KEY_HEADER),\n/* harmony export */   MULTIKEY_CONTEXT_V1_URL: () => (/* binding */ MULTIKEY_CONTEXT_V1_URL)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n// Name of algorithm\nconst ALGORITHM = 'ECDSA';\n// Determines whether key pair is extractable\nconst EXTRACTABLE = true;\n// ECDSA curve P-256 type\nconst ECDSA_2019_SECP_256_KEY_TYPE = 'EcdsaSecp256r1VerificationKey2019';\n// ECDSA curve P-384 type\nconst ECDSA_2019_SECP_384_KEY_TYPE = 'EcdsaSecp384r1VerificationKey2019';\n// ECDSA curve P-521 type\nconst ECDSA_2019_SECP_521_KEY_TYPE = 'EcdsaSecp521r1VerificationKey2019';\n// ECDSA 2019 suite context v1 URL\nconst ECDSA_2019_SUITE_CONTEXT_V1_URL =\n  'https://w3id.org/security/suites/ecdsa-2019/v1';\n// Multikey context v1 URL\nconst MULTIKEY_CONTEXT_V1_URL = 'https://w3id.org/security/multikey/v1';\nconst MULTIBASE_BASE58_HEADER = 'z';\n\n// Multicodec p256-pub header (0x1200 varint -> 0x8024 hex)\nconst MULTICODEC_P256_PUBLIC_KEY_HEADER = new Uint8Array([0x80, 0x24]);\n// Multicodec p384-pub header (0x1201 varint -> 0x8124 hex)\nconst MULTICODEC_P384_PUBLIC_KEY_HEADER = new Uint8Array([0x81, 0x24]);\n// Multicodec p521-pub header (0x1202 varint -> 0x8224 hex)\nconst MULTICODEC_P521_PUBLIC_KEY_HEADER = new Uint8Array([0x82, 0x24]);\n\n// Multicodec p256-priv header (0x1306 varint -> 0x8626 hex)\nconst MULTICODEC_P256_SECRET_KEY_HEADER = new Uint8Array([0x86, 0x26]);\n// Multicodec p384-priv header (0x1307 varint -> 0x8726 hex)\nconst MULTICODEC_P384_SECRET_KEY_HEADER = new Uint8Array([0x87, 0x26]);\n// Multicodec p521-priv header (0x1308 varint -> 0x8826 hex)\nconst MULTICODEC_P521_SECRET_KEY_HEADER = new Uint8Array([0x88, 0x26]);\n\n// ECDSA curves\nconst ECDSA_CURVE = {\n  P256: 'P-256',\n  P384: 'P-384',\n  P521: 'P-521'\n};\n\n// ECDSA hash functions\nconst ECDSA_HASH = {\n  SHA256: 'SHA-256',\n  SHA384: 'SHA-384',\n  SHA512: 'SHA-512'\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CryptoKey: () => (/* binding */ CryptoKey),\n/* harmony export */   webcrypto: () => (/* binding */ webcrypto)\n/* harmony export */ });\n/*!\n * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.\n */\n// eslint-disable-next-line no-undef\nconst webcrypto = globalThis.crypto;\n// eslint-disable-next-line no-undef\nconst CryptoKey = globalThis.CryptoKey ?? webcrypto.CryptoKey;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/factory.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/factory.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSigner: () => (/* binding */ createSigner),\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js\");\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js\");\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n// exposes sign method\nfunction createSigner({id, secretKey}) {\n  if(!secretKey) {\n    throw new Error('\"secretKey\" is required for signing.');\n  }\n  const {namedCurve: curve} = secretKey.algorithm;\n  const algorithm = {name: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ALGORITHM, hash: {name: _getEcdsaHash({curve})}};\n  return {\n    algorithm: curve,\n    id,\n    async sign({data} = {}) {\n      return new Uint8Array(await _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.sign(\n        algorithm, secretKey, data));\n    }\n  };\n}\n\n// exposes verify method\nfunction createVerifier({id, publicKey}) {\n  if(!publicKey) {\n    throw new Error('\"publicKey\" is required for verifying.');\n  }\n  const {namedCurve: curve} = publicKey.algorithm;\n  const algorithm = {name: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ALGORITHM, hash: {name: _getEcdsaHash({curve})}};\n  return {\n    algorithm: curve,\n    id,\n    async verify({data, signature} = {}) {\n      return _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.verify(algorithm, publicKey, signature, data);\n    }\n  };\n}\n\n// retrieves name of appropriate ECDSA hash function\nfunction _getEcdsaHash({curve}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_HASH.SHA256;\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_HASH.SHA384;\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_HASH.SHA512;\n  }\n  throw new TypeError(`Unsupported curve \"${curve}\".`);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/factory.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNamedCurveFromPublicMultikey: () => (/* binding */ getNamedCurveFromPublicMultikey),\n/* harmony export */   getNamedCurveFromSecretMultikey: () => (/* binding */ getNamedCurveFromSecretMultikey),\n/* harmony export */   getSecretKeySize: () => (/* binding */ getSecretKeySize),\n/* harmony export */   setPublicKeyHeader: () => (/* binding */ setPublicKeyHeader),\n/* harmony export */   setSecretKeyHeader: () => (/* binding */ setSecretKeyHeader)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js\");\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// retrieves name of appropriate ECDSA curve from public Multikey\nfunction getNamedCurveFromPublicMultikey({publicMultikey}) {\n  if(publicMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_PUBLIC_KEY_HEADER[0] &&\n    publicMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_PUBLIC_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256;\n  }\n  if(publicMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_PUBLIC_KEY_HEADER[0] &&\n    publicMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_PUBLIC_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384;\n  }\n  if(publicMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_PUBLIC_KEY_HEADER[0] &&\n    publicMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_PUBLIC_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521;\n  }\n  // FIXME; also support P-256K/secp256k1\n  throw new TypeError('Unsupported public multikey header.');\n}\n\n// retrieves name of appropriate ECDSA curve from secret Multikey\nfunction getNamedCurveFromSecretMultikey({secretMultikey}) {\n  if(secretMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_SECRET_KEY_HEADER[0] &&\n    secretMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_SECRET_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256;\n  }\n  if(secretMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_SECRET_KEY_HEADER[0] &&\n    secretMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_SECRET_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384;\n  }\n  if(secretMultikey[0] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_SECRET_KEY_HEADER[0] &&\n    secretMultikey[1] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_SECRET_KEY_HEADER[1]) {\n    return _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521;\n  }\n  // FIXME; also support P-256K/secp256k1\n  throw new TypeError('Unsupported secret multikey header.');\n}\n\n// retrieves byte size of secret key\nfunction getSecretKeySize({curve}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256) {\n    return 32;\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384) {\n    return 48;\n  }\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521) {\n    return 66;\n  }\n  throw new TypeError(`Unsupported curve \"${curve}\".`);\n}\n\n// sets secret key header bytes on key pair\nfunction setSecretKeyHeader({curve, buffer}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_SECRET_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_SECRET_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_SECRET_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_SECRET_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_SECRET_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_SECRET_KEY_HEADER[1];\n  } else {\n    throw new TypeError(`Unsupported curve \"${curve}\".`);\n  }\n}\n\n// sets public key header bytes on key pair\nfunction setPublicKeyHeader({curve, buffer}) {\n  if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P256) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_PUBLIC_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P256_PUBLIC_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P384) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_PUBLIC_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P384_PUBLIC_KEY_HEADER[1];\n  } else if(curve === _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE.P521) {\n    buffer[0] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_PUBLIC_KEY_HEADER[0];\n    buffer[1] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTICODEC_P521_PUBLIC_KEY_HEADER[1];\n  } else {\n    throw new TypeError(`Unsupported curve \"${curve}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromJwk: () => (/* binding */ fromJwk),\n/* harmony export */   fromRaw: () => (/* binding */ fromRaw),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   toJwk: () => (/* binding */ toJwk)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js\");\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factory.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/factory.js\");\n/* harmony import */ var _serialize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serialize.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/serialize.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/helpers.js\");\n/* harmony import */ var _translators_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./translators.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/translators.js\");\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\n// FIXME: support `P-256K` via `@noble/secp256k1`\n// generates ECDSA key pair\nasync function generate({\n  id, controller, curve, keyAgreement = false\n} = {}) {\n  if(!curve) {\n    throw new TypeError(\n      '\"curve\" must be one of the following values: ' +\n      `${Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_CURVE).map(v => `'${v}'`).join(', ')}.`);\n  }\n  const algorithm = keyAgreement ?\n    {name: 'ECDH', namedCurve: curve} : {name: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ALGORITHM, namedCurve: curve};\n  const usage = keyAgreement ? ['deriveBits'] : ['sign', 'verify'];\n  const keyPair = await _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.generateKey(\n    algorithm, _constants_js__WEBPACK_IMPORTED_MODULE_0__.EXTRACTABLE, usage);\n  keyPair.secretKey = keyPair.privateKey;\n  delete keyPair.privateKey;\n  const keyPairInterface = await _createKeyPairInterface(\n    {keyPair, keyAgreement});\n  const exportedKeyPair = await keyPairInterface.export({publicKey: true});\n  const {publicKeyMultibase} = exportedKeyPair;\n  if(controller && !id) {\n    id = `${controller}#${publicKeyMultibase}`;\n  }\n  keyPairInterface.id = id;\n  keyPairInterface.controller = controller;\n  return keyPairInterface;\n}\n\n// imports P-256 key pair from JSON Multikey\nasync function from(key, options = {}) {\n  // backwards compatibility\n  if(typeof options === 'boolean') {\n    options = {keyAgreement: options};\n  }\n  const {keyAgreement} = options;\n\n  let multikey = {...key};\n  if(multikey.type !== 'Multikey') {\n    // attempt loading from JWK if `publicKeyJwk` is present\n    if(multikey.publicKeyJwk) {\n      return fromJwk({jwk: multikey.publicKeyJwk, secretKey: false});\n    }\n    if(multikey.type) {\n      multikey = await (0,_translators_js__WEBPACK_IMPORTED_MODULE_5__.toMultikey)({keyPair: multikey});\n      return _createKeyPairInterface({keyPair: multikey, keyAgreement});\n    }\n  }\n  if(!multikey.type) {\n    multikey.type = 'Multikey';\n  }\n  if(!multikey['@context']) {\n    multikey['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL;\n  }\n  if(multikey.controller && !multikey.id) {\n    multikey.id = `${key.controller}#${key.publicKeyMultibase}`;\n  }\n\n  _assertMultikey(multikey);\n  return _createKeyPairInterface({keyPair: multikey, keyAgreement});\n}\n\n// imports key pair from JWK\nasync function fromJwk({jwk, secretKey = false} = {}) {\n  const multikey = {\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL,\n    type: 'Multikey',\n    publicKeyMultibase: (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.toPublicKeyMultibase)({jwk})\n  };\n  if(secretKey && jwk.d) {\n    multikey.secretKeyMultibase = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.toSecretKeyMultibase)({jwk});\n  }\n  const keyAgreement = !jwk.key_ops || jwk.key_ops.includes('deriveBits');\n  return from(multikey, keyAgreement);\n}\n\n// converts key pair to JWK\nasync function toJwk({keyPair, secretKey = false} = {}) {\n  if(!(keyPair?.publicKey instanceof _crypto_js__WEBPACK_IMPORTED_MODULE_1__.CryptoKey)) {\n    keyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.importKeyPair)(keyPair);\n  }\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n  const cryptoKey = useSecretKey ? keyPair.secretKey : keyPair.publicKey;\n  const jwk = await _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.exportKey('jwk', cryptoKey);\n  return jwk;\n}\n\n// raw import from secretKey and publicKey bytes\nasync function fromRaw({\n  curve, secretKey, publicKey, keyAgreement = false\n} = {}) {\n  if(typeof curve !== 'string') {\n    throw new TypeError('\"curve\" must be a string.');\n  }\n  if(secretKey && !(secretKey instanceof Uint8Array)) {\n    throw new TypeError('\"secretKey\" must be a Uint8Array.');\n  }\n  if(!(publicKey instanceof Uint8Array)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array.');\n  }\n  const cryptoKey = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.cryptoKeyfromRaw)(\n    {curve, secretKey, publicKey, keyAgreement});\n  const jwk = await _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.exportKey('jwk', cryptoKey);\n  return fromJwk({jwk, secretKey: !!secretKey, keyAgreement});\n}\n\n// augments key pair with useful metadata and utilities\nasync function _createKeyPairInterface({keyPair, keyAgreement = false}) {\n  if(!(keyPair?.publicKey instanceof _crypto_js__WEBPACK_IMPORTED_MODULE_1__.CryptoKey)) {\n    keyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.importKeyPair)(keyPair);\n  }\n  const exportFn = async ({\n    publicKey = true, secretKey = false, includeContext = true, raw = false\n  } = {}) => {\n    if(raw) {\n      const jwk = await toJwk({keyPair, secretKey});\n      const result = {};\n      if(publicKey) {\n        result.publicKey = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.toPublicKeyBytes)({jwk});\n      }\n      if(secretKey) {\n        result.secretKey = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.toSecretKeyBytes)({jwk});\n      }\n      return result;\n    }\n    return (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.exportKeyPair)({keyPair, publicKey, secretKey, includeContext});\n  };\n  const {publicKeyMultibase, secretKeyMultibase} = await exportFn({\n    publicKey: true, secretKey: true, includeContext: true\n  });\n  keyPair = {\n    ...keyPair,\n    publicKeyMultibase,\n    secretKeyMultibase,\n    keyAgreement,\n    export: exportFn,\n    signer() {\n      const {id, secretKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_2__.createSigner)({id, secretKey});\n    },\n    verifier() {\n      const {id, publicKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_2__.createVerifier)({id, publicKey});\n    },\n    // pass `publicKey`, as `remotePublicKey` is just a backwards compatible\n    // alias\n    async deriveSecret({publicKey, remotePublicKey} = {}) {\n      if(remotePublicKey && publicKey) {\n        throw new Error(\n          'Only one of \"remotePublicKey\" and \"publicKey\" must be given.');\n      }\n      if(!keyPair.keyAgreement) {\n        const error = Error('\"keyAgreement\" is not supported by this keypair.');\n        error.name = 'NotSupportedError';\n        throw error;\n      }\n      return _deriveSecret(\n        {localKeyPair: this, remoteKeyPair: remotePublicKey || publicKey});\n    }\n  };\n\n  return keyPair;\n}\n\n// checks if key pair is in Multikey format\nfunction _assertMultikey(key) {\n  if(!(key && typeof key === 'object')) {\n    throw new TypeError('\"key\" must be an object.');\n  }\n  if(key.type !== 'Multikey') {\n    throw new TypeError('\"key\" must be a Multikey with type \"Multikey\".');\n  }\n  if(!(key['@context'] === _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL ||\n    (Array.isArray(key['@context']) &&\n    key['@context'].includes(_constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL)))) {\n    throw new TypeError(\n      '\"key\" must be a Multikey with context ' +\n      `\"${_constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL}\".`);\n  }\n}\n\nasync function _deriveSecret({localKeyPair, remoteKeyPair}) {\n  if(!localKeyPair.secretKey) {\n    const error = Error('\"secretKey\" required to derive secret.');\n    error.name = 'NotSupportedError';\n    throw error;\n  }\n\n  // import keys with `keyAgreement` key usage\n  localKeyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.importKeyPair)({...localKeyPair, keyAgreement: true});\n  remoteKeyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.importKeyPair)({...remoteKeyPair, keyAgreement: true});\n\n  // produce shared secret that is the same size as a secret key, the\n  // shared secret should be used as just one input to a KDF\n  const {namedCurve: curve} = localKeyPair.secretKey.algorithm;\n  const secretSize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  const arrayBuffer = await _crypto_js__WEBPACK_IMPORTED_MODULE_1__.webcrypto.subtle.deriveBits({\n    name: 'ECDH',\n    namedCurve: curve,\n    public: remoteKeyPair.publicKey,\n  }, localKeyPair.secretKey, secretSize * 8);\n  return new Uint8Array(arrayBuffer, 0, secretSize);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/serialize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/serialize.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _rawToPkcs8: () => (/* binding */ _rawToPkcs8),\n/* harmony export */   cryptoKeyfromRaw: () => (/* binding */ cryptoKeyfromRaw),\n/* harmony export */   exportKeyPair: () => (/* binding */ exportKeyPair),\n/* harmony export */   importKeyPair: () => (/* binding */ importKeyPair),\n/* harmony export */   toPublicKeyBytes: () => (/* binding */ toPublicKeyBytes),\n/* harmony export */   toPublicKeyMultibase: () => (/* binding */ toPublicKeyMultibase),\n/* harmony export */   toSecretKeyBytes: () => (/* binding */ toSecretKeyBytes),\n/* harmony export */   toSecretKeyMultibase: () => (/* binding */ toSecretKeyMultibase)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js\");\n/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./crypto.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/crypto-browser.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/helpers.js\");\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n// FIXME: may need to move any leading zeros for bitstring compression; needs\n// testing with various browsers\nconst PKCS8_PREFIXES = new Map([\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P256, {\n    secret: new Uint8Array([\n      48, 103, 2, 1, 0, 48, 19, 6, 7, 42, 134, 72,\n      206, 61, 2, 1, 6, 8, 42, 134, 72, 206, 61, 3,\n      1, 7, 4, 77, 48, 75, 2, 1, 1, 4, 32\n    ]),\n    public: new Uint8Array([161, 36, 3, 34, 0])\n  }],\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P384, {\n    secret: new Uint8Array([\n      48, 129, 132, 2, 1, 0, 48, 16, 6, 7, 42, 134,\n      72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 34,\n      4, 109, 48, 107, 2, 1, 1, 4, 48\n    ]),\n    public: new Uint8Array([161, 52, 3, 50, 0])\n  }],\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P521, {\n    secret: new Uint8Array([\n      48, 129, 170, 2, 1, 0, 48, 16, 6, 7, 42, 134,\n      72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 35,\n      4, 129, 146, 48, 129, 143, 2, 1, 1, 4, 66\n    ]),\n    public: new Uint8Array([161, 70, 3, 68, 0])\n  }]\n]);\n\nconst SPKI_PREFIXES = new Map([\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P256, new Uint8Array([\n    48, 57, 48, 19, 6, 7, 42, 134, 72, 206,\n    61, 2, 1, 6, 8, 42, 134, 72, 206, 61,\n    3, 1, 7, 3, 34, 0\n  ])],\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P384, new Uint8Array([\n    48, 70, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2,\n    1, 6, 5, 43, 129, 4, 0, 34, 3, 50, 0\n  ])],\n  [_constants_js__WEBPACK_IMPORTED_MODULE_2__.ECDSA_CURVE.P521, new Uint8Array([\n    48, 88, 48, 16, 6, 7, 42, 134, 72, 206, 61, 2,\n    1, 6, 5, 43, 129, 4, 0, 35, 3, 68, 0\n  ])]\n]);\n\n// converts key pair to PKCS #8 format\nasync function cryptoKeyfromRaw({\n  curve, secretKey, publicKey, keyAgreement\n} = {}) {\n  const algorithm = {\n    name: keyAgreement ? 'ECDH' : _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHM,\n    namedCurve: curve\n  };\n\n  let cryptoKey;\n  if(secretKey) {\n    const pkcs8 = _rawToPkcs8({curve, secretKey, publicKey});\n    const secretUsage = keyAgreement ? ['deriveBits'] : ['sign'];\n    cryptoKey = await _crypto_js__WEBPACK_IMPORTED_MODULE_3__.webcrypto.subtle.importKey(\n      'pkcs8', pkcs8, algorithm, _constants_js__WEBPACK_IMPORTED_MODULE_2__.EXTRACTABLE, secretUsage);\n  } else {\n    const spki = _rawToSpki({curve, publicKey});\n    // must be empty usage for importing a public key\n    const publicUsage = keyAgreement ? [] : ['verify'];\n    cryptoKey = await _crypto_js__WEBPACK_IMPORTED_MODULE_3__.webcrypto.subtle.importKey(\n      'spki', spki, algorithm, _constants_js__WEBPACK_IMPORTED_MODULE_2__.EXTRACTABLE, publicUsage);\n  }\n  return cryptoKey;\n}\n\n// exports key pair\nasync function exportKeyPair({\n  keyPair, secretKey, publicKey, includeContext\n} = {}) {\n  if(!(publicKey || secretKey)) {\n    throw new TypeError(\n      'Export requires specifying either \"publicKey\" or \"secretKey\".');\n  }\n\n  // get JWK\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n  const cryptoKey = useSecretKey ? keyPair.secretKey : keyPair.publicKey;\n  const jwk = await _crypto_js__WEBPACK_IMPORTED_MODULE_3__.webcrypto.subtle.exportKey('jwk', cryptoKey);\n\n  // export as Multikey\n  const exported = {};\n  if(includeContext) {\n    exported['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL;\n  }\n  exported.id = keyPair.id;\n  exported.type = 'Multikey';\n  exported.controller = keyPair.controller;\n\n  if(publicKey) {\n    exported.publicKeyMultibase = toPublicKeyMultibase({jwk});\n  }\n\n  if(useSecretKey) {\n    exported.secretKeyMultibase = toSecretKeyMultibase({jwk});\n  }\n\n  return exported;\n}\n\n// imports key pair\nasync function importKeyPair({\n  id, controller, secretKeyMultibase, publicKeyMultibase, keyAgreement = false\n}) {\n  if(!publicKeyMultibase) {\n    throw new TypeError('The \"publicKeyMultibase\" property is required.');\n  }\n\n  const keyPair = {id, controller};\n\n  // import public key\n  if(!(publicKeyMultibase && typeof publicKeyMultibase === 'string' &&\n    publicKeyMultibase[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIBASE_BASE58_HEADER)) {\n    throw new TypeError(\n      '\"publicKeyMultibase\" must be a multibase, base58-encoded string.');\n  }\n  const publicMultikey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(publicKeyMultibase.slice(1));\n\n  // set named curved based on multikey header\n  const algorithm = {\n    name: keyAgreement ? 'ECDH' : _constants_js__WEBPACK_IMPORTED_MODULE_2__.ALGORITHM,\n    namedCurve: (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromPublicMultikey)({publicMultikey})\n  };\n\n  // import public key; convert to `spki` format because `jwk` doesn't handle\n  // compressed public keys\n  const spki = _multikeyToSpki({publicMultikey});\n  // must be empty usage for importing a public key\n  const publicUsage = keyAgreement ? [] : ['verify'];\n  keyPair.publicKey = await _crypto_js__WEBPACK_IMPORTED_MODULE_3__.webcrypto.subtle.importKey(\n    'spki', spki, algorithm, _constants_js__WEBPACK_IMPORTED_MODULE_2__.EXTRACTABLE, publicUsage);\n\n  // import secret key if given\n  if(secretKeyMultibase) {\n    if(!(typeof secretKeyMultibase === 'string' &&\n    secretKeyMultibase[0] === _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIBASE_BASE58_HEADER)) {\n      throw new TypeError(\n        '\"secretKeyMultibase\" must be a multibase, base58-encoded string.');\n    }\n    const secretMultikey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(secretKeyMultibase.slice(1));\n\n    // ensure secret key multikey header appropriately matches the\n    // public key multikey header\n    _ensureMultikeyHeadersMatch({secretMultikey, publicMultikey});\n\n    // convert to `pkcs8` format for import because `jwk` doesn't support\n    // compressed keys\n    const pkcs8 = _multikeyToPkcs8({secretMultikey, publicMultikey});\n    const secretUsage = keyAgreement ? ['deriveBits'] : ['sign'];\n    keyPair.secretKey = await _crypto_js__WEBPACK_IMPORTED_MODULE_3__.webcrypto.subtle.importKey(\n      'pkcs8', pkcs8, algorithm, _constants_js__WEBPACK_IMPORTED_MODULE_2__.EXTRACTABLE, secretUsage);\n  }\n\n  return keyPair;\n}\n\nfunction toPublicKeyBytes({jwk} = {}) {\n  if(jwk?.kty !== 'EC') {\n    throw new TypeError('\"jwk.kty\" must be \"EC\".');\n  }\n  const {crv: curve} = jwk;\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  // convert `x` coordinate to compressed public key\n  const x = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.x);\n  const y = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.y);\n  // public key size is always secret key size + 1\n  const publicKeySize = secretKeySize + 1;\n  const publicKey = new Uint8Array(publicKeySize);\n  // use even / odd status of `y` coordinate for compressed header\n  const even = y[y.length - 1] % 2 === 0;\n  publicKey[0] = even ? 2 : 3;\n  // write `x` coordinate at end of multikey buffer to zero-fill it\n  publicKey.set(x, publicKey.length - x.length);\n  return publicKey;\n}\n\nfunction toPublicKeyMultibase({jwk} = {}) {\n  if(jwk?.kty !== 'EC') {\n    throw new TypeError('\"jwk.kty\" must be \"EC\".');\n  }\n  const {crv: curve} = jwk;\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  // convert `x` coordinate to compressed public key\n  const x = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.x);\n  const y = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.y);\n  // public key size is always secret key size + 1\n  const publicKeySize = secretKeySize + 1;\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + publicKeySize);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setPublicKeyHeader)({curve, buffer: multikey});\n  // use even / odd status of `y` coordinate for compressed header\n  const even = y[y.length - 1] % 2 === 0;\n  multikey[2] = even ? 2 : 3;\n  // write `x` coordinate at end of multikey buffer to zero-fill it\n  multikey.set(x, multikey.length - x.length);\n  const publicKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return publicKeyMultibase;\n}\n\nfunction toSecretKeyBytes({jwk} = {}) {\n  if(jwk?.kty !== 'EC') {\n    throw new TypeError('\"jwk.kty\" must be \"EC\".');\n  }\n  const {crv: curve} = jwk;\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  const d = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.d);\n  const secretKey = new Uint8Array(secretKeySize);\n  // write `d` at end of multikey buffer to zero-fill it\n  secretKey.set(d, secretKey.length - d.length);\n  return secretKey;\n}\n\nfunction toSecretKeyMultibase({jwk} = {}) {\n  if(jwk?.kty !== 'EC') {\n    throw new TypeError('\"jwk.kty\" must be \"EC\".');\n  }\n  const {crv: curve} = jwk;\n  const secretKeySize = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getSecretKeySize)({curve});\n  const d = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(jwk.d);\n  // leave room for multicodec header (2 bytes)\n  const multikey = new Uint8Array(2 + secretKeySize);\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.setSecretKeyHeader)({curve: jwk.crv, buffer: multikey});\n  // write `d` at end of multikey buffer to zero-fill it\n  multikey.set(d, multikey.length - d.length);\n  const secretKeyMultibase = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIBASE_BASE58_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(multikey);\n  return secretKeyMultibase;\n}\n\n// ensures that public key header matches secret key header\nfunction _ensureMultikeyHeadersMatch({secretMultikey, publicMultikey}) {\n  const publicCurve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromPublicMultikey)({publicMultikey});\n  const secretCurve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromSecretMultikey)({secretMultikey});\n  if(publicCurve !== secretCurve) {\n    throw new Error(\n      `Public key curve ('${publicCurve}') does not match ` +\n      `secret key curve ('${secretCurve}').`);\n  }\n}\n\n// converts key pair to PKCS #8 format\nfunction _multikeyToPkcs8({secretMultikey, publicMultikey}) {\n  const curve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromSecretMultikey)({secretMultikey});\n  // omit multikey headers\n  const secretKey = secretMultikey.subarray(2);\n  const publicKey = publicMultikey.subarray(2);\n  return _rawToPkcs8({curve, secretKey, publicKey});\n}\n\nfunction _multikeyToSpki({publicMultikey}) {\n  const curve = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_4__.getNamedCurveFromPublicMultikey)({publicMultikey});\n  // omit multikey header\n  const publicKey = publicMultikey.subarray(2);\n  return _rawToSpki({curve, publicKey});\n}\n\n// converts key pair to PKCS #8 format\nfunction _rawToPkcs8({curve, secretKey, publicKey}) {\n  /* Format:\n  SEQUENCE (3 elem)\n    INTEGER 0\n    SEQUENCE (2 elem)\n      OBJECT IDENTIFIER 1.2.840.10045.2.1 ecPublicKey\n      // curve-specific, e.g. P-256:\n      OBJECT IDENTIFIER 1.2.840.10045.3.1.7 prime256v1\n    OCTET STRING\n      SEQUENCE (3 elem)\n        INTEGER 1\n        OCTET STRING (32 byte) (RAW SECRET KEY BYTES)\n        [1] (1 elem)\n          BIT STRING (COMPRESSED/UNCOMPRESSED PUBLIC KEY BYTES)\n\n  This translates to:\n\n  PKCS #8 DER SECRET KEY HEADER (w/algorithm OID for specific key type)\n  RAW SECRET KEY BYTES\n  PKCS #8 DER PUBLIC KEY HEADER\n  COMPRESSED / UNCOMPRESSED PUBLIC KEY BYTES */\n  const headers = PKCS8_PREFIXES.get(curve);\n  if(!headers) {\n    throw new Error(`Unsupported curve \"${curve}\".`);\n  }\n  const pkcs8 = new Uint8Array(\n    headers.secret.length + secretKey.length +\n    headers.public.length + publicKey.length);\n  let offset = 0;\n  pkcs8.set(headers.secret, offset);\n  offset += headers.secret.length;\n  pkcs8.set(secretKey, offset);\n  offset += secretKey.length;\n  pkcs8.set(headers.public, offset);\n  offset += headers.public.length;\n  pkcs8.set(publicKey, offset);\n  return pkcs8;\n}\n\n// converts public key to SubjectPublicKeyInfo format\nfunction _rawToSpki({curve, publicKey}) {\n  /* Format:\n  SPKI DER PUBLIC KEY HEADER (w/algorithm OID for specific key type)\n  COMPRESSED / UNCOMPRESSED PUBLIC KEY BYTES */\n  const header = SPKI_PREFIXES.get(curve);\n  const spki = new Uint8Array(header.length + publicKey.length);\n  let offset = 0;\n  spki.set(header, offset);\n  offset += header.length;\n  spki.set(publicKey, offset);\n  return spki;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/serialize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-multikey/lib/translators.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-multikey/lib/translators.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toMultikey: () => (/* binding */ toMultikey)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/constants.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// valid ECDSA types\nconst VALID_ECDSA_TYPES = new Set([\n  _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_2019_SECP_256_KEY_TYPE,\n  _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_2019_SECP_384_KEY_TYPE,\n  _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_2019_SECP_521_KEY_TYPE\n]);\n\n// converts key pair to Multikey format\nasync function toMultikey({keyPair}) {\n  if(!VALID_ECDSA_TYPES.has(keyPair.type)) {\n    throw new TypeError(`Unsupported key type \"${keyPair.type}\".`);\n  }\n\n  if(!keyPair['@context']) {\n    keyPair['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_2019_SUITE_CONTEXT_V1_URL;\n  }\n  if(!_includesContext({\n    document: keyPair,\n    contextUrl: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA_2019_SUITE_CONTEXT_V1_URL\n  })) {\n    throw new TypeError(`Context not supported \"${keyPair['@context']}\".`);\n  }\n\n  return {\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_0__.MULTIKEY_CONTEXT_V1_URL,\n    id: keyPair.id,\n    type: 'Multikey',\n    controller: keyPair.controller,\n    publicKeyMultibase: keyPair.publicKeyMultibase,\n    secretKeyMultibase: keyPair.secretKeyMultibase\n  };\n}\n\n// checks if context was properly included in document\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-multikey/lib/translators.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/canonize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/canonize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonize: () => (/* binding */ canonize)\n/* harmony export */ });\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nasync function canonize(input, options) {\n  return jsonld__WEBPACK_IMPORTED_MODULE_0__.canonize(input, {\n    algorithm: 'URDNA2015',\n    format: 'application/n-quads',\n    ...options\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/canonize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/createVerifier.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/createVerifier.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/ecdsa-multikey */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nasync function createVerifier({verificationMethod}) {\n  const key = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_0__.from(verificationMethod);\n  const verifier = key.verifier();\n  return verifier;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/createVerifier.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cryptosuite: () => (/* binding */ cryptosuite)\n/* harmony export */ });\n/* harmony import */ var _canonize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canonize.js */ \"./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/canonize.js\");\n/* harmony import */ var _createVerifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createVerifier.js */ \"./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/createVerifier.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n*/\n\n\n\n\n\nconst cryptosuite = {\n  canonize: _canonize_js__WEBPACK_IMPORTED_MODULE_0__.canonize,\n  createVerifier: _createVerifier_js__WEBPACK_IMPORTED_MODULE_1__.createVerifier,\n  name: _name_js__WEBPACK_IMPORTED_MODULE_2__.name,\n  requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__.requiredAlgorithm,\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/name.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/name.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst name = 'ecdsa-rdfc-2019';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/name.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/requiredAlgorithm.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/requiredAlgorithm.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requiredAlgorithm: () => (/* binding */ requiredAlgorithm)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst requiredAlgorithm = ['P-256', 'P-384'];\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-rdfc-2019-cryptosuite/lib/requiredAlgorithm.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/disclose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/disclose.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDiscloseCryptosuite: () => (/* binding */ createDiscloseCryptosuite)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\nfunction createDiscloseCryptosuite({\n  proofId, selectivePointers = []\n} = {}) {\n  const options = {proofId, selectivePointers};\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_2__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__.requiredAlgorithm,\n    createVerifier: _throwDeriveUsageError,\n    createVerifyData: _throwDeriveUsageError,\n    createProofValue: _throwDeriveUsageError,\n    derive: _derive,\n    options\n  };\n}\n\nasync function _createDisclosureData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_2__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_2__.name}\".`);\n  }\n  if(!(cryptosuite.options && typeof cryptosuite.options === 'object')) {\n    throw new TypeError(`\"cryptosuite.options\" must be an object.`);\n  }\n\n  // 1. Parse base `proof` to get parameters for disclosure proof.\n  const {\n    baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n  } = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_1__.parseBaseProofValue)({proof});\n\n  // 2. Ensure mandatory and / or selective data will be disclosed.\n  const {selectivePointers = []} = cryptosuite.options;\n  if(!(mandatoryPointers?.length > 0 || selectivePointers?.length > 0)) {\n    throw new Error('Nothing selected for disclosure.');\n  }\n\n  // 3. Create HMAC label replacement function from `hmacKey` to randomize\n  //   bnode identifiers.\n  const hmac = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.createHmac)({key: hmacKey});\n  const labelMapFactoryFunction = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.createHmacIdLabelMapFunction)({hmac});\n\n  // 4. Canonicalize document with randomized bnode labels and group N-Quads\n  //  by mandatory, selective, and combined pointers.\n  const options = {documentLoader};\n  const combinedPointers = mandatoryPointers.concat(selectivePointers);\n  const {\n    groups: {\n      mandatory: mandatoryGroup,\n      selective: selectiveGroup,\n      combined: combinedGroup,\n    },\n    labelMap\n  } = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.canonicalizeAndGroup)({\n    document,\n    labelMapFactoryFunction,\n    groups: {\n      mandatory: mandatoryPointers,\n      selective: selectivePointers,\n      combined: combinedPointers\n    },\n    options\n  });\n\n  // 5. Converting absolute indexes of mandatory N-Quads to relative indexes in\n  // the combined output to be revealed.\n  let relativeIndex = 0;\n  const mandatoryIndexes = [];\n  for(const absoluteIndex of combinedGroup.matching.keys()) {\n    if(mandatoryGroup.matching.has(absoluteIndex)) {\n      mandatoryIndexes.push(relativeIndex);\n    }\n    relativeIndex++;\n  }\n\n  // 6. Filter signatures from `baseProof` to those matching non-mandatory\n  //   absolute indexes and shifting by any absolute mandatory indexes that\n  //   occur before each entry.\n  let index = 0;\n  const filteredSignatures = signatures.filter(() => {\n    while(mandatoryGroup.matching.has(index)) {\n      index++;\n    }\n    return selectiveGroup.matching.has(index++);\n  });\n\n  // 7. Produce reveal document using combination of mandatory and selective\n  //   pointers.\n  const revealDoc = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.selectJsonLd)({document, pointers: combinedPointers});\n\n  // 8. Canonicalize deskolemized N-Quads for the combined group to generate\n  //   the canonical blank node labels a verifier will see.\n  let canonicalIdMap = new Map();\n  await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.canonicalize)(\n    combinedGroup.deskolemizedNQuads.join(''),\n    {...options, inputFormat: 'application/n-quads', canonicalIdMap});\n  // implementation-specific bnode prefix fix\n  canonicalIdMap = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_0__.stripBlankNodePrefixes)(canonicalIdMap);\n\n  // 9. Produce a blank node label map from the canonical blank node labels\n  //   the verifier will see to the HMAC labels.\n  const verifierLabelMap = new Map();\n  for(const [inputLabel, verifierLabel] of canonicalIdMap) {\n    verifierLabelMap.set(verifierLabel, labelMap.get(inputLabel));\n  }\n\n  // 10. Return data used by cryptosuite to disclose.\n  return {\n    baseSignature, publicKey, signatures: filteredSignatures,\n    labelMap: verifierLabelMap, mandatoryIndexes,\n    revealDoc\n  };\n}\n\nasync function _derive({\n  cryptosuite, document, purpose, proofSet,\n  documentLoader, dataIntegrityProof\n}) {\n  // find matching base `proof` in `proofSet`\n  const {options: {proofId}} = cryptosuite;\n  const baseProof = await _findProof({proofId, proofSet, dataIntegrityProof});\n\n  // ensure `purpose` matches `baseProof`\n  if(baseProof.proofPurpose !== purpose.term) {\n    throw new Error(\n      'Base proof purpose does not match purpose for derived proof.');\n  }\n\n  // generate data for disclosure\n  const {\n    baseSignature, publicKey, signatures, labelMap, mandatoryIndexes, revealDoc\n  } = await _createDisclosureData(\n    {cryptosuite, document, proof: baseProof, documentLoader});\n\n  // create new disclosure proof\n  const newProof = {...baseProof};\n  newProof.proofValue = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_1__.serializeDisclosureProofValue)(\n    {baseSignature, publicKey, signatures, labelMap, mandatoryIndexes});\n\n  // attach proof to reveal doc w/o context\n  delete newProof['@context'];\n  revealDoc.proof = newProof;\n  return revealDoc;\n}\n\nasync function _findProof({proofId, proofSet, dataIntegrityProof}) {\n  let proof;\n  if(proofId) {\n    proof = proofSet.find(p => p.id === proofId);\n  } else {\n    // no `proofId` given, so see if a single matching proof exists\n    for(const p of proofSet) {\n      if(await dataIntegrityProof.matchProof({proof: p})) {\n        if(proof) {\n          // already matched\n          throw new Error(\n            'Multiple matching proofs; a \"proofId\" must be specified.');\n        }\n        proof = p;\n      }\n    }\n  }\n  if(!proof) {\n    throw new Error(\n      'No matching base proof found from which to derive a disclosure proof.');\n  }\n  return proof;\n}\n\nfunction _throwDeriveUsageError() {\n  throw new Error('This cryptosuite must only be used with \"derive\".');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/disclose.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDiscloseCryptosuite: () => (/* reexport safe */ _disclose_js__WEBPACK_IMPORTED_MODULE_0__.createDiscloseCryptosuite),\n/* harmony export */   createSignCryptosuite: () => (/* reexport safe */ _sign_js__WEBPACK_IMPORTED_MODULE_1__.createSignCryptosuite),\n/* harmony export */   createVerifyCryptosuite: () => (/* reexport safe */ _verify_js__WEBPACK_IMPORTED_MODULE_2__.createVerifyCryptosuite)\n/* harmony export */ });\n/* harmony import */ var _disclose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./disclose.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/disclose.js\");\n/* harmony import */ var _sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/sign.js\");\n/* harmony import */ var _verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./verify.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/verify.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n*/\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst name = 'ecdsa-sd-2023';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseBaseProofValue: () => (/* binding */ parseBaseProofValue),\n/* harmony export */   parseDisclosureProofValue: () => (/* binding */ parseDisclosureProofValue),\n/* harmony export */   serializeBaseProofValue: () => (/* binding */ serializeBaseProofValue),\n/* harmony export */   serializeBaseVerifyData: () => (/* binding */ serializeBaseVerifyData),\n/* harmony export */   serializeDisclosureProofValue: () => (/* binding */ serializeDisclosureProofValue)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var cborg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cborg */ \"./node_modules/cborg/cborg.js\");\n/*!\n * Copyright (c) 2023-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n/* CBOR proof value representation:\n0xd9 == 11011001\n110 = CBOR major type 6\n11001 = 25, 16-bit tag size (65536 possible values)\n0x5d = always the first 8-bits of an ECDSA-SD tag\n0x00 | 0x01 = last 8-bits of a ECDSA-SD tag indicating proof mode\nproof mode can be 0 = base, 1 = derived\n*/\nconst CBOR_PREFIX_BASE = new Uint8Array([0xd9, 0x5d, 0x00]);\nconst CBOR_PREFIX_DERIVED = new Uint8Array([0xd9, 0x5d, 0x01]);\n\n// CBOR decoder for implementations that use tag 64 for Uint8Array instead\n// of byte string major type 2\nconst TAGS = [];\nTAGS[64] = _decodeUint8Array;\n\nfunction parseBaseProofValue({proof} = {}) {\n  try {\n    if(typeof proof?.proofValue !== 'string') {\n      throw new TypeError('\"proof.proofValue\" must be a string.');\n    }\n    if(proof.proofValue[0] !== 'u') {\n      throw new Error('Only base64url multibase encoding is supported.');\n    }\n\n    // decode from base64url\n    const proofValue = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(proof.proofValue.slice(1));\n    if(!_startsWithBytes(proofValue, CBOR_PREFIX_BASE)) {\n      throw new TypeError('\"proof.proofValue\" must be a base proof.');\n    }\n\n    const payload = proofValue.subarray(CBOR_PREFIX_BASE.length);\n    const [\n      baseSignature,\n      publicKey,\n      hmacKey,\n      signatures,\n      mandatoryPointers\n    ] = cborg__WEBPACK_IMPORTED_MODULE_1__.decode(payload, {useMaps: true, tags: TAGS});\n\n    const params = {\n      baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n    };\n    _validateBaseProofParams(params);\n    return params;\n  } catch(e) {\n    const err = new TypeError(\n      'The proof does not include a valid \"proofValue\" property.');\n    err.cause = e;\n    throw err;\n  }\n}\n\nfunction parseDisclosureProofValue({proof} = {}) {\n  try {\n    if(typeof proof?.proofValue !== 'string') {\n      throw new TypeError('\"proof.proofValue\" must be a string.');\n    }\n    if(proof.proofValue[0] !== 'u') {\n      throw new Error('Only base64url multibase encoding is supported.');\n    }\n\n    // decode from base64url\n    const proofValue = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(proof.proofValue.slice(1));\n    if(!_startsWithBytes(proofValue, CBOR_PREFIX_DERIVED)) {\n      throw new TypeError('\"proof.proofValue\" must be a derived proof.');\n    }\n\n    const payload = proofValue.subarray(CBOR_PREFIX_DERIVED.length);\n    const [\n      baseSignature,\n      publicKey,\n      signatures,\n      compressedLabelMap,\n      mandatoryIndexes\n    ] = cborg__WEBPACK_IMPORTED_MODULE_1__.decode(payload, {useMaps: true, tags: TAGS});\n\n    const labelMap = _decompressLabelMap(compressedLabelMap);\n    const params = {\n      baseSignature, publicKey, signatures, labelMap, mandatoryIndexes\n    };\n    _validateDerivedProofParams(params);\n    return params;\n  } catch(e) {\n    const err = new TypeError(\n      'The proof does not include a valid \"proofValue\" property.');\n    err.cause = e;\n    throw err;\n  }\n}\n\nfunction serializeBaseProofValue({\n  baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n} = {}) {\n  _validateBaseProofParams({\n    baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n  });\n\n  // encode as multibase (base64url no pad) CBOR\n  const payload = [\n    // Uint8Array\n    baseSignature,\n    // Uint8Array\n    publicKey,\n    // Uint8Array\n    hmacKey,\n    // array of Uint8Arrays\n    signatures,\n    // array of strings\n    mandatoryPointers\n  ];\n  const cbor = _concatBuffers([\n    CBOR_PREFIX_BASE, cborg__WEBPACK_IMPORTED_MODULE_1__.encode(payload, {useMaps: true})\n  ]);\n  return `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(cbor)}`;\n}\n\nfunction serializeBaseVerifyData({\n  proofHash, publicKey, mandatoryHash\n} = {}) {\n  _validateBaseVerifyDataParams({proofHash, publicKey, mandatoryHash});\n\n  // concatenate, in order: `proofHash` + `publicKey` + `mandatoryHash`\n  const verifyData = _concatBuffers([proofHash, publicKey, mandatoryHash]);\n  return verifyData;\n}\n\nfunction serializeDisclosureProofValue({\n  baseSignature, publicKey, signatures, labelMap, mandatoryIndexes\n} = {}) {\n  _validateDerivedProofParams({\n    baseSignature, publicKey, signatures, labelMap, mandatoryIndexes\n  });\n\n  // encode as multibase (base64url no pad) CBOR\n  const payload = [\n    // Uint8Array\n    baseSignature,\n    // Uint8Array\n    publicKey,\n    // array of Uint8Arrays\n    signatures,\n    // Map of strings => strings compressed to ints => Uint8Arrays\n    _compressLabelMap(labelMap),\n    // array of numbers\n    mandatoryIndexes\n  ];\n  const cbor = _concatBuffers([\n    CBOR_PREFIX_DERIVED, cborg__WEBPACK_IMPORTED_MODULE_1__.encode(payload, {useMaps: true})\n  ]);\n  return `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(cbor)}`;\n}\n\nfunction _compressLabelMap(labelMap) {\n  const map = new Map();\n  for(const [k, v] of labelMap.entries()) {\n    map.set(parseInt(k.slice(4), 10), base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(v.slice(1)));\n  }\n  return map;\n}\n\nfunction _concatBuffers(buffers) {\n  const bytes = new Uint8Array(buffers.reduce((acc, b) => acc + b.length, 0));\n  let offset = 0;\n  for(const b of buffers) {\n    bytes.set(b, offset);\n    offset += b.length;\n  }\n  return bytes;\n}\n\nfunction _decompressLabelMap(compressedLabelMap) {\n  const map = new Map();\n  for(const [k, v] of compressedLabelMap.entries()) {\n    map.set(`c14n${k}`, `u${base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(v)}`);\n  }\n  return map;\n}\n\nfunction _startsWithBytes(buffer, prefix) {\n  for(let i = 0; i < prefix.length; ++i) {\n    if(buffer[i] !== prefix[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction _validateBaseProofParams({\n  baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n}) {\n  if(!(baseSignature instanceof Uint8Array && baseSignature.length === 64)) {\n    throw new TypeError('\"baseSignature\" must be a Uint8Array of length 64.');\n  }\n  if(!(publicKey instanceof Uint8Array &&\n    publicKey.length === 35)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array of length 35.');\n  }\n  if(!(hmacKey instanceof Uint8Array && hmacKey.length === 32)) {\n    throw new TypeError('\"hmacKey\" must be a Uint8Array of length 32.');\n  }\n  if(!(Array.isArray(signatures) &&\n    signatures.every(s => s instanceof Uint8Array && s.length === 64))) {\n    throw new TypeError(\n      '\"signatures\" must be an array of Uint8Arrays, each of length 64.');\n  }\n  if(!(Array.isArray(mandatoryPointers) &&\n    mandatoryPointers.every(p => typeof p === 'string'))) {\n    throw new TypeError('\"mandatoryPointers\" must be an array of strings.');\n  }\n}\n\nfunction _validateBaseVerifyDataParams({\n  proofHash, publicKey, mandatoryHash\n}) {\n  if(!(proofHash instanceof Uint8Array && proofHash.length === 32)) {\n    throw new TypeError('\"proofHash\" must be a Uint8Array of length 32.');\n  }\n  if(!(publicKey instanceof Uint8Array &&\n    publicKey.length === 35)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array of length 35.');\n  }\n  if(!(mandatoryHash instanceof Uint8Array && mandatoryHash.length === 32)) {\n    throw new TypeError('\"mandatoryHash\" must be a Uint8Array of length 32.');\n  }\n}\n\nfunction _validateDerivedProofParams({\n  baseSignature, publicKey, signatures, labelMap, mandatoryIndexes\n}) {\n  if(!(baseSignature instanceof Uint8Array && baseSignature.length === 64)) {\n    throw new TypeError('\"baseSignature\" must be a Uint8Array of length 64.');\n  }\n  if(!(publicKey instanceof Uint8Array &&\n    publicKey.length === 35)) {\n    throw new TypeError('\"publicKey\" must be a Uint8Array of length 35.');\n  }\n  if(!(Array.isArray(signatures) &&\n    signatures.every(s => s instanceof Uint8Array))) {\n    throw new TypeError('\"signatures\" must be an array of Uint8Arrays.');\n  }\n  if(!(labelMap instanceof Map &&\n    [...labelMap.entries()].every(\n      ([k, v]) => typeof k === 'string' && typeof v === 'string'))) {\n    throw new TypeError('\"labelMap\" must be a Map of strings to strings.');\n  }\n  if(!(Array.isArray(mandatoryIndexes) &&\n    mandatoryIndexes.every(Number.isInteger))) {\n    throw new TypeError('\"mandatoryIndexes\" must be an array of integers.');\n  }\n}\n\nfunction _decodeUint8Array(bytes) {\n  return bytes;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requiredAlgorithm: () => (/* binding */ requiredAlgorithm)\n/* harmony export */ });\n/*!\n * Copyright (c) 2022-2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst requiredAlgorithm = 'P-256';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/sign.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/sign.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSignCryptosuite: () => (/* binding */ createSignCryptosuite)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/ecdsa-multikey */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\nfunction createSignCryptosuite({mandatoryPointers = []} = {}) {\n  const options = {mandatoryPointers};\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_4__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.requiredAlgorithm,\n    createVerifier: _throwSignUsageError,\n    createVerifyData: _createSignData,\n    createProofValue: _createBaseProofValue,\n    options\n  };\n}\n\nasync function _createBaseProofValue({verifyData, dataIntegrityProof}) {\n  const {signer} = dataIntegrityProof;\n  const {\n    proofHash, mandatoryPointers, mandatoryHash, nonMandatory, hmacKey\n  } = verifyData;\n\n  // 1. Sign non-mandatory quads using a locally generated key.\n  const localKeyPair = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_1__.generate({curve: 'P-256'});\n  const {sign} = localKeyPair.signer();\n  const signatures = await Promise.all(nonMandatory.map(\n    nq => sign({data: (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.stringToUtf8Bytes)(nq)})));\n\n  // 2. Create data to be signed. (remove 'z' base58-multibase prefix)\n  const publicKey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(localKeyPair.publicKeyMultibase.slice(1));\n  const toSign = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_3__.serializeBaseVerifyData)(\n    {proofHash, publicKey, mandatoryHash});\n\n  // 3. Sign data.\n  const baseSignature = await signer.sign({data: toSign});\n\n  // 4. Generate `proofValue`.\n  const proofValue = (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_3__.serializeBaseProofValue)({\n    baseSignature, publicKey, hmacKey, signatures, mandatoryPointers\n  });\n  return proofValue;\n}\n\nasync function _createSignData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_4__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_4__.name}\".`);\n  }\n  if(!(cryptosuite.options && typeof cryptosuite.options === 'object')) {\n    throw new TypeError(`\"cryptosuite.options\" must be an object.`);\n  }\n  const {mandatoryPointers = []} = cryptosuite.options;\n  if(!Array.isArray(mandatoryPointers)) {\n    throw new TypeError(\n      `\"cryptosuite.options.mandatoryPointers\" must be an array.`);\n  }\n\n  // 1. Generate `proofHash` in parallel.\n  const options = {documentLoader};\n  const proofHashPromise = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashCanonizedProof)({document, proof, options})\n    .catch(e => e);\n\n  // 2. Create HMAC label replacement function to randomize bnode labels.\n  const hmac = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.createHmac)({key: null});\n  const labelMapFactoryFunction = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.createHmacIdLabelMapFunction)({hmac});\n\n  // 3. Canonicalize document with randomized bnode labels and group N-Quads\n  //  by mandatory pointers.\n  const {\n    groups: {mandatory: mandatoryGroup}\n  } = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.canonicalizeAndGroup)({\n    document,\n    labelMapFactoryFunction,\n    groups: {mandatory: mandatoryPointers},\n    options\n  });\n  const mandatory = [...mandatoryGroup.matching.values()];\n  const nonMandatory = [...mandatoryGroup.nonMatching.values()];\n\n  // 4. Hash any mandatory N-Quads.\n  const {mandatoryHash} = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashMandatory)({mandatory});\n\n  // 5. Export HMAC key.\n  const hmacKey = await hmac.export();\n\n  // 6. Return data used by cryptosuite to sign.\n  const proofHash = await proofHashPromise;\n  if(proofHash instanceof Error) {\n    throw proofHash;\n  }\n  return {proofHash, mandatoryPointers, mandatoryHash, nonMandatory, hmacKey};\n}\n\nfunction _throwSignUsageError() {\n  throw new Error('This cryptosuite must only be used with \"sign\".');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/sign.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/verify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/verify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier),\n/* harmony export */   createVerifyCryptosuite: () => (/* binding */ createVerifyCryptosuite)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/ecdsa-multikey */ \"./node_modules/@digitalbazaar/ecdsa-multikey/lib/index.js\");\n/* harmony import */ var _digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/di-sd-primitives */ \"./node_modules/@digitalbazaar/di-sd-primitives/lib/index.js\");\n/* harmony import */ var _proofValue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proofValue.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/proofValue.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\nfunction createVerifyCryptosuite() {\n  return {\n    name: _name_js__WEBPACK_IMPORTED_MODULE_4__.name,\n    requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_5__.requiredAlgorithm,\n    createVerifier,\n    createVerifyData: _createVerifyData\n  };\n}\n\nasync function createVerifier({verificationMethod}) {\n  const key = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_1__.from(verificationMethod);\n  const verifier = key.verifier();\n  return {\n    algorithm: verifier.algorithm,\n    id: verifier.id,\n    // `data` includes `signature` in this cryptosuite\n    async verify({data}) {\n      return _multiverify({verifier, data});\n    }\n  };\n}\n\nasync function _createVerifyData({\n  cryptosuite, document, proof, documentLoader\n}) {\n  if(cryptosuite?.name !== _name_js__WEBPACK_IMPORTED_MODULE_4__.name) {\n    throw new TypeError(`\"cryptosuite.name\" must be \"${_name_js__WEBPACK_IMPORTED_MODULE_4__.name}\".`);\n  }\n\n  // 1. Generate `proofHash` in parallel.\n  const options = {documentLoader};\n  const proofHashPromise = (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashCanonizedProof)({document, proof, options})\n    .catch(e => e);\n\n  // 2. Parse disclosure `proof` to get parameters to verify.\n  const {\n    baseSignature, publicKey, signatures, labelMap, mandatoryIndexes\n  } = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_3__.parseDisclosureProofValue)({proof});\n\n  // 3. Canonicalize document using label map.\n  const labelMapFactoryFunction = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.createLabelMapFunction)({labelMap});\n  const nquads = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.labelReplacementCanonicalizeJsonLd)(\n    {document, labelMapFactoryFunction, options});\n\n  // 4. Separate N-Quads into mandatory and non-mandatory.\n  const mandatory = [];\n  const nonMandatory = [];\n  for(const [index, nq] of nquads.entries()) {\n    if(mandatoryIndexes.includes(index)) {\n      mandatory.push(nq);\n    } else {\n      nonMandatory.push(nq);\n    }\n  }\n\n  // 5. Hash any mandatory N-Quads.\n  const {mandatoryHash} = await (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.hashMandatory)({mandatory});\n\n  // 6. Return data used by cryptosuite to verify.\n  const proofHash = await proofHashPromise;\n  if(proofHash instanceof Error) {\n    throw proofHash;\n  }\n  return {\n    baseSignature, proofHash, publicKey, signatures, nonMandatory,\n    mandatoryHash\n  };\n}\n\nasync function _multiverify({verifier, data} = {}) {\n  const {\n    baseSignature, proofHash, publicKey, signatures,\n    nonMandatory, mandatoryHash\n  } = data;\n\n  // 1. Import `publicKey`.\n  const publicKeyMultibase = 'z' + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(publicKey);\n  const localKeyPair = await _digitalbazaar_ecdsa_multikey__WEBPACK_IMPORTED_MODULE_1__.from({publicKeyMultibase});\n\n  // 2. Verify all signatures.\n  if(signatures.length !== nonMandatory.length) {\n    throw new Error(\n      `Signature count (${signatures.length}) does not match ` +\n      `non-mandatory message count (${nonMandatory.length}).`);\n  }\n  const {verify} = localKeyPair.verifier();\n  const results = await Promise.all(signatures.map(\n    (signature, index) => verify({\n      data: (0,_digitalbazaar_di_sd_primitives__WEBPACK_IMPORTED_MODULE_2__.stringToUtf8Bytes)(nonMandatory[index]),\n      signature\n    })));\n  if(results.some(r => !r)) {\n    return false;\n  }\n\n  // 3. Verify base signature.\n  const toVerify = await (0,_proofValue_js__WEBPACK_IMPORTED_MODULE_3__.serializeBaseVerifyData)(\n    {proofHash, publicKey, mandatoryHash});\n  return verifier.verify({data: toVerify, signature: baseSignature});\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ecdsa-sd-2023-cryptosuite/lib/verify.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_SIGNATURE_2018_V1_URL: () => (/* binding */ ED25519_SIGNATURE_2018_V1_URL),\n/* harmony export */   ED25519_SIGNATURE_2020_V1_URL: () => (/* binding */ ED25519_SIGNATURE_2020_V1_URL),\n/* harmony export */   MULTIBASE_BASE58BTC_HEADER: () => (/* binding */ MULTIBASE_BASE58BTC_HEADER),\n/* harmony export */   MULTICODEC_PRIV_HEADER: () => (/* binding */ MULTICODEC_PRIV_HEADER),\n/* harmony export */   MULTICODEC_PUB_HEADER: () => (/* binding */ MULTICODEC_PUB_HEADER),\n/* harmony export */   MULTIKEY_CONTEXT_V1_URL: () => (/* binding */ MULTIKEY_CONTEXT_V1_URL),\n/* harmony export */   PUBLIC_KEY_SIZE: () => (/* binding */ PUBLIC_KEY_SIZE),\n/* harmony export */   SECRET_KEY_SIZE: () => (/* binding */ SECRET_KEY_SIZE)\n/* harmony export */ });\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n// Ed25519 Signature 2018 Context v1 URL\nconst ED25519_SIGNATURE_2018_V1_URL =\n  'https://w3id.org/security/suites/ed25519-2018/v1';\n// Ed25519 Signature 2020 Context v1 URL\nconst ED25519_SIGNATURE_2020_V1_URL =\n  'https://w3id.org/security/suites/ed25519-2020/v1';\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n// multicodec ed25519-pub header as varint\nconst MULTICODEC_PUB_HEADER = new Uint8Array([0xed, 0x01]);\n// multicodec ed25519-priv header as varint\nconst MULTICODEC_PRIV_HEADER = new Uint8Array([0x80, 0x26]);\n// multikey context v1 url\nconst MULTIKEY_CONTEXT_V1_URL = 'https://w3id.org/security/multikey/v1';\n// Ed25519 public key size in bytes\nconst PUBLIC_KEY_SIZE = 32;\n// Ed25519 secret key size in bytes\nconst SECRET_KEY_SIZE = 32;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateKeyPairFromSeed: () => (/* binding */ generateKeyPairFromSeed),\n/* harmony export */   sha256digest: () => (/* binding */ sha256digest),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_ed25519__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/ed25519 */ \"./node_modules/@noble/ed25519/lib/esm/index.js\");\n/* harmony import */ var _validators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validators.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/validators.js\");\n/*!\n * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n// browser MUST provide \"crypto.getRandomValues\"\nconst crypto = globalThis.crypto;\nif(!crypto.getRandomValues) {\n  throw new Error('Browser does not provide \"crypto.getRandomValues\".');\n}\n\nasync function generateKeyPairFromSeed(seed) {\n  (0,_validators_js__WEBPACK_IMPORTED_MODULE_1__.assertKeyBytes)({\n    bytes: seed,\n    expectedLength: 32,\n  });\n  const publicKey = await _noble_ed25519__WEBPACK_IMPORTED_MODULE_0__.getPublicKey(seed);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(seed);\n  secretKey.set(publicKey, seed.length);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\nasync function generateKeyPair() {\n  const seed = new Uint8Array(32);\n  crypto.getRandomValues(seed);\n  const keyPair = await generateKeyPairFromSeed(seed);\n  seed.fill(0);\n  return keyPair;\n}\n\nasync function sign(secretKey, data) {\n  return _noble_ed25519__WEBPACK_IMPORTED_MODULE_0__.sign(data, secretKey.slice(0, 32));\n}\n\nasync function verify(publicKey, data, signature) {\n  return _noble_ed25519__WEBPACK_IMPORTED_MODULE_0__.verify(signature, data, publicKey);\n}\n\nasync function sha256digest({data}) {\n  return crypto.subtle.digest('SHA-256', data);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/factory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/factory.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSigner: () => (/* binding */ createSigner),\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier)\n/* harmony export */ });\n/* harmony import */ var _ed25519_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ed25519.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js\");\n/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ALGORITHM = 'Ed25519';\n\nfunction createSigner({id, secretKey}) {\n  if(!secretKey) {\n    throw new Error('A secret key is not available for signing.');\n  }\n  return {\n    algorithm: ALGORITHM,\n    id,\n    async sign({data}) {\n      return _ed25519_js__WEBPACK_IMPORTED_MODULE_0__.sign(secretKey, data);\n    },\n  };\n}\n\nfunction createVerifier({id, publicKey}) {\n  if(!publicKey) {\n    throw new Error('A public key is not available for verifying.');\n  }\n  return {\n    algorithm: ALGORITHM,\n    id,\n    async verify({data, signature}) {\n      return _ed25519_js__WEBPACK_IMPORTED_MODULE_0__.verify(publicKey, data, signature);\n    },\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/factory.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mbDecodeKeyPair: () => (/* binding */ mbDecodeKeyPair),\n/* harmony export */   mbEncodeKeyPair: () => (/* binding */ mbEncodeKeyPair)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js\");\n/*!\n * Copyright (c) 2020-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\nfunction mbEncodeKeyPair({keyPair}) {\n  const result = {};\n  if(keyPair.publicKey) {\n    result.publicKeyMultibase = _encodeMbKey(\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTICODEC_PUB_HEADER, keyPair.publicKey);\n  }\n  if(keyPair.secretKey) {\n    result.secretKeyMultibase = _encodeMbKey(\n      _constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTICODEC_PRIV_HEADER, keyPair.secretKey);\n  }\n  return result;\n}\n\nfunction mbDecodeKeyPair({publicKeyMultibase, secretKeyMultibase}) {\n  if(!(publicKeyMultibase && typeof publicKeyMultibase === 'string' &&\n  publicKeyMultibase[0] === 'z')) {\n    throw new Error(\n      '\"publicKeyMultibase\" must be a multibase, base58-encoded string.');\n  }\n  // remove multibase header\n  const publicKeyMulticodec = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(publicKeyMultibase.substr(1));\n  // remove multicodec header\n  const publicKey = publicKeyMulticodec.slice(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTICODEC_PUB_HEADER.length);\n\n  let secretKey;\n  if(secretKeyMultibase) {\n    if(!(typeof secretKeyMultibase === 'string' &&\n    secretKeyMultibase[0] === 'z')) {\n      throw new Error(\n        '\"secretKeyMultibase\" must be a multibase, base58-encoded string.');\n    }\n    // remove multibase header\n    const secretKeyMulticodec = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(secretKeyMultibase.substr(1));\n    // remove multicodec header\n    secretKey = secretKeyMulticodec.slice(_constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTICODEC_PRIV_HEADER.length);\n  }\n\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\n// encode a multibase base58-btc multicodec key\nfunction _encodeMbKey(header, key) {\n  const mbKey = new Uint8Array(header.length + key.length);\n\n  mbKey.set(header);\n  mbKey.set(key, header.length);\n\n  return _constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTIBASE_BASE58BTC_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(mbKey);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromJwk: () => (/* binding */ fromJwk),\n/* harmony export */   generate: () => (/* binding */ generate),\n/* harmony export */   toJwk: () => (/* binding */ toJwk)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _ed25519_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ed25519.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/ed25519-browser.js\");\n/* harmony import */ var _factory_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factory.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/factory.js\");\n/* harmony import */ var _serialize_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serialize.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/serialize.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js\");\n/* harmony import */ var _keyPairTranslator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keyPairTranslator.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslator.js\");\n/*!\n * Copyright (c) 2020-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n\n\nasync function generate({id, controller, seed} = {}) {\n  let key;\n  if(seed) {\n    key = await _ed25519_js__WEBPACK_IMPORTED_MODULE_1__.generateKeyPairFromSeed(seed);\n  } else {\n    key = await _ed25519_js__WEBPACK_IMPORTED_MODULE_1__.generateKeyPair();\n  }\n\n  const {publicKeyMultibase, secretKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_5__.mbEncodeKeyPair)({\n    keyPair: key\n  });\n  if(controller && !id) {\n    id = `${controller}#${publicKeyMultibase}`;\n  }\n  const keyPair = {\n    id,\n    controller,\n    publicKeyMultibase,\n    secretKeyMultibase,\n    ...key,\n  };\n  return _createKeyPairInterface({keyPair});\n}\n\n// import key pair from JSON Multikey\nasync function from(key) {\n  let multikey = {...key};\n  if(multikey.type !== 'Multikey') {\n    // attempt loading from JWK if `publicKeyJwk` is present\n    if(multikey.publicKeyJwk) {\n      return fromJwk({jwk: multikey.publicKeyJwk, secretKey: false});\n    }\n    if(multikey.type) {\n      multikey = await (0,_keyPairTranslator_js__WEBPACK_IMPORTED_MODULE_6__.toMultikey)({keyPair: multikey});\n      return _createKeyPairInterface({keyPair: multikey});\n    }\n  }\n  if(!multikey.type) {\n    multikey.type = 'Multikey';\n  }\n  if(!multikey['@context']) {\n    multikey['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_4__.MULTIKEY_CONTEXT_V1_URL;\n  }\n\n  _assertMultikey(multikey);\n  return _createKeyPairInterface({keyPair: multikey});\n}\n\n// imports key pair from JWK\nasync function fromJwk({jwk, secretKey = false} = {}) {\n  const multikey = {\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_4__.MULTIKEY_CONTEXT_V1_URL,\n    type: 'Multikey',\n    publicKeyMultibase: (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.jwkToPublicKeyMultibase)({jwk})\n  };\n  if(secretKey && jwk.d) {\n    multikey.secretKeyMultibase = (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.jwkToSecretKeyMultibase)({jwk});\n  }\n  return from(multikey);\n}\n\n// converts key pair to JWK\nasync function toJwk({keyPair, secretKey = false} = {}) {\n  const jwk = {\n    kty: 'OKP',\n    crv: 'Ed25519',\n    x: base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(keyPair.publicKey)\n  };\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n  if(useSecretKey) {\n    jwk.d = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.encode(keyPair.secretKey);\n  }\n  return jwk;\n}\n\nasync function _createKeyPairInterface({keyPair}) {\n  if(!keyPair.publicKey) {\n    keyPair = await (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.importKeyPair)(keyPair);\n  }\n  keyPair = {\n    ...keyPair,\n    async export({\n      publicKey = true, secretKey = false, includeContext = true, raw = false,\n      canonicalize = false\n    } = {}) {\n      if(raw) {\n        const {publicKey, secretKey} = keyPair;\n        const result = {};\n        if(publicKey) {\n          result.publicKey = publicKey.slice();\n        }\n        if(secretKey) {\n          if(canonicalize && secretKey.length > _constants_js__WEBPACK_IMPORTED_MODULE_4__.SECRET_KEY_SIZE) {\n            result.secretKey = secretKey.subarray(0, _constants_js__WEBPACK_IMPORTED_MODULE_4__.SECRET_KEY_SIZE).slice();\n          }\n          result.secretKey = secretKey;\n        }\n        return result;\n      }\n      return (0,_serialize_js__WEBPACK_IMPORTED_MODULE_3__.exportKeyPair)({\n        keyPair, publicKey, secretKey, includeContext, canonicalize\n      });\n    },\n    signer() {\n      const {id, secretKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_2__.createSigner)({id, secretKey});\n    },\n    verifier() {\n      const {id, publicKey} = keyPair;\n      return (0,_factory_js__WEBPACK_IMPORTED_MODULE_2__.createVerifier)({id, publicKey});\n    }\n  };\n\n  return keyPair;\n}\n\nfunction _assertMultikey(key) {\n  if(!(key && typeof key === 'object')) {\n    throw new TypeError('\"key\" must be an object.');\n  }\n  if(key.type !== 'Multikey') {\n    throw new Error('\"key\" must be a Multikey with type \"Multikey\".');\n  }\n  if(!(key['@context'] === _constants_js__WEBPACK_IMPORTED_MODULE_4__.MULTIKEY_CONTEXT_V1_URL ||\n    (Array.isArray(key['@context']) &&\n    key['@context'].includes(_constants_js__WEBPACK_IMPORTED_MODULE_4__.MULTIKEY_CONTEXT_V1_URL)))) {\n    throw new TypeError(\n      '\"key\" must be a Multikey with context ' +\n      `\"${_constants_js__WEBPACK_IMPORTED_MODULE_4__.MULTIKEY_CONTEXT_V1_URL}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslationMap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslationMap.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keyPairTranslationMap: () => (/* binding */ keyPairTranslationMap)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\nconst keyPairTranslationMap = new Map([\n  ['Ed25519VerificationKey2020', {\n    contextUrl: _constants_js__WEBPACK_IMPORTED_MODULE_1__.ED25519_SIGNATURE_2020_V1_URL,\n    translationFn: _translateEd25519VerificationKey2020\n  }],\n  ['Ed25519VerificationKey2018', {\n    contextUrl: _constants_js__WEBPACK_IMPORTED_MODULE_1__.ED25519_SIGNATURE_2018_V1_URL,\n    translationFn: _translateEd25519VerificationKey2018\n  }]\n]);\n\nasync function _translateEd25519VerificationKey2020({keyPair}) {\n  return {\n    ...keyPair,\n    type: 'Multikey',\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTIKEY_CONTEXT_V1_URL,\n    secretKeyMultibase: keyPair.privateKeyMultibase\n  };\n}\n\nasync function _translateEd25519VerificationKey2018({keyPair}) {\n  const key = {\n    publicKey: base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.publicKeyBase58),\n    secretKey: undefined\n  };\n\n  if(keyPair.privateKeyBase58) {\n    key.secretKey = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.privateKeyBase58);\n  }\n\n  const {publicKeyMultibase, secretKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_2__.mbEncodeKeyPair)({\n    keyPair: key\n  });\n\n  return {\n    '@context': _constants_js__WEBPACK_IMPORTED_MODULE_1__.MULTIKEY_CONTEXT_V1_URL,\n    id: keyPair.id,\n    type: 'Multikey',\n    controller: keyPair.controller,\n    revoked: keyPair.revoked,\n    publicKeyMultibase,\n    secretKeyMultibase,\n  };\n}\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslationMap.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslator.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslator.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toMultikey: () => (/* binding */ toMultikey)\n/* harmony export */ });\n/* harmony import */ var _keyPairTranslationMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyPairTranslationMap.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslationMap.js\");\n/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nasync function toMultikey({keyPair}) {\n  const translationResult = _keyPairTranslationMap_js__WEBPACK_IMPORTED_MODULE_0__.keyPairTranslationMap.get(keyPair.type);\n  if(!translationResult) {\n    throw new Error(`Unsupported key type \"${keyPair.type}\".`);\n  }\n\n  const {contextUrl, translationFn} = translationResult;\n  if(!keyPair['@context']) {\n    keyPair['@context'] = contextUrl;\n  }\n  if(!_includesContext({document: keyPair, contextUrl})) {\n    throw new Error(`Context not supported \"${keyPair['@context']}\".`);\n  }\n\n  return translationFn({keyPair});\n}\n\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/keyPairTranslator.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/serialize.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/serialize.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportKeyPair: () => (/* binding */ exportKeyPair),\n/* harmony export */   importKeyPair: () => (/* binding */ importKeyPair),\n/* harmony export */   jwkToPublicKeyBytes: () => (/* binding */ jwkToPublicKeyBytes),\n/* harmony export */   jwkToPublicKeyMultibase: () => (/* binding */ jwkToPublicKeyMultibase),\n/* harmony export */   jwkToSecretKeyBytes: () => (/* binding */ jwkToSecretKeyBytes),\n/* harmony export */   jwkToSecretKeyMultibase: () => (/* binding */ jwkToSecretKeyMultibase),\n/* harmony export */   rawToPublicKeyMultibase: () => (/* binding */ rawToPublicKeyMultibase),\n/* harmony export */   rawToSecretKeyMultibase: () => (/* binding */ rawToSecretKeyMultibase)\n/* harmony export */ });\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/helpers.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/constants.js\");\n/*!\n * Copyright (c) 2022-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\nconst LEGACY_SECRET_KEY_SIZE = _constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE + _constants_js__WEBPACK_IMPORTED_MODULE_2__.PUBLIC_KEY_SIZE;\n\nasync function exportKeyPair({\n  keyPair, secretKey, publicKey, includeContext, canonicalize = false\n} = {}) {\n  if(!(publicKey || secretKey)) {\n    throw new TypeError(\n      'Export requires specifying either \"publicKey\" or \"secretKey\".');\n  }\n\n  const useSecretKey = secretKey && !!keyPair.secretKey;\n\n  // export as Multikey\n  const exported = {};\n  if(includeContext) {\n    exported['@context'] = _constants_js__WEBPACK_IMPORTED_MODULE_2__.MULTIKEY_CONTEXT_V1_URL;\n  }\n  exported.id = keyPair.id;\n  exported.type = 'Multikey';\n  exported.controller = keyPair.controller;\n\n  if(publicKey) {\n    exported.publicKeyMultibase = rawToPublicKeyMultibase(keyPair);\n  }\n  if(useSecretKey) {\n    exported.secretKeyMultibase = rawToSecretKeyMultibase({\n      ...keyPair, canonicalize\n    });\n  }\n\n  if(keyPair.revoked) {\n    exported.revoked = keyPair.revoked;\n  }\n\n  return exported;\n}\n\nasync function importKeyPair({\n  id, controller, secretKeyMultibase, publicKeyMultibase, revoked\n}) {\n  if(!publicKeyMultibase) {\n    throw new TypeError('The \"publicKeyMultibase\" property is required.');\n  }\n\n  const {\n    publicKey, secretKey\n  } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mbDecodeKeyPair)({publicKeyMultibase, secretKeyMultibase});\n\n  if(controller && !id) {\n    id = `${controller}#${publicKeyMultibase}`;\n  }\n\n  return {\n    id,\n    controller,\n    publicKey,\n    secretKey,\n    publicKeyMultibase,\n    secretKeyMultibase,\n    revoked,\n  };\n}\n\nfunction jwkToPublicKeyBytes({jwk} = {}) {\n  const {kty, crv, x} = jwk;\n  if(kty !== 'OKP') {\n    throw new TypeError('\"jwk.kty\" must be \"OKP\".');\n  }\n  if(crv !== 'Ed25519') {\n    throw new TypeError('\"jwk.crv\" must be \"Ed25519\".');\n  }\n  if(typeof x !== 'string') {\n    throw new TypeError('\"jwk.x\" must be a string.');\n  }\n  const publicKey = base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(jwk.x);\n  if(publicKey.length !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.PUBLIC_KEY_SIZE) {\n    throw new Error(\n      `Invalid public key size (${publicKey.length}); ` +\n      `expected ${_constants_js__WEBPACK_IMPORTED_MODULE_2__.PUBLIC_KEY_SIZE}.`);\n  }\n  return publicKey;\n}\n\nfunction jwkToPublicKeyMultibase({jwk} = {}) {\n  const publicKey = jwkToPublicKeyBytes({jwk});\n  const {publicKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mbEncodeKeyPair)({\n    keyPair: {publicKey}\n  });\n  return publicKeyMultibase;\n}\n\nfunction jwkToSecretKeyBytes({jwk} = {}) {\n  const {kty, crv, d} = jwk;\n  if(kty !== 'OKP') {\n    throw new TypeError('\"jwk.kty\" must be \"OKP\".');\n  }\n  if(crv !== 'Ed25519') {\n    throw new TypeError('\"jwk.crv\" must be \"Ed25519\".');\n  }\n  if(typeof d !== 'string') {\n    throw new TypeError('\"jwk.d\" must be a string.');\n  }\n  const secretKey = Uint8Array.from(base64url_universal__WEBPACK_IMPORTED_MODULE_0__.decode(jwk.d));\n  if(secretKey.length !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE) {\n    throw new Error(\n      `Invalid secret key size (${secretKey.length}); ` +\n      `expected ${_constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE}.`);\n  }\n  return secretKey;\n}\n\nfunction jwkToSecretKeyMultibase({jwk} = {}) {\n  const secretKey = jwkToSecretKeyBytes({jwk});\n  const {secretKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mbEncodeKeyPair)({\n    keyPair: {secretKey}\n  });\n  return secretKeyMultibase;\n}\n\nfunction rawToPublicKeyMultibase({publicKey} = {}) {\n  if(publicKey.length !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.PUBLIC_KEY_SIZE) {\n    throw new Error(\n      `Invalid public key size (${publicKey.length}); ` +\n      `expected ${_constants_js__WEBPACK_IMPORTED_MODULE_2__.PUBLIC_KEY_SIZE}.`);\n  }\n  const {publicKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mbEncodeKeyPair)({\n    keyPair: {publicKey}\n  });\n  return publicKeyMultibase;\n}\n\nfunction rawToSecretKeyMultibase({\n  secretKey, canonicalize = false\n} = {}) {\n  if(secretKey.length !== _constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE) {\n    if(secretKey.length !== LEGACY_SECRET_KEY_SIZE) {\n      throw new Error(\n        `Invalid secret key size (${secretKey.length}); ` +\n        `expected ${_constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE}.`);\n    }\n    // handle legacy concatenated (secret key + public key)\n    if(canonicalize) {\n      secretKey = secretKey.subarray(0, _constants_js__WEBPACK_IMPORTED_MODULE_2__.SECRET_KEY_SIZE);\n    }\n  }\n  const {secretKeyMultibase} = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_1__.mbEncodeKeyPair)({\n    keyPair: {secretKey}\n  });\n  return secretKeyMultibase;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/serialize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-multikey/lib/validators.js":
/*!************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-multikey/lib/validators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertKeyBytes: () => (/* binding */ assertKeyBytes)\n/* harmony export */ });\n/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * Asserts that key bytes have a type of Uint8Array and a specific length.\n *\n * @throws {TypeError|SyntaxError} - Throws a Type or Syntax error.\n *\n * @param {object} options - Options to use.\n * @param {Uint8Array} options.bytes - The bytes being checked.\n * @param {number} [options.expectedLength=32] - The expected bytes length.\n * @param {string} [options.code] - An optional code for the error.\n *\n * @returns {undefined} Returns on success throws on error.\n */\nfunction assertKeyBytes({bytes, expectedLength = 32, code}) {\n  if(!(bytes instanceof Uint8Array)) {\n    throw new TypeError('\"bytes\" must be a Uint8Array.');\n  }\n  if(bytes.length !== expectedLength) {\n    const error = new Error(\n      `\"bytes\" must be a ${expectedLength}-byte Uint8Array.`);\n    // we need DataError for invalid byte length\n    error.name = 'DataError';\n    // add the error code from the did:key spec if provided\n    if(code) {\n      error.code = code;\n    }\n    throw error;\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-multikey/lib/validators.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519Signature2020: () => (/* binding */ Ed25519Signature2020)\n/* harmony export */ });\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @digitalbazaar/ed25519-verification-key-2020 */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/index.js\");\n/* harmony import */ var ed25519_signature_2018_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ed25519-signature-2018-context */ \"./node_modules/ed25519-signature-2018-context/dist/context.esm.js\");\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\nconst {suites: {LinkedDataSignature}} = jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__;\n\n\n\n\n\n// 'https://w3id.org/security/suites/ed25519-2020/v1'\nconst SUITE_CONTEXT_URL = ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_4__[\"default\"].constants.CONTEXT_URL;\n// 'https://w3id.org/security/suites/ed25519-2018/v1'\nconst SUITE_CONTEXT_URL_2018 = ed25519_signature_2018_context__WEBPACK_IMPORTED_MODULE_3__[\"default\"].constants.CONTEXT_URL;\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n\nclass Ed25519Signature2020 extends LinkedDataSignature {\n  /**\n   * @param {object} options - Options hashmap.\n   *\n   * Either a `key` OR at least one of `signer`/`verifier` is required:\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   * @param {Function} [options.signer] - Signer function that returns an\n   *   object with an async sign() method. This is useful when interfacing\n   *   with a KMS (since you don't get access to the private key and its\n   *   `signer()`, the KMS client gives you only the signer function to use).\n   * @param {Function} [options.verifier] - Verifier function that returns\n   *   an object with an async `verify()` method. Useful when working with a\n   *   KMS-provided verifier function.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param {string|Date} [options.date] - Signing date to use if not passed.\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   * @param {object} [options.canonizeOptions] - Options to pass to\n   *   canonize algorithm.\n   */\n  constructor({\n    key, signer, verifier, proof, date, useNativeCanonize, canonizeOptions\n  } = {}) {\n    super({\n      type: 'Ed25519Signature2020', LDKeyClass: _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_2__.Ed25519VerificationKey2020,\n      contextUrl: SUITE_CONTEXT_URL,\n      key, signer, verifier, proof, date, useNativeCanonize,\n      canonizeOptions\n    });\n    // Some operations may be performed with Ed25519VerificationKey2018.\n    // So, Ed25519VerificationKey2020 is recommended, but not strictly required.\n    this.requiredKeyType = 'Ed25519VerificationKey2020';\n  }\n\n  /**\n   * Adds a signature (proofValue) field to the proof object. Called by\n   * LinkedDataSignature.createProof().\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Data to be signed (extracted\n   *   from document, according to the suite's spec).\n   * @param {object} options.proof - Proof object (containing the proofPurpose,\n   *   verificationMethod, etc).\n   *\n   * @returns {Promise<object>} Resolves with the proof containing the signature\n   *   value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n\n    const signatureBytes = await this.signer.sign({data: verifyData});\n    proof.proofValue =\n      MULTIBASE_BASE58BTC_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_1__.encode(signatureBytes);\n\n    return proof;\n  }\n\n  /**\n   * Verifies the proof signature against the given data.\n   *\n   * @param {object} options - The options to use.\n   * @param {Uint8Array} options.verifyData - Canonicalized hashed data.\n   * @param {object} options.verificationMethod - Key object.\n   * @param {object} options.proof - The proof to be verified.\n   *\n   * @returns {Promise<boolean>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    const {proofValue} = proof;\n    if(!(proofValue && typeof proofValue === 'string')) {\n      throw new TypeError(\n        'The proof does not include a valid \"proofValue\" property.');\n    }\n    if(proofValue[0] !== MULTIBASE_BASE58BTC_HEADER) {\n      throw new Error('Only base58btc multibase encoding is supported.');\n    }\n    const signatureBytes = base58_universal__WEBPACK_IMPORTED_MODULE_1__.decode(proofValue.substr(1));\n\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data: verifyData, signature: signatureBytes});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    let contextUrl;\n    if(verificationMethod.type === 'Ed25519VerificationKey2020') {\n      contextUrl = SUITE_CONTEXT_URL;\n    } else if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      contextUrl = SUITE_CONTEXT_URL_2018;\n    } else {\n      throw new Error(`Unsupported key type \"${verificationMethod.type}\".`);\n    }\n    if(!_includesContext({\n      document: verificationMethod, contextUrl\n    })) {\n      // For DID Documents, since keys do not have their own contexts,\n      // the suite context is usually provided by the documentLoader logic\n      throw new TypeError(\n        `The verification method (key) must contain \"${contextUrl}\" context.`\n      );\n    }\n\n    // ensure verification method has not been revoked\n    if(verificationMethod.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      // This happens most often during sign() operations. For verify(),\n      // the expectation is that the verification method will be fetched\n      // by the documentLoader (below), not provided as a `key` parameter.\n      return this.key.export({publicKey: true});\n    }\n\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    const {document} = await documentLoader(verificationMethod);\n\n    verificationMethod = typeof document === 'string' ?\n      JSON.parse(document) : document;\n\n    await this.assertVerificationMethod({verificationMethod});\n    if(verificationMethod.type === 'Ed25519VerificationKey2018') {\n      verificationMethod = (await _digitalbazaar_ed25519_verification_key_2020__WEBPACK_IMPORTED_MODULE_2__.Ed25519VerificationKey2020\n        .fromEd25519VerificationKey2018({keyPair: verificationMethod}))\n        .export({publicKey: true, includeContext: true});\n    }\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader}) {\n    if(!_includesContext({document, contextUrl: SUITE_CONTEXT_URL})) {\n      return false;\n    }\n\n    if(!await super.matchProof({proof, document, purpose, documentLoader})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    const {verificationMethod} = proof;\n\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n}\n\n/**\n * Tests whether a provided JSON-LD document includes a context url in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context url.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\nEd25519Signature2020.CONTEXT_URL = SUITE_CONTEXT_URL;\nEd25519Signature2020.CONTEXT = ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_4__[\"default\"].contexts.get(SUITE_CONTEXT_URL);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-signature-2020/lib/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-signature-2020/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519Signature2020: () => (/* reexport safe */ _Ed25519Signature2020_js__WEBPACK_IMPORTED_MODULE_1__.Ed25519Signature2020),\n/* harmony export */   suiteContext: () => (/* reexport safe */ ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var ed25519_signature_2020_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ed25519-signature-2020-context */ \"./node_modules/ed25519-signature-2020-context/dist/context.esm.js\");\n/* harmony import */ var _Ed25519Signature2020_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ed25519Signature2020.js */ \"./node_modules/@digitalbazaar/ed25519-signature-2020/lib/Ed25519Signature2020.js\");\n/*!\n * Copyright (c) 2020-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-signature-2020/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519VerificationKey2020: () => (/* binding */ Ed25519VerificationKey2020)\n/* harmony export */ });\n/* harmony import */ var base58_universal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base58-universal */ \"./node_modules/base58-universal/lib/index.js\");\n/* harmony import */ var base64url_universal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! base64url-universal */ \"./node_modules/base64url-universal/lib/browser.js\");\n/* harmony import */ var _validators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./validators.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js\");\n/* harmony import */ var _ed25519_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ed25519.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js\");\n/* harmony import */ var crypto_ld__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! crypto-ld */ \"./node_modules/crypto-ld/lib/index.js\");\n/*!\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n\n\nconst SUITE_ID = 'Ed25519VerificationKey2020';\n// multibase base58-btc header\nconst MULTIBASE_BASE58BTC_HEADER = 'z';\n// multicodec ed25519-pub header as varint\nconst MULTICODEC_ED25519_PUB_HEADER = new Uint8Array([0xed, 0x01]);\n// multicodec ed25519-priv header as varint\nconst MULTICODEC_ED25519_PRIV_HEADER = new Uint8Array([0x80, 0x26]);\n\nclass Ed25519VerificationKey2020 extends crypto_ld__WEBPACK_IMPORTED_MODULE_4__.LDKeyPair {\n  /**\n   * An implementation of the Ed25519VerificationKey2020 spec, for use with\n   * Linked Data Proofs.\n   *\n   * @see https://w3c-ccg.github.io/lds-ed25519-2020/#ed25519verificationkey2020\n   * @see https://github.com/digitalbazaar/jsonld-signatures\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.controller - Controller DID or document url.\n   * @param {string} [options.id] - The key ID. If not provided, will be\n   *   composed of controller and key fingerprint as hash fragment.\n   * @param {string} options.publicKeyMultibase - Multibase encoded public key\n   *   with a multicodec ed25519-pub varint header [0xed, 0x01].\n   * @param {string} [options.privateKeyMultibase] - Multibase private key\n   *   with a multicodec ed25519-priv varint header [0x80, 0x26].\n   * @param {string} [options.revoked] - Timestamp of when the key has been\n   *   revoked, in RFC3339 format. If not present, the key itself is considered\n   *   not revoked. Note that this mechanism is slightly different than DID\n   *   Document key revocation, where a DID controller can revoke a key from\n   *   that DID by removing it from the DID Document.\n   */\n  constructor(options = {}) {\n    super(options);\n    this.type = SUITE_ID;\n    const {publicKeyMultibase, privateKeyMultibase} = options;\n\n    if(!publicKeyMultibase) {\n      throw new TypeError('The \"publicKeyMultibase\" property is required.');\n    }\n\n    if(!publicKeyMultibase || !_isValidKeyHeader(\n      publicKeyMultibase, MULTICODEC_ED25519_PUB_HEADER)) {\n      throw new Error(\n        '\"publicKeyMultibase\" has invalid header bytes: ' +\n        `\"${publicKeyMultibase}\".`);\n    }\n\n    if(privateKeyMultibase && !_isValidKeyHeader(\n      privateKeyMultibase, MULTICODEC_ED25519_PRIV_HEADER)) {\n      throw new Error('\"privateKeyMultibase\" has invalid header bytes.');\n    }\n\n    // assign valid key values\n    this.publicKeyMultibase = publicKeyMultibase;\n    this.privateKeyMultibase = privateKeyMultibase;\n\n    // set key identifier if controller is provided\n    if(this.controller && !this.id) {\n      this.id = `${this.controller}#${this.fingerprint()}`;\n    }\n    // check that the passed in keyBytes are 32 bytes\n    (0,_validators_js__WEBPACK_IMPORTED_MODULE_2__.assertKeyBytes)({\n      bytes: this._publicKeyBuffer,\n      code: 'invalidPublicKeyLength',\n      expectedLength: 32\n    });\n  }\n\n  /**\n   * Creates an Ed25519 Key Pair from an existing serialized key pair.\n   *\n   * @param {object} options - Key pair options (see constructor).\n   * @example\n   * > const keyPair = await Ed25519VerificationKey2020.from({\n   * controller: 'did:ex:1234',\n   * type: 'Ed25519VerificationKey2020',\n   * publicKeyMultibase,\n   * privateKeyMultibase\n   * });\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} An Ed25519 Key Pair.\n   */\n  static async from(options) {\n    if(options.type === 'Ed25519VerificationKey2018') {\n      return Ed25519VerificationKey2020.fromEd25519VerificationKey2018(options);\n    }\n    if(options.type === 'JsonWebKey2020') {\n      return Ed25519VerificationKey2020.fromJsonWebKey2020(options);\n    }\n    return new Ed25519VerificationKey2020(options);\n  }\n\n  /**\n   * Instance creation method for backwards compatibility with the\n   * `Ed25519VerificationKey2018` key suite.\n   *\n   * @see https://github.com/digitalbazaar/ed25519-verification-key-2018\n   * @typedef {object} Ed25519VerificationKey2018\n   * @param {Ed25519VerificationKey2018} keyPair - Ed25519 2018 suite key pair.\n   *\n   * @returns {Ed25519VerificationKey2020} - 2020 suite instance.\n   */\n  static fromEd25519VerificationKey2018({keyPair} = {}) {\n    const publicKeyMultibase = _encodeMbKey(\n      MULTICODEC_ED25519_PUB_HEADER, base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.publicKeyBase58));\n    const keyPair2020 = new Ed25519VerificationKey2020({\n      id: keyPair.id,\n      controller: keyPair.controller,\n      publicKeyMultibase\n    });\n\n    if(keyPair.privateKeyBase58) {\n      keyPair2020.privateKeyMultibase = _encodeMbKey(\n        MULTICODEC_ED25519_PRIV_HEADER,\n        base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(keyPair.privateKeyBase58));\n    }\n\n    return keyPair2020;\n  }\n\n  /**\n   * Creates a key pair instance (public key only) from a JsonWebKey2020\n   * object.\n   *\n   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key id.\n   * @param {string} options.type - Key suite type.\n   * @param {string} options.controller - Key controller.\n   * @param {object} options.publicKeyJwk - JWK object.\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with key pair.\n   */\n  static fromJsonWebKey2020({id, type, controller, publicKeyJwk} = {}) {\n    if(type !== 'JsonWebKey2020') {\n      throw new TypeError(`Invalid key type: \"${type}\".`);\n    }\n    if(!publicKeyJwk) {\n      throw new TypeError('\"publicKeyJwk\" property is required.');\n    }\n    const {kty, crv} = publicKeyJwk;\n    if(kty !== 'OKP') {\n      throw new TypeError('\"kty\" is required to be \"OKP\".');\n    }\n    if(crv !== 'Ed25519') {\n      throw new TypeError('\"crv\" is required to be \"Ed25519\".');\n    }\n    const {x: publicKeyBase64Url} = publicKeyJwk;\n    const publicKeyMultibase = _encodeMbKey(\n      MULTICODEC_ED25519_PUB_HEADER,\n      base64url_universal__WEBPACK_IMPORTED_MODULE_1__.decode(publicKeyBase64Url));\n\n    return Ed25519VerificationKey2020.from({\n      id, controller, publicKeyMultibase\n    });\n  }\n\n  /**\n   * Generates a KeyPair with an optional deterministic seed.\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {Uint8Array} [options.seed] - A 32-byte array seed for a\n   *   deterministic key.\n   *\n   * @returns {Promise<Ed25519VerificationKey2020>} Resolves with generated\n   *   public/private key pair.\n   */\n  static async generate({seed, ...keyPairOptions} = {}) {\n    let keyObject;\n    if(seed) {\n      keyObject = await _ed25519_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].generateKeyPairFromSeed(seed);\n    } else {\n      keyObject = await _ed25519_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].generateKeyPair();\n    }\n    const publicKeyMultibase =\n      _encodeMbKey(MULTICODEC_ED25519_PUB_HEADER, keyObject.publicKey);\n\n    const privateKeyMultibase =\n      _encodeMbKey(MULTICODEC_ED25519_PRIV_HEADER, keyObject.secretKey);\n\n    return new Ed25519VerificationKey2020({\n      publicKeyMultibase,\n      privateKeyMultibase,\n      ...keyPairOptions\n    });\n  }\n\n  /**\n   * Creates an instance of Ed25519VerificationKey2020 from a key fingerprint.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.fingerprint - Multibase encoded key fingerprint.\n   *\n   * @returns {Ed25519VerificationKey2020} Returns key pair instance (with\n   *   public key only).\n   */\n  static fromFingerprint({fingerprint} = {}) {\n    return new Ed25519VerificationKey2020({publicKeyMultibase: fingerprint});\n  }\n\n  /**\n   * @returns {Uint8Array} Public key bytes.\n   */\n  get _publicKeyBuffer() {\n    if(!this.publicKeyMultibase) {\n      return;\n    }\n    // remove multibase header\n    const publicKeyMulticodec =\n      base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(this.publicKeyMultibase.substr(1));\n    // remove multicodec header\n    const publicKeyBytes =\n      publicKeyMulticodec.slice(MULTICODEC_ED25519_PUB_HEADER.length);\n\n    return publicKeyBytes;\n  }\n\n  /**\n   * @returns {Uint8Array} Private key bytes.\n   */\n  get _privateKeyBuffer() {\n    if(!this.privateKeyMultibase) {\n      return;\n    }\n    // remove multibase header\n    const privateKeyMulticodec =\n      base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(this.privateKeyMultibase.substr(1));\n    // remove multicodec header\n    const privateKeyBytes =\n      privateKeyMulticodec.slice(MULTICODEC_ED25519_PRIV_HEADER.length);\n\n    return privateKeyBytes;\n  }\n\n  /**\n   * Generates and returns a multiformats encoded\n   * ed25519 public key fingerprint (for use with cryptonyms, for example).\n   *\n   * @see https://github.com/multiformats/multicodec\n   *\n   * @returns {string} The fingerprint.\n   */\n  fingerprint() {\n    return this.publicKeyMultibase;\n  }\n\n  /**\n   * Exports the serialized representation of the KeyPair\n   * and other information that JSON-LD Signatures can use to form a proof.\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Export public key material?\n   * @param {boolean} [options.privateKey] - Export private key material?\n   * @param {boolean} [options.includeContext] - Include JSON-LD context?\n   *\n   * @returns {object} A plain js object that's ready for serialization\n   *   (to JSON, etc), for use in DIDs, Linked Data Proofs, etc.\n   */\n  export({publicKey = false, privateKey = false, includeContext = false} = {}) {\n    if(!(publicKey || privateKey)) {\n      throw new TypeError(\n        'Export requires specifying either \"publicKey\" or \"privateKey\".');\n    }\n    const exportedKey = {\n      id: this.id,\n      type: this.type\n    };\n    if(includeContext) {\n      exportedKey['@context'] = Ed25519VerificationKey2020.SUITE_CONTEXT;\n    }\n    if(this.controller) {\n      exportedKey.controller = this.controller;\n    }\n    if(publicKey) {\n      exportedKey.publicKeyMultibase = this.publicKeyMultibase;\n    }\n    if(privateKey) {\n      exportedKey.privateKeyMultibase = this.privateKeyMultibase;\n    }\n    if(this.revoked) {\n      exportedKey.revoked = this.revoked;\n    }\n    return exportedKey;\n  }\n\n  /**\n   * Returns the JWK representation of this key pair.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc8037\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Include public key?\n   * @param {boolean} [options.privateKey] - Include private key?\n   *\n   * @returns {{kty: string, crv: string, x: string, d: string}} JWK\n   *   representation.\n   */\n  toJwk({publicKey = true, privateKey = false} = {}) {\n    if(!(publicKey || privateKey)) {\n      throw TypeError('Either a \"publicKey\" or a \"privateKey\" is required.');\n    }\n    const jwk = {crv: 'Ed25519', kty: 'OKP'};\n    if(publicKey) {\n      jwk.x = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._publicKeyBuffer);\n    }\n    if(privateKey) {\n      jwk.d = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._privateKeyBuffer);\n    }\n    return jwk;\n  }\n\n  /**\n   * @see https://datatracker.ietf.org/doc/html/rfc8037#appendix-A.3\n   *\n   * @returns {Promise<string>} JWK Thumbprint.\n   */\n  async jwkThumbprint() {\n    const publicKey = base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(this._publicKeyBuffer);\n    const serialized = `{\"crv\":\"Ed25519\",\"kty\":\"OKP\",\"x\":\"${publicKey}\"}`;\n    const data = new TextEncoder().encode(serialized);\n    return base64url_universal__WEBPACK_IMPORTED_MODULE_1__.encode(\n      new Uint8Array(await _ed25519_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].sha256digest({data})));\n  }\n\n  /**\n   * Returns the JsonWebKey2020 representation of this key pair.\n   *\n   * @see https://w3c-ccg.github.io/lds-jws2020/#json-web-key-2020\n   *\n   * @returns {Promise<object>} JsonWebKey2020 representation.\n   */\n  async toJsonWebKey2020() {\n    return {\n      '@context': 'https://w3id.org/security/jws/v1',\n      id: this.controller + '#' + await this.jwkThumbprint(),\n      type: 'JsonWebKey2020',\n      controller: this.controller,\n      publicKeyJwk: this.toJwk({publicKey: true})\n    };\n  }\n\n  /**\n   * Tests whether the fingerprint was generated from a given key pair.\n   *\n   * @example\n   * > edKeyPair.verifyFingerprint({fingerprint: 'z6Mk2S2Q...6MkaFJewa'});\n   * {valid: true};\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.fingerprint - A public key fingerprint.\n   *\n   * @returns {{valid: boolean, error: *}} Result of verification.\n   */\n  verifyFingerprint({fingerprint} = {}) {\n    // fingerprint should have multibase base58-btc header\n    if(!(typeof fingerprint === 'string' &&\n      fingerprint[0] === MULTIBASE_BASE58BTC_HEADER)) {\n      return {\n        error: new Error('\"fingerprint\" must be a multibase encoded string.'),\n        valid: false\n      };\n    }\n    let fingerprintBuffer;\n    try {\n      fingerprintBuffer = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(fingerprint.substr(1));\n      if(!fingerprintBuffer) {\n        throw new TypeError('Invalid encoding of fingerprint.');\n      }\n    } catch(e) {\n      return {error: e, valid: false};\n    }\n\n    const buffersEqual = _isEqualBuffer(this._publicKeyBuffer,\n      fingerprintBuffer.slice(2));\n\n    // validate the first two multicodec bytes\n    const valid =\n      fingerprintBuffer[0] === MULTICODEC_ED25519_PUB_HEADER[0] &&\n      fingerprintBuffer[1] === MULTICODEC_ED25519_PUB_HEADER[1] &&\n      buffersEqual;\n    if(!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false\n      };\n    }\n    return {valid};\n  }\n\n  signer() {\n    const privateKeyBuffer = this._privateKeyBuffer;\n\n    return {\n      async sign({data}) {\n        if(!privateKeyBuffer) {\n          throw new Error('A private key is not available for signing.');\n        }\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].sign(privateKeyBuffer, data);\n      },\n      id: this.id\n    };\n  }\n\n  verifier() {\n    const publicKeyBuffer = this._publicKeyBuffer;\n\n    return {\n      async verify({data, signature}) {\n        if(!publicKeyBuffer) {\n          throw new Error('A public key is not available for verifying.');\n        }\n        return _ed25519_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].verify(publicKeyBuffer, data, signature);\n      },\n      id: this.id\n    };\n  }\n}\n// Used by CryptoLD harness for dispatching.\nEd25519VerificationKey2020.suite = SUITE_ID;\n// Used by CryptoLD harness's fromKeyId() method.\nEd25519VerificationKey2020.SUITE_CONTEXT =\n  'https://w3id.org/security/suites/ed25519-2020/v1';\n\n// check to ensure that two buffers are byte-for-byte equal\n// WARNING: this function must only be used to check public information as\n//          timing attacks can be used for non-constant time checks on\n//          secret information.\nfunction _isEqualBuffer(buf1, buf2) {\n  if(buf1.length !== buf2.length) {\n    return false;\n  }\n  for(let i = 0; i < buf1.length; i++) {\n    if(buf1[i] !== buf2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// check a multibase key for an expected header\nfunction _isValidKeyHeader(multibaseKey, expectedHeader) {\n  if(!(typeof multibaseKey === 'string' &&\n    multibaseKey[0] === MULTIBASE_BASE58BTC_HEADER)) {\n    return false;\n  }\n\n  const keyBytes = base58_universal__WEBPACK_IMPORTED_MODULE_0__.decode(multibaseKey.slice(1));\n  return expectedHeader.every((val, i) => keyBytes[i] === val);\n}\n\n// encode a multibase base58-btc multicodec key\nfunction _encodeMbKey(header, key) {\n  const mbKey = new Uint8Array(header.length + key.length);\n\n  mbKey.set(header);\n  mbKey.set(key, header.length);\n\n  return MULTIBASE_BASE58BTC_HEADER + base58_universal__WEBPACK_IMPORTED_MODULE_0__.encode(mbKey);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validators_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validators.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js\");\n/* harmony import */ var _noble_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/ed25519 */ \"./node_modules/@noble/ed25519/lib/esm/index.js\");\n/*!\n * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n// browser MUST provide \"crypto.getRandomValues\"\nconst crypto = globalThis.crypto;\nif(!crypto.getRandomValues) {\n  throw new Error('Browser does not provide \"crypto.getRandomValues\".');\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  async generateKeyPair() {\n    const seed = new Uint8Array(32);\n    crypto.getRandomValues(seed);\n    const keyPair = await generateKeyPairFromSeed(seed);\n    seed.fill(0);\n    return keyPair;\n  },\n  generateKeyPairFromSeed,\n  async sign(secretKey, data) {\n    return _noble_ed25519__WEBPACK_IMPORTED_MODULE_1__.sign(data, secretKey.slice(0, 32));\n  },\n  async verify(publicKey, data, signature) {\n    return _noble_ed25519__WEBPACK_IMPORTED_MODULE_1__.verify(signature, data, publicKey);\n  },\n  async sha256digest({data}) {\n    return crypto.subtle.digest('SHA-256', data);\n  }\n});\n\nasync function generateKeyPairFromSeed(seed) {\n  (0,_validators_js__WEBPACK_IMPORTED_MODULE_0__.assertKeyBytes)({\n    bytes: seed,\n    expectedLength: 32,\n  });\n  const publicKey = await _noble_ed25519__WEBPACK_IMPORTED_MODULE_1__.getPublicKey(seed);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(seed);\n  secretKey.set(publicKey, seed.length);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/ed25519-browser.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519VerificationKey2020: () => (/* reexport safe */ _Ed25519VerificationKey2020_js__WEBPACK_IMPORTED_MODULE_0__.Ed25519VerificationKey2020)\n/* harmony export */ });\n/* harmony import */ var _Ed25519VerificationKey2020_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ed25519VerificationKey2020.js */ \"./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/Ed25519VerificationKey2020.js\");\n/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertKeyBytes: () => (/* binding */ assertKeyBytes)\n/* harmony export */ });\n/*!\n * Copyright (c) 2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * Asserts that key bytes have a type of Uint8Array and a specific length.\n *\n * @throws {TypeError|SyntaxError} - Throws a Type or Syntax error.\n *\n * @param {object} options - Options to use.\n * @param {Uint8Array} options.bytes - The bytes being checked.\n * @param {number} [options.expectedLength=32] - The expected bytes length.\n * @param {string} [options.code] - An optional code for the error.\n *\n * @returns {undefined} Returns on success throws on error.\n */\nfunction assertKeyBytes({bytes, expectedLength = 32, code}) {\n  if(!(bytes instanceof Uint8Array)) {\n    throw new TypeError('\"bytes\" must be a Uint8Array.');\n  }\n  if(bytes.length !== expectedLength) {\n    const error = new Error(\n      `\"bytes\" must be a ${expectedLength}-byte Uint8Array.`);\n    // we need DataError for invalid byte length\n    error.name = 'DataError';\n    // add the error code from the did:key spec if provided\n    if(code) {\n      error.code = code;\n    }\n    throw error;\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/ed25519-verification-key-2020/lib/validators.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/canonize.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/canonize.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canonize: () => (/* binding */ canonize)\n/* harmony export */ });\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nfunction canonize(input, options) {\n  return jsonld__WEBPACK_IMPORTED_MODULE_0__.canonize(input, {\n    algorithm: 'URDNA2015',\n    format: 'application/n-quads',\n    ...options\n  });\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/canonize.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/createVerifier.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/createVerifier.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createVerifier: () => (/* binding */ createVerifier)\n/* harmony export */ });\n/* harmony import */ var _digitalbazaar_ed25519_multikey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @digitalbazaar/ed25519-multikey */ \"./node_modules/@digitalbazaar/ed25519-multikey/lib/index.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nasync function createVerifier({verificationMethod}) {\n  const key = await _digitalbazaar_ed25519_multikey__WEBPACK_IMPORTED_MODULE_0__.from(verificationMethod);\n  const verifier = key.verifier();\n  return verifier;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/createVerifier.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cryptosuite: () => (/* binding */ cryptosuite)\n/* harmony export */ });\n/* harmony import */ var _canonize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canonize.js */ \"./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/canonize.js\");\n/* harmony import */ var _createVerifier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createVerifier.js */ \"./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/createVerifier.js\");\n/* harmony import */ var _name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./name.js */ \"./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/name.js\");\n/* harmony import */ var _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./requiredAlgorithm.js */ \"./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/requiredAlgorithm.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n*/\n\n\n\n\n\nconst cryptosuite = {\n  canonize: _canonize_js__WEBPACK_IMPORTED_MODULE_0__.canonize,\n  createVerifier: _createVerifier_js__WEBPACK_IMPORTED_MODULE_1__.createVerifier,\n  name: _name_js__WEBPACK_IMPORTED_MODULE_2__.name,\n  requiredAlgorithm: _requiredAlgorithm_js__WEBPACK_IMPORTED_MODULE_3__.requiredAlgorithm,\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/name.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/name.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   name: () => (/* binding */ name)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst name = 'eddsa-rdfc-2022';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/name.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/requiredAlgorithm.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/requiredAlgorithm.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   requiredAlgorithm: () => (/* binding */ requiredAlgorithm)\n/* harmony export */ });\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\nconst requiredAlgorithm = 'Ed25519';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/eddsa-rdfc-2022-cryptosuite/lib/requiredAlgorithm.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialIssuancePurpose: () => (/* binding */ CredentialIssuancePurpose)\n/* harmony export */ });\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/*!\n * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\nconst {purposes: {AssertionProofPurpose}} = jsonld_signatures__WEBPACK_IMPORTED_MODULE_0__;\n\n/**\n * Creates a proof purpose that will validate whether or not the verification\n * method in a proof was authorized by its declared controller for the\n * proof's purpose.\n */\nclass CredentialIssuancePurpose extends AssertionProofPurpose {\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} [options.controller] - The description of the controller,\n   *   if it is not to be dereferenced via a `documentLoader`.\n   * @param {string|Date|number} [options.date] - The expected date for\n   *   the creation of the proof.\n   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number\n   *   of seconds that the date on the signature can deviate from.\n   */\n  constructor({controller, date, maxTimestampDelta} = {}) {\n    super({controller, date, maxTimestampDelta});\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param {object} proof - The proof to validate.\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document whose signature is\n   *   being verified.\n   * @param {object} options.suite - Signature suite used in\n   *   the proof.\n   * @param {string} options.verificationMethod - Key id URL to the paired\n   *   public key.\n   * @param {object} [options.documentLoader] - A document loader.\n   *\n   * @throws {Error} If verification method not authorized by controller.\n   * @throws {Error} If proof's created timestamp is out of range.\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.\n   */\n  async validate(proof, {\n    document, suite, verificationMethod, documentLoader\n  }) {\n    try {\n      const result = await super.validate(proof, {\n        document, suite, verificationMethod, documentLoader\n      });\n\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const issuer = jsonld__WEBPACK_IMPORTED_MODULE_1__.getValues(document, 'issuer');\n\n      if(!issuer || issuer.length === 0) {\n        throw new Error('Credential issuer is required.');\n      }\n\n      const issuerId = typeof issuer[0] === 'string' ? issuer[0] : issuer[0].id;\n\n      if(result.controller.id !== issuerId) {\n        throw new Error(\n          'Credential issuer must match the verification method controller.');\n      }\n\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/contexts/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/contexts/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   contexts: () => (/* binding */ contexts)\n/* harmony export */ });\n/* harmony import */ var credentials_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! credentials-context */ \"./node_modules/credentials-context/dist/context.esm.js\");\n/* harmony import */ var _digitalbazaar_credentials_v2_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/credentials-v2-context */ \"./node_modules/@digitalbazaar/credentials-v2-context/js/index.js\");\n/*!\n * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\nconst contexts = new Map();\n\n// adds the _contexts to the contexts map\nconst addContexts = _contexts => {\n  for(const [url, context] of _contexts.entries()) {\n    contexts.set(url, context);\n  }\n};\n\naddContexts(credentials_context__WEBPACK_IMPORTED_MODULE_0__.contexts);\naddContexts(_digitalbazaar_credentials_v2_context__WEBPACK_IMPORTED_MODULE_1__.contexts);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/contexts/index.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/documentLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/documentLoader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   documentLoader: () => (/* binding */ documentLoader)\n/* harmony export */ });\n/* harmony import */ var _contexts_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contexts/index.js */ \"./node_modules/@digitalbazaar/vc/lib/contexts/index.js\");\n/*!\n * Copyright (c) 2019-2023 Digital Bazaar, Inc. All rights reserved.\n */\n// load locally embedded contexts\n\n\nasync function documentLoader(url) {\n  const context = _contexts_index_js__WEBPACK_IMPORTED_MODULE_0__.contexts.get(url);\n  if(context !== undefined) {\n    return {\n      contextUrl: null,\n      documentUrl: url,\n      document: context\n    };\n  }\n  throw new Error(`Document loader unable to load URL \"${url}\".`);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/documentLoader.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/helpers.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CREDENTIALS_CONTEXT_V1_URL: () => (/* binding */ CREDENTIALS_CONTEXT_V1_URL),\n/* harmony export */   CREDENTIALS_CONTEXT_V2_URL: () => (/* binding */ CREDENTIALS_CONTEXT_V2_URL),\n/* harmony export */   assertCredentialContext: () => (/* binding */ assertCredentialContext),\n/* harmony export */   assertDateString: () => (/* binding */ assertDateString),\n/* harmony export */   checkContextVersion: () => (/* binding */ checkContextVersion),\n/* harmony export */   dateRegex: () => (/* binding */ dateRegex)\n/* harmony export */ });\n/* harmony import */ var credentials_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! credentials-context */ \"./node_modules/credentials-context/dist/context.esm.js\");\n/* harmony import */ var _digitalbazaar_credentials_v2_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @digitalbazaar/credentials-v2-context */ \"./node_modules/@digitalbazaar/credentials-v2-context/js/index.js\");\n/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\nconst {constants: {CREDENTIALS_CONTEXT_V1_URL}} = credentials_context__WEBPACK_IMPORTED_MODULE_0__;\nconst {\n  constants: {\n    CONTEXT_URL: CREDENTIALS_CONTEXT_V2_URL\n  }\n} = _digitalbazaar_credentials_v2_context__WEBPACK_IMPORTED_MODULE_1__;\n// Z and T must be uppercase\n// xml schema date time RegExp\n// @see https://www.w3.org/TR/xmlschema11-2/#dateTime\nconst dateRegex = new RegExp(\n  '-?([1-9][0-9]{3,}|0[0-9]{3})' +\n  '-(0[1-9]|1[0-2])' +\n  '-(0[1-9]|[12][0-9]|3[01])' +\n  'T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))' +\n  '(Z|(\\\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?');\n\n// entries should be in ascending version order\n// so v1 is entry 0\nconst credentialContextUrls = new Set([\n  CREDENTIALS_CONTEXT_V1_URL,\n  CREDENTIALS_CONTEXT_V2_URL\n]);\n\n/**\n * Asserts that a context array's first item is a credentials context.\n *\n * @param {object} options - Options.\n * @param {Array} options.context - An array of contexts.\n *\n * @throws {Error} - Throws if the first context\n *   is not a credentials context.\n *\n * @returns {undefined}\n */\nfunction assertCredentialContext({context}) {\n  // ensure first context is credentials context url\n  if(credentialContextUrls.has(context[0]) === false) {\n    // throw if the first context is not a credentials context\n    throw new Error(\n      `\"${CREDENTIALS_CONTEXT_V1_URL}\" or \"${CREDENTIALS_CONTEXT_V2_URL}\"` +\n      ' needs to be first in the list of contexts.');\n  }\n}\n\n/**\n * Throws if a Date is not in the correct format.\n *\n * @param {object} options - Options.\n * @param {object} options.credential - A VC.\n * @param {string} options.prop - A prop in the object.\n *\n * @throws {Error} Throws if the date is not a proper date string.\n * @returns {undefined}\n */\nfunction assertDateString({credential, prop}) {\n  const value = credential[prop];\n  if(!dateRegex.test(value)) {\n    throw new Error(`\"${prop}\" must be a valid date: ${value}`);\n  }\n}\n\n/**\n * Turns the first context in a VC into a numbered version.\n *\n * @param {object} options - Options.\n * @param {object} options.credential - A VC.\n *\n * @returns {number} A number representing the version.\n */\nfunction getContextVersion({credential} = {}) {\n  const firstContext = credential?.['@context']?.[0];\n  return [...credentialContextUrls].indexOf(firstContext) + 1;\n}\n\n/**\n * Checks if a VC is using a specific context version.\n *\n * @param {object} options - Options.\n * @param {object} options.credential - A VC.\n * @param {number} options.version - A VC Context version\n *\n * @returns {boolean} If the first context matches the version.\n */\nfunction checkContextVersion({credential, version}) {\n  return getContextVersion({credential}) === version;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/helpers.js?");

/***/ }),

/***/ "./node_modules/@digitalbazaar/vc/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@digitalbazaar/vc/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialIssuancePurpose: () => (/* reexport safe */ _CredentialIssuancePurpose_js__WEBPACK_IMPORTED_MODULE_2__.CredentialIssuancePurpose),\n/* harmony export */   _checkCredential: () => (/* binding */ _checkCredential),\n/* harmony export */   _checkPresentation: () => (/* binding */ _checkPresentation),\n/* harmony export */   createPresentation: () => (/* binding */ createPresentation),\n/* harmony export */   dateRegex: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_0__.dateRegex),\n/* harmony export */   defaultDocumentLoader: () => (/* binding */ defaultDocumentLoader),\n/* harmony export */   derive: () => (/* binding */ derive),\n/* harmony export */   issue: () => (/* binding */ issue),\n/* harmony export */   signPresentation: () => (/* binding */ signPresentation),\n/* harmony export */   verify: () => (/* binding */ verify),\n/* harmony export */   verifyCredential: () => (/* binding */ verifyCredential)\n/* harmony export */ });\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ \"./node_modules/@digitalbazaar/vc/lib/helpers.js\");\n/* harmony import */ var _documentLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documentLoader.js */ \"./node_modules/@digitalbazaar/vc/lib/documentLoader.js\");\n/* harmony import */ var _CredentialIssuancePurpose_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CredentialIssuancePurpose.js */ \"./node_modules/@digitalbazaar/vc/lib/CredentialIssuancePurpose.js\");\n/* harmony import */ var jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsonld-signatures */ \"./node_modules/jsonld-signatures/lib/jsonld-signatures.js\");\n/* harmony import */ var jsonld__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jsonld */ \"./node_modules/jsonld/lib/jsonld.js\");\n/**\n * A JavaScript implementation of Verifiable Credentials.\n *\n * @author Dave Longley\n * @author David I. Lehn\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2017-2023 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n\n\n\n\nconst {AssertionProofPurpose, AuthenticationProofPurpose} = jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.purposes;\n\nconst defaultDocumentLoader = jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.extendContextLoader(_documentLoader_js__WEBPACK_IMPORTED_MODULE_1__.documentLoader);\n\n\n/**\n * @typedef {object} LinkedDataSignature\n */\n\n/**\n * @typedef {object} Presentation\n */\n\n/**\n * @typedef {object} ProofPurpose\n */\n\n/**\n * @typedef {object} VerifiableCredential\n */\n\n/**\n * @typedef {object} VerifiablePresentation\n */\n\n/**\n * @typedef {object} VerifyPresentationResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} presentationResult\n * @property {Array} credentialResults\n * @property {object} error\n */\n\n/**\n * @typedef {object} VerifyCredentialResult\n * @property {boolean} verified - True if verified, false if not.\n * @property {object} statusResult\n * @property {Array} results\n * @property {object} error\n */\n\n/**\n * Issues a verifiable credential (by taking a base credential document,\n * and adding a digital signature to it).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.credential - Base credential document.\n * @param {LinkedDataSignature} options.suite - Signature suite (with private\n *   key material or an API to use it), passed in to sign().\n *\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created.\n *\n * Other optional params passed to `sign()`:\n * @param {object} [options.documentLoader] - A document loader.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nasync function issue({\n  credential, suite,\n  purpose = new _CredentialIssuancePurpose_js__WEBPACK_IMPORTED_MODULE_2__.CredentialIssuancePurpose(),\n  documentLoader = defaultDocumentLoader,\n  now\n} = {}) {\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor\n  if(!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  if(!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  if(!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n  if((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.checkContextVersion)({\n    credential,\n    version: 1.0\n  }) && !credential.issuanceDate) {\n    const now = (new Date()).toJSON();\n    credential.issuanceDate = `${now.slice(0, now.length - 5)}Z`;\n  }\n\n  // run common credential checks\n  _checkCredential({credential, now, mode: 'issue'});\n\n  return jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.sign(credential, {purpose, documentLoader, suite});\n}\n\n/**\n * Derives a proof from the given verifiable credential, resulting in a new\n * verifiable credential. This method is usually used to generate selective\n * disclosure and / or unlinkable proofs.\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {object} options.verifiableCredential - The verifiable credential\n *   containing a base proof to derive another proof from.\n * @param {LinkedDataSignature} options.suite - Derived proof signature suite.\n *\n * Other optional params passed to `derive()`:\n * @param {object} [options.documentLoader] - A document loader.\n *\n * @throws {Error} If missing required properties.\n *\n * @returns {Promise<VerifiableCredential>} Resolves on completion.\n */\nasync function derive({\n  verifiableCredential, suite,\n  documentLoader = defaultDocumentLoader\n} = {}) {\n  if(!verifiableCredential) {\n    throw new TypeError(\n      '\"verifiableCredential\" parameter is required for deriving.');\n  }\n  if(!suite) {\n    throw new TypeError('\"suite\" parameter is required for deriving.');\n  }\n\n  // run common credential checks\n  _checkCredential({credential: verifiableCredential, mode: 'issue'});\n\n  return jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.derive(verifiableCredential, {\n    purpose: new AssertionProofPurpose(),\n    documentLoader,\n    suite\n  });\n}\n\n/**\n * Verifies a verifiable presentation:\n *   - Checks that the presentation is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options to use.\n *\n * @param {VerifiablePresentation} options.presentation - Verifiable\n *   presentation, signed or unsigned, that may contain within it a\n *   verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n *\n * or a default purpose will be created with params:\n * @param {string} [options.challenge] - Required if purpose is not passed in.\n * @param {string} [options.controller] - A controller.\n * @param {string} [options.domain] - A domain.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function verify(options = {}) {\n  const {presentation} = options;\n  try {\n    if(!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.');\n    }\n    return _verifyPresentation(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{presentation, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential:\n *   - Checks that the credential is well-formed\n *   - Checks the proofs (for example, checks digital signatures against the\n *     provided public keys).\n *\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - One or\n *   more signature suites that are supported by the caller's use case. This is\n *   an explicit design decision -- the calling code must specify which\n *   signature types (ed25519, RSA, etc) are allowed.\n *   Although it is expected that the secure resolution/fetching of the public\n *   key material (to verify against) is to be handled by the documentLoader,\n *   the suite param can optionally include the key directly.\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - Optional\n *   proof purpose (a default one will be created if not passed in).\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function verifyCredential(options = {}) {\n  const {credential} = options;\n  try {\n    if(!credential) {\n      throw new TypeError(\n        'A \"credential\" property is required for verifying.');\n    }\n    return await _verifyCredential(options);\n  } catch(error) {\n    return {\n      verified: false,\n      results: [{credential, verified: false, error}],\n      error\n    };\n  }\n}\n\n/**\n * Verifies a verifiable credential.\n *\n * @private\n * @param {object} [options={}] - The options.\n *\n * @param {object} options.credential - Verifiable credential.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If required parameters are missing (in `_checkCredential`).\n *\n * @param {CredentialIssuancePurpose} [options.purpose] - A purpose.\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n *\n * @returns {Promise<VerifyCredentialResult>} The verification result.\n */\nasync function _verifyCredential(options = {}) {\n  const {credential, checkStatus, now} = options;\n\n  // run common credential checks\n  _checkCredential({credential, now});\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if(credential.credentialStatus && typeof options.checkStatus !== 'function') {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n      '\"credentialStatus\".');\n  }\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  const {controller} = options;\n  const purpose = options.purpose || new _CredentialIssuancePurpose_js__WEBPACK_IMPORTED_MODULE_2__.CredentialIssuancePurpose({\n    controller\n  });\n\n  const result = await jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.verify(\n    credential, {...options, purpose, documentLoader});\n\n  // if verification has already failed, skip status check\n  if(!result.verified) {\n    return result;\n  }\n\n  if(credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if(!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an unsigned presentation from a given verifiable credential.\n *\n * @param {object} options - Options to use.\n * @param {object|Array<object>} [options.verifiableCredential] - One or more\n *   verifiable credential.\n * @param {string} [options.id] - Optional VP id.\n * @param {string} [options.holder] - Optional presentation holder url.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n * @param {number} [options.version = 2.0] - The VC context version to use.\n *\n * @throws {TypeError} If verifiableCredential param is missing.\n * @throws {Error} If the credential (or the presentation params) are missing\n *   required properties.\n *\n * @returns {Presentation} The credential wrapped inside of a\n *   VerifiablePresentation.\n */\nfunction createPresentation({\n  verifiableCredential, id, holder, now, version = 2.0\n} = {}) {\n  const initialContext = (version === 2.0) ? _helpers_js__WEBPACK_IMPORTED_MODULE_0__.CREDENTIALS_CONTEXT_V2_URL :\n    _helpers_js__WEBPACK_IMPORTED_MODULE_0__.CREDENTIALS_CONTEXT_V1_URL;\n  const presentation = {\n    '@context': [initialContext],\n    type: ['VerifiablePresentation']\n  };\n  if(verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for(const credential of credentials) {\n      _checkCredential({credential, now});\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if(id) {\n    presentation.id = id;\n  }\n  if(holder) {\n    presentation.holder = holder;\n  }\n\n  _checkPresentation(presentation);\n\n  return presentation;\n}\n\n/**\n * Signs a given presentation.\n *\n * @param {object} [options={}] - Options to use.\n *\n * Required:\n * @param {Presentation} options.presentation - A presentation.\n * @param {LinkedDataSignature} options.suite - passed in to sign()\n *\n * Either pass in a ProofPurpose, or a default one will be created with params:\n * @param {ProofPurpose} [options.purpose] - A ProofPurpose. If not specified,\n *   a default purpose will be created with the domain and challenge options.\n *\n * @param {string} [options.domain] - A domain.\n * @param {string} options.challenge - A required challenge.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n *\n * @returns {Promise<{VerifiablePresentation}>} A VerifiablePresentation with\n *   a proof.\n */\nasync function signPresentation(options = {}) {\n  const {presentation, domain, challenge} = options;\n  const purpose = options.purpose || new AuthenticationProofPurpose({\n    domain,\n    challenge\n  });\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  return jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.sign(presentation, {...options, purpose, documentLoader});\n}\n\n/**\n * Verifies that the VerifiablePresentation is well formed, and checks the\n * proof signature if it's present. Also verifies all the VerifiableCredentials\n * that are present in the presentation, if any.\n *\n * @param {object} [options={}] - The options.\n * @param {VerifiablePresentation} options.presentation - A\n *   VerifiablePresentation.\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite - See the\n *   definition in the `verify()` docstring, for this param.\n *\n * @param {boolean} [options.unsignedPresentation=false] - By default, this\n *   function assumes that a presentation is signed (and will return an error if\n *   a `proof` section is missing). Set this to `true` if you're using an\n *   unsigned presentation.\n *\n * Either pass in a proof purpose,\n * @param {AuthenticationProofPurpose} [options.presentationPurpose] - A\n *   ProofPurpose. If not specified, a default purpose will be created with\n *   the challenge, controller, and domain options.\n *\n * @param {string} [options.challenge] - A challenge. Required if purpose is\n *   not passed in.\n * @param {string} [options.controller] - A controller. Required if purpose is\n *   not passed in.\n * @param {string} [options.domain] - A domain. Required if purpose is not\n *   passed in.\n *\n * @param {Function} [options.documentLoader] - A document loader.\n * @param {Function} [options.checkStatus] - Optional function for checking\n *   credential status if `credentialStatus` is present on the credential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n *\n * @throws {Error} If presentation is missing required params.\n *\n * @returns {Promise<VerifyPresentationResult>} The verification result.\n */\nasync function _verifyPresentation(options = {}) {\n  const {presentation, unsignedPresentation} = options;\n\n  _checkPresentation(presentation);\n\n  const documentLoader = options.documentLoader || defaultDocumentLoader;\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults;\n  let verified = true;\n  const credentials = jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(presentation, 'verifiableCredential');\n  if(credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(credentials.map(credential => {\n      return verifyCredential({...options, credential, documentLoader});\n    }));\n\n    for(const [i, credentialResult] of credentialResults.entries()) {\n      credentialResult.credentialId = credentials[i].id;\n    }\n\n    const allCredentialsVerified = credentialResults.every(r => r.verified);\n    if(!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if(unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return {verified, results: [presentation], credentialResults};\n  }\n\n  const {controller, domain, challenge} = options;\n  if(!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.');\n  }\n\n  const purpose = options.presentationPurpose ||\n    new AuthenticationProofPurpose({controller, domain, challenge});\n\n  const presentationResult = await jsonld_signatures__WEBPACK_IMPORTED_MODULE_3__.verify(\n    presentation, {...options, purpose, documentLoader});\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error\n  };\n}\n\n/**\n * @param {string|object} obj - Either an object with an id property\n *   or a string that is an id.\n * @returns {string|undefined} Either an id or undefined.\n * @private\n */\nfunction _getId(obj) {\n  if(typeof obj === 'string') {\n    return obj;\n  }\n\n  if(!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\n// export for testing\n/**\n * @param {object} presentation - An object that could be a presentation.\n *\n * @throws {Error}\n * @private\n */\nfunction _checkPresentation(presentation) {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context']) ?\n    presentation['@context'] : [presentation['@context']];\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertCredentialContext)({context});\n\n  const types = jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(presentation, 'type');\n\n  // check type presence\n  if(!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n}\n\n// these props of a VC must be an object with a type\n// if present in a VC or VP\nconst mustHaveType = [\n  'proof',\n  'credentialStatus',\n  'termsOfUse',\n  'evidence'\n];\n\n// export for testing\n/**\n * @param {object} options - The options.\n * @param {object} options.credential - An object that could be a\n *   VerifiableCredential.\n * @param {string|Date} [options.now] - A string representing date time in\n *   ISO 8601 format or an instance of Date. Defaults to current date time.\n * @param {string} [options.mode] - The mode of operation for this\n *   validation function, either `issue` or `verify`.\n *\n * @throws {Error}\n * @private\n */\nfunction _checkCredential({\n  credential, now = new Date(), mode = 'verify'\n} = {}) {\n  if(typeof now === 'string') {\n    now = new Date(now);\n  }\n  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertCredentialContext)({context: credential['@context']});\n\n  // check type presence and cardinality\n  if(!credential.type) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if(!jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  _checkCredentialSubjects({credential});\n\n  if(!credential.issuer) {\n    throw new Error('\"issuer\" property is required.');\n  }\n  if((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.checkContextVersion)({credential, version: 1.0})) {\n    // check issuanceDate exists\n    if(!credential.issuanceDate) {\n      throw new Error('\"issuanceDate\" property is required.');\n    }\n    // check issuanceDate format on issue\n    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertDateString)({credential, prop: 'issuanceDate'});\n\n    // check issuanceDate cardinality\n    if(jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(credential, 'issuanceDate').length > 1) {\n      throw new Error('\"issuanceDate\" property can only have one value.');\n    }\n    // optionally check expirationDate\n    if('expirationDate' in credential) {\n      // check if `expirationDate` property is a date\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertDateString)({credential, prop: 'expirationDate'});\n      if(mode === 'verify') {\n        // check if `now` is after `expirationDate`\n        if(now > new Date(credential.expirationDate)) {\n          throw new Error('Credential has expired.');\n        }\n      }\n    }\n    // check if `now` is before `issuanceDate` on verification\n    if(mode === 'verify') {\n      const issuanceDate = new Date(credential.issuanceDate);\n      if(now < issuanceDate) {\n        throw new Error(\n          `The current date time (${now.toISOString()}) is before the ` +\n          `\"issuanceDate\" (${credential.issuanceDate}).`);\n      }\n    }\n  }\n  if((0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.checkContextVersion)({credential, version: 2.0})) {\n    // check if 'validUntil' and 'validFrom'\n    let {validUntil, validFrom} = credential;\n    if(validUntil) {\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertDateString)({credential, prop: 'validUntil'});\n      if(mode === 'verify') {\n        validUntil = new Date(credential.validUntil);\n        if(now > validUntil) {\n          throw new Error(\n            `The current date time (${now.toISOString()}) is after ` +\n            `\"validUntil\" (${credential.validUntil}).`);\n        }\n      }\n    }\n    if(validFrom) {\n      (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.assertDateString)({credential, prop: 'validFrom'});\n      if(mode === 'verify') {\n      // check if `now` is before `validFrom`\n        validFrom = new Date(credential.validFrom);\n        if(now < validFrom) {\n          throw new Error(\n            `The current date time (${now.toISOString()}) is before ` +\n            `\"validFrom\" (${credential.validFrom}).`);\n        }\n      }\n    }\n  }\n  // check issuer cardinality\n  if(jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  if('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if(!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    _validateUriId({id: issuer, propertyName: 'issuer'});\n  }\n\n  // check credentialStatus\n  jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(credential, 'credentialStatus').forEach(cs => {\n    // check if optional \"id\" is a URL\n    if('id' in cs) {\n      _validateUriId({id: cs.id, propertyName: 'credentialStatus.id'});\n    }\n\n    // check \"type\" present\n    if(!cs.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  });\n\n  // check evidences are URLs\n  jsonld__WEBPACK_IMPORTED_MODULE_4__.getValues(credential, 'evidence').forEach(evidence => {\n    const evidenceId = _getId(evidence);\n    if(evidenceId) {\n      _validateUriId({id: evidenceId, propertyName: 'evidence'});\n    }\n  });\n\n  // check if properties that require a type are\n  // defined, objects, and objects with types\n  for(const prop of mustHaveType) {\n    if(prop in credential) {\n      const _value = credential[prop];\n      if(Array.isArray(_value)) {\n        _value.forEach(entry => _checkTypedObject(entry, prop));\n        continue;\n      }\n      _checkTypedObject(_value, prop);\n    }\n  }\n}\n\n/**\n * @private\n * Checks that a property is non-empty object with\n * property type.\n *\n * @param {object} obj - A potential object.\n * @param {string} name - The name of the property.\n *\n * @throws {Error} if the property is not an object with a type.\n *\n * @returns {undefined} - Returns on success.\n */\nfunction _checkTypedObject(obj, name) {\n  if(!isObject(obj)) {\n    throw new Error(`property \"${name}\" must be an object.`);\n  }\n  if(_emptyObject(obj)) {\n    throw new Error(`property \"${name}\" can not be an empty object.`);\n  }\n  if(!('type' in obj)) {\n    throw new Error(`property \"${name}\" must have property type.`);\n  }\n}\n\n/**\n * @private\n * Takes in a credential and checks the credentialSubject(s)\n *\n * @param {object} options - Options.\n * @param {object} options.credential - The credential to check.\n *\n * @throws {Error} error - Throws on errors in the credential subject.\n *\n * @returns {undefined} - Returns on success.\n*/\nfunction _checkCredentialSubjects({credential}) {\n  if(!credential?.credentialSubject) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n  if(Array.isArray(credential?.credentialSubject)) {\n    return credential?.credentialSubject.map(\n      subject => _checkCredentialSubject({subject}));\n  }\n  return _checkCredentialSubject({subject: credential?.credentialSubject});\n}\n\n/**\n * @private\n *\n * Checks a credential subject is valid.\n *\n * @param {object} options - Options.\n * @param {object} options.subject - A potential credential subject.\n *\n * @throws {Error} If the credentialSubject is not valid.\n *\n * @returns {undefined} Returns on success.\n */\nfunction _checkCredentialSubject({subject}) {\n  if(isObject(subject) === false) {\n    throw new Error('\"credentialSubject\" must be a non-null object.');\n  }\n  if(_emptyObject(subject)) {\n    throw new Error('\"credentialSubject\" must make a claim.');\n  }\n  // If credentialSubject.id is present and is not a URI, reject it\n  if(subject.id) {\n    _validateUriId({\n      id: subject.id, propertyName: 'credentialSubject.id'\n    });\n  }\n}\n\n/**\n * @private\n * Checks if parameter is an object.\n *\n * @param {object} obj - A potential object.\n *\n * @returns {boolean} - Returns false if not an object or null.\n */\nfunction isObject(obj) {\n  // return false for null even though it has type object\n  if(obj === null) {\n    return false;\n  }\n  // if something has type object and is not null return true\n  if((typeof obj) === 'object') {\n    return true;\n  }\n  // return false for strings, symbols, etc.\n  return false;\n}\n\n/**\n * @private\n * Is it an empty object?\n *\n * @param {object} obj - A potential object.\n *\n * @returns {boolean} - Is it empty?\n */\nfunction _emptyObject(obj) {\n  // if the parameter is not an object return true\n  // as a non-object is an empty object\n  if(!isObject(obj)) {\n    return true;\n  }\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * @private\n *\n * Validates if an ID is a URL.\n *\n * @param {object} options - Options.\n * @param {string} options.id - the id.\n * @param {string} options.propertyName - The property name.\n *\n * @throws {Error} Throws if an id is not a URL.\n *\n * @returns {undefined} Returns on success.\n */\nfunction _validateUriId({id, propertyName}) {\n  let parsed;\n  try {\n    parsed = new URL(id);\n  } catch(e) {\n    const error = new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n    error.cause = e;\n    throw error;\n  }\n\n  if(!parsed.protocol) {\n    throw new TypeError(`\"${propertyName}\" must be a URI: \"${id}\".`);\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@digitalbazaar/vc/lib/index.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/bls.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/bls.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls: () => (/* binding */ bls)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n\n\n// prettier-ignore\n\n\n// prettier-ignore\nconst _2n = BigInt(2), _3n = BigInt(3);\nfunction bls(CURVE) {\n    // Fields are specific for curve, so for now we'll need to pass them with opts\n    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n    const BLS_X_LEN = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(CURVE.params.x);\n    // Pre-compute coefficients for sparse multiplication\n    // Point addition and point double calculations is reused for coefficients\n    function calcPairingPrecomputes(p) {\n        const { x, y } = p;\n        // prettier-ignore\n        const Qx = x, Qy = y, Qz = Fp2.ONE;\n        // prettier-ignore\n        let Rx = Qx, Ry = Qy, Rz = Qz;\n        let ell_coeff = [];\n        for (let i = BLS_X_LEN - 2; i >= 0; i--) {\n            // Double\n            let t0 = Fp2.sqr(Ry); // Ry\n            let t1 = Fp2.sqr(Rz); // Rz\n            let t2 = Fp2.multiplyByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n            let t3 = Fp2.mul(t2, _3n); // 3 * T2\n            let t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz) - T1 - T0\n            ell_coeff.push([\n                Fp2.sub(t2, t0), // T2 - T0\n                Fp2.mul(Fp2.sqr(Rx), _3n), // 3 * Rx\n                Fp2.neg(t4), // -T4\n            ]);\n            Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2\n            Ry = Fp2.sub(Fp2.sqr(Fp2.div(Fp2.add(t0, t3), _2n)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2) - 3 * T2\n            Rz = Fp2.mul(t0, t4); // T0 * T4\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(CURVE.params.x, i)) {\n                // Addition\n                let t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n                let t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n                ell_coeff.push([\n                    Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)), // T0 * Qx - T1 * Qy\n                    Fp2.neg(t0), // -T0\n                    t1, // T1\n                ]);\n                let t2 = Fp2.sqr(t1); // T1\n                let t3 = Fp2.mul(t2, t1); // T2 * T1\n                let t4 = Fp2.mul(t2, Rx); // T2 * Rx\n                let t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0 * Rz\n                Rx = Fp2.mul(t1, t5); // T1 * T5\n                Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n                Rz = Fp2.mul(Rz, t3); // Rz * T3\n            }\n        }\n        return ell_coeff;\n    }\n    function millerLoop(ell, g1) {\n        const { x } = CURVE.params;\n        const Px = g1[0];\n        const Py = g1[1];\n        let f12 = Fp12.ONE;\n        for (let j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++) {\n            const E = ell[j];\n            f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(x, i)) {\n                j += 1;\n                const F = ell[j];\n                f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));\n            }\n            if (i !== 0)\n                f12 = Fp12.sqr(f12);\n        }\n        return Fp12.conjugate(f12);\n    }\n    const utils = {\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.getMinHashLength)(Fr.ORDER);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mapHashToField)(CURVE.randomBytes(length), Fr.ORDER);\n        },\n        calcPairingPrecomputes,\n    };\n    // Point on G1 curve: (x, y)\n    const G1_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G1 });\n    const G1 = Object.assign(G1_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.createHasher)(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G1.htfDefaults,\n    }));\n    function pairingPrecomputes(point) {\n        const p = point;\n        if (p._PPRECOMPUTES)\n            return p._PPRECOMPUTES;\n        p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());\n        return p._PPRECOMPUTES;\n    }\n    // TODO: export\n    // function clearPairingPrecomputes(point: G2) {\n    //   const p = point as G2 & withPairingPrecomputes;\n    //   p._PPRECOMPUTES = undefined;\n    // }\n    // Point on G2 curve (complex numbers): (x, x+i), (y, y+i)\n    const G2_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)({ n: Fr.ORDER, ...CURVE.G2 });\n    const G2 = Object.assign(G2_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_3__.createHasher)(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G2.htfDefaults,\n    }));\n    const { ShortSignature } = CURVE.G1;\n    const { Signature } = CURVE.G2;\n    // Calculates bilinear pairing\n    function pairing(Q, P, withFinalExponent = true) {\n        if (Q.equals(G1.ProjectivePoint.ZERO) || P.equals(G2.ProjectivePoint.ZERO))\n            throw new Error('pairing is not available for ZERO point');\n        Q.assertValidity();\n        P.assertValidity();\n        // Performance: 9ms for millerLoop and ~14ms for exp.\n        const Qa = Q.toAffine();\n        const looped = millerLoop(pairingPrecomputes(P), [Qa.x, Qa.y]);\n        return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;\n    }\n    function normP1(point) {\n        return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n    }\n    function normP1Hash(point, htfOpts) {\n        return point instanceof G1.ProjectivePoint\n            ? point\n            : G1.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('point', point), htfOpts);\n    }\n    function normP2(point) {\n        return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n    }\n    function normP2Hash(point, htfOpts) {\n        return point instanceof G2.ProjectivePoint\n            ? point\n            : G2.hashToCurve((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('point', point), htfOpts);\n    }\n    // Multiplies generator (G1) by private key.\n    // P = pk x G\n    function getPublicKey(privateKey) {\n        return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    // Multiplies generator (G2) by private key.\n    // P = pk x G\n    function getPublicKeyForShortSignatures(privateKey) {\n        return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n        const msgPoint = normP2Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G2.ProjectivePoint)\n            return sigPoint;\n        return Signature.toRawBytes(sigPoint);\n    }\n    function signShortSignature(message, privateKey, htfOpts) {\n        const msgPoint = normP1Hash(message, htfOpts);\n        msgPoint.assertValidity();\n        const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n        if (message instanceof G1.ProjectivePoint)\n            return sigPoint;\n        return ShortSignature.toRawBytes(sigPoint);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(P, H(m)) == e(G, S)\n    function verify(signature, message, publicKey, htfOpts) {\n        const P = normP1(publicKey);\n        const Hm = normP2Hash(message, htfOpts);\n        const G = G1.ProjectivePoint.BASE;\n        const S = normP2(signature);\n        // Instead of doing 2 exponentiations, we use property of billinear maps\n        // and do one exp after multiplying 2 points.\n        const ePHm = pairing(P.negate(), Hm, false);\n        const eGS = pairing(G, S, false);\n        const exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n    // e(S, G) == e(H(m), P)\n    function verifyShortSignature(signature, message, publicKey, htfOpts) {\n        const P = normP2(publicKey);\n        const Hm = normP1Hash(message, htfOpts);\n        const G = G2.ProjectivePoint.BASE;\n        const S = normP1(signature);\n        // Instead of doing 2 exponentiations, we use property of billinear maps\n        // and do one exp after multiplying 2 points.\n        const eHmP = pairing(Hm, P, false);\n        const eSG = pairing(S, G.negate(), false);\n        const exp = Fp12.finalExponentiate(Fp12.mul(eSG, eHmP));\n        return Fp12.eql(exp, Fp12.ONE);\n    }\n    function aggregatePublicKeys(publicKeys) {\n        if (!publicKeys.length)\n            throw new Error('Expected non-empty array');\n        const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (publicKeys[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        // toRawBytes ensures point validity\n        return aggAffine.toRawBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G2.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return Signature.toRawBytes(aggAffine);\n    }\n    function aggregateShortSignatures(signatures) {\n        if (!signatures.length)\n            throw new Error('Expected non-empty array');\n        const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n        const aggAffine = agg; //.toAffine();\n        if (signatures[0] instanceof G1.ProjectivePoint) {\n            aggAffine.assertValidity();\n            return aggAffine;\n        }\n        return ShortSignature.toRawBytes(aggAffine);\n    }\n    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n    function verifyBatch(signature, messages, publicKeys, htfOpts) {\n        // @ts-ignore\n        // console.log('verifyBatch', bytesToHex(signature as any), messages, publicKeys.map(bytesToHex));\n        if (!messages.length)\n            throw new Error('Expected non-empty messages array');\n        if (publicKeys.length !== messages.length)\n            throw new Error('Pubkey count should equal msg count');\n        const sig = normP2(signature);\n        const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n        const nPublicKeys = publicKeys.map(normP1);\n        try {\n            const paired = [];\n            for (const message of new Set(nMessages)) {\n                const groupPublicKey = nMessages.reduce((groupPublicKey, subMessage, i) => subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey, G1.ProjectivePoint.ZERO);\n                // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);\n                // Possible to batch pairing for same msg with different groupPublicKey here\n                paired.push(pairing(groupPublicKey, message, false));\n            }\n            paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));\n            const product = paired.reduce((a, b) => Fp12.mul(a, b), Fp12.ONE);\n            const exp = Fp12.finalExponentiate(product);\n            return Fp12.eql(exp, Fp12.ONE);\n        }\n        catch {\n            return false;\n        }\n    }\n    G1.ProjectivePoint.BASE._setWindowSize(4);\n    return {\n        getPublicKey,\n        getPublicKeyForShortSignatures,\n        sign,\n        signShortSignature,\n        verify,\n        verifyBatch,\n        verifyShortSignature,\n        aggregatePublicKeys,\n        aggregateSignatures,\n        aggregateShortSignatures,\n        millerLoop,\n        pairing,\n        G1,\n        G2,\n        Signature,\n        ShortSignature,\n        fields: {\n            Fr,\n            Fp,\n            Fp2,\n            Fp6,\n            Fp12,\n        },\n        params: {\n            x: CURVE.params.x,\n            r: CURVE.params.r,\n            G1b: CURVE.G1.b,\n            G2b: CURVE.G2.b,\n        },\n        utils,\n    };\n}\n//# sourceMappingURL=bls.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/bls.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/modular.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/utils.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/abstract/weierstrass.js?");

/***/ }),

/***/ "./node_modules/@noble/curves/esm/bls12-381.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/bls12-381.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls12_381: () => (/* binding */ bls12_381)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/bls.js */ \"./node_modules/@noble/curves/esm/abstract/bls.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n// - Construct zk-SNARKs at the 120-bit security\n// - Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n//   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n//\n// ### Summary\n// 1. BLS Relies on Bilinear Pairing (expensive)\n// 2. Private Keys: 32 bytes\n// 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n// 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n//     - The signature is a point on the G2 subgroup, which is defined over a finite field\n//     with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the complex numbers).\n// 5. The 12 stands for the Embedding degree.\n//\n// ### Formulas\n// - `P = pk x G` - public keys\n// - `S = pk x H(m)` - signing\n// - `e(P, H(m)) == e(G, S)` - verification using pairings\n// - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n//\n// ### Compatibility and notes\n// 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC\n//    Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n// 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\"\n// 3. Curve security level is about 120 bits as per Barbulescu-Duquesne 2017\n//    https://hal.science/hal-01534101/file/main.pdf\n// 4. Compatible with specs:\n// [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n// [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05),\n// [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\n\n\n\n\n\n// Types\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// prettier-ignore\nconst _8n = BigInt(8), _16n = BigInt(16);\n// CURVE FIELDS\n// Finite field over p.\nconst Fp_raw = BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab');\nconst Fp = _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(Fp_raw);\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\nconst Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n});\nconst Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n});\nconst Fp2Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === 'bigint')\n        return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (acbd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n};\nconst Fp2Square = ({ c0, c1 }) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n};\n// G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),\n// where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where\n// G - 1\n// h2q\n// NOTE: ORDER was wrong!\nconst FP2_ORDER = Fp_raw * Fp_raw;\nconst Fp2 = {\n    ORDER: FP2_ORDER,\n    BITS: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER),\n    BYTES: Math.ceil((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER) / 8),\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp2, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n        // We wish to find the multiplicative inverse of a nonzero\n        // element a + bu in Fp2. We leverage an identity\n        //\n        // (a + bu)(a - bu) = a + b\n        //\n        // which holds because u = -1. This can be rewritten as\n        //\n        // (a + bu)(a - bu)/(a + b) = 1\n        //\n        // because a + b = 0 has no nonzero solutions for (a, b).\n        // This gives that (a - bu)/(a + b) is the inverse\n        // of (a + bu). Importantly, this can be computing using\n        // only a single inversion in Fp.\n        const factor = Fp.inv(Fp.create(a * a + b * b));\n        return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n        if (Fp2.eql(num, Fp2.ZERO))\n            return Fp2.ZERO; // Algo doesn't handles this case\n        // TODO: Optimize this line. It's extremely slow.\n        // Speeding this up would boost aggregateSignatures.\n        // https://eprint.iacr.org/2012/685.pdf applicable?\n        // https://github.com/zkcrypto/bls12_381/blob/080eaa74ec0e394377caa1ba302c8c121df08b07/src/fp2.rs#L250\n        // https://github.com/supranational/blst/blob/aae0c7d70b799ac269ff5edf29d8191dbd357876/src/exp2.c#L1\n        // Inspired by https://github.com/dalek-cryptography/curve25519-dalek/blob/17698df9d4c834204f83a3574143abacb4fc81a5/src/field.rs#L99\n        const candidateSqrt = Fp2.pow(num, (Fp2.ORDER + _8n) / _16n);\n        const check = Fp2.div(Fp2.sqr(candidateSqrt), num); // candidateSqrt.square().div(this);\n        const R = FP2_ROOTS_OF_UNITY;\n        const divisor = [R[0], R[2], R[4], R[6]].find((r) => Fp2.eql(r, check));\n        if (!divisor)\n            throw new Error('No root');\n        const index = R.indexOf(divisor);\n        const root = R[index / 2];\n        if (!root)\n            throw new Error('Invalid root');\n        const x1 = Fp2.div(candidateSqrt, root);\n        const x2 = Fp2.neg(x1);\n        const { re: re1, im: im1 } = Fp2.reim(x1);\n        const { re: re2, im: im2 } = Fp2.reim(x2);\n        if (im1 > im2 || (im1 === im2 && re1 > re2))\n            return x1;\n        return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x) => {\n        const { re: x0, im: x1 } = Fp2.reim(x);\n        const sign_0 = x0 % _2n;\n        const zero_0 = x0 === _0n;\n        const sign_1 = x1 % _2n;\n        return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b) {\n        if (b.length !== Fp2.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n        c0: Fp.cmov(c0, r0, c),\n        c1: Fp.cmov(c1, r1, c),\n    }),\n    // Specific utils\n    // toString() {\n    //   return `Fp2(${this.c0} + ${this.c1}i)`;\n    // }\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => ({ c0: Fp.sub(c0, c1), c1: Fp.add(c0, c1) }),\n    multiplyByB: ({ c0, c1 }) => {\n        let t0 = Fp.mul(c0, _4n); // 4 * c0\n        let t1 = Fp.mul(c1, _4n); // 4 * c1\n        // (T0-T1) + (T0+T1)*i\n        return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n    },\n    fromBigTuple: (tuple) => {\n        if (tuple.length !== 2)\n            throw new Error('Invalid tuple');\n        const fps = tuple.map((n) => Fp.create(n));\n        return { c0: fps[0], c1: fps[1] };\n    },\n    frobeniusMap: ({ c0, c1 }, power) => ({\n        c0,\n        c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n};\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u - ) where  = -1\nconst FP2_FROBENIUS_COEFFICIENTS = [\n    BigInt('0x1'),\n    BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n].map((item) => Fp.create(item));\n// For Fp2 roots of unity.\nconst rv1 = BigInt('0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09');\n// const ev1 =\n//   BigInt('0x699be3b8c6870965e5bf892ad5d2cc7b0e85a117402dfd83b7f4a947e02d978498255a2aaec0ac627b5afbdf1bf1c90');\n// const ev2 =\n//   BigInt('0x8157cd83046453f5dd0972b6e3949e4288020b5b8a9cc99ca07e27089a2ce2436d965026adad3ef7baba37f2183e9b5');\n// const ev3 =\n//   BigInt('0xab1c2ffdd6c253ca155231eb3e71ba044fd562f6f72bc5bad5ec46a0b7a3b0247cf08ce6c6317f40edbc653a72dee17');\n// const ev4 =\n//   BigInt('0xaa404866706722864480885d68ad0ccac1967c7544b447873cc37e0181271e006df72162a3d3e0287bf597fbf7f8fc1');\n// Eighth roots of unity, used for computing square roots in Fp2.\n// To verify or re-calculate:\n// Array(8).fill(new Fp2([1n, 1n])).map((fp2, k) => fp2.pow(Fp2.ORDER * BigInt(k) / 8n))\nconst FP2_ROOTS_OF_UNITY = [\n    [_1n, _0n],\n    [rv1, -rv1],\n    [_0n, _1n],\n    [rv1, rv1],\n    [-_1n, _0n],\n    [-rv1, rv1],\n    [_0n, -_1n],\n    [-rv1, -rv1],\n].map((pair) => Fp2.fromBigTuple(pair));\nconst Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n});\nconst Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n});\nconst Fp6Multiply = ({ c0, c1, c2 }, rhs) => {\n    if (typeof rhs === 'bigint') {\n        return {\n            c0: Fp2.mul(c0, rhs),\n            c1: Fp2.mul(c1, rhs),\n            c2: Fp2.mul(c2, rhs),\n        };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n        // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n        c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n        // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n        c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n        // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n        c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n};\nconst Fp6Square = ({ c0, c1, c2 }) => {\n    let t0 = Fp2.sqr(c0); // c0\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2\n    return {\n        c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n        c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n        // T1 + (c0 - c1 + c2) + T3 - T0 - T4\n        c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n};\nconst Fp6 = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: () => {\n        throw new Error('Not implemented');\n    },\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp6, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n    inv: ({ c0, c1, c2 }) => {\n        let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0 - c2 * c1 * (u + 1)\n        let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2 * (u + 1) - c0 * c1\n        let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1 - c0 * c2\n        // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n        let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n        return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b) => {\n        if (b.length !== Fp6.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return {\n            c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n            c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n            c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n        };\n    },\n    toBytes: ({ c0, c1, c2 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({\n        c0: Fp2.cmov(c0, r0, c),\n        c1: Fp2.cmov(c1, r1, c),\n        c2: Fp2.cmov(c2, r2, c),\n    }),\n    // Utils\n    //   fromTriple(triple: [Fp2, Fp2, Fp2]) {\n    //     return new Fp6(...triple);\n    //   }\n    //   toString() {\n    //     return `Fp6(${this.c0} + ${this.c1} * v, ${this.c2} * v^2)`;\n    //   }\n    fromBigSix: (t) => {\n        if (!Array.isArray(t) || t.length !== 6)\n            throw new Error('Invalid Fp6 usage');\n        return {\n            c0: Fp2.fromBigTuple(t.slice(0, 2)),\n            c1: Fp2.fromBigTuple(t.slice(2, 4)),\n            c2: Fp2.fromBigTuple(t.slice(4, 6)),\n        };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power) => ({\n        c0: Fp2.frobeniusMap(c0, power),\n        c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n        c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    multiplyBy1: ({ c0, c1, c2 }, b1) => ({\n        c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n        c1: Fp2.mul(c0, b1),\n        c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    multiplyBy01({ c0, c1, c2 }, b0, b1) {\n        let t0 = Fp2.mul(c0, b0); // c0 * b0\n        let t1 = Fp2.mul(c1, b1); // c1 * b1\n        return {\n            // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n            c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n            // (b0 + b1) * (c0 + c1) - T0 - T1\n            c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n            // (c0 + c2) * b0 - T0 + T1\n            c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n        };\n    },\n    multiplyByFp2: ({ c0, c1, c2 }, rhs) => ({\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n    }),\n};\nconst FP6_FROBENIUS_COEFFICIENTS_1 = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x0'),\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [BigInt('0x0'), BigInt('0x1')],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x0'),\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n    ],\n].map((pair) => Fp2.fromBigTuple(pair));\nconst FP6_FROBENIUS_COEFFICIENTS_2 = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),\n        BigInt('0x0'),\n    ],\n].map((pair) => Fp2.fromBigTuple(pair));\n// The BLS parameter x for BLS12-381\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BLS_X);\nconst Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n});\nconst Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n});\nconst Fp12Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === 'bigint')\n        return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n        c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n        // (c0 + c1) * (r0 + r1) - (T1 + T2)\n        c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n};\nconst Fp12Square = ({ c0, c1 }) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n        // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n        c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n        c1: Fp6.add(ab, ab),\n    }; // AB + AB\n};\nfunction Fp4Square(a, b) {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n        first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b * Nonresidue + a\n        second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b) - a - b\n    };\n}\nconst Fp12 = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    BITS: 2 * Fp2.BITS,\n    BYTES: 2 * Fp2.BYTES,\n    MASK: (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(2 * Fp2.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: () => {\n        throw new Error('Not implemented');\n    },\n    inv: ({ c0, c1 }) => {\n        let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0 - c1 * v)\n        return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpPow(Fp12, num, power),\n    invertBatch: (nums) => _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n    // Bytes utils\n    fromBytes: (b) => {\n        if (b.length !== Fp12.BYTES)\n            throw new Error(`fromBytes wrong length=${b.length}`);\n        return {\n            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n        };\n    },\n    toBytes: ({ c0, c1 }) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n        c0: Fp6.cmov(c0, r0, c),\n        c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return `Fp12(${this.c0} + ${this.c1} * w)`;\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t) => ({\n        c0: Fp6.fromBigSix(t.slice(0, 6)),\n        c1: Fp6.fromBigSix(t.slice(6, 12)),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n        const r0 = Fp6.frobeniusMap(lhs.c0, power);\n        const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n        const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n        return {\n            c0: r0,\n            c1: Fp6.create({\n                c0: Fp2.mul(c0, coeff),\n                c1: Fp2.mul(c1, coeff),\n                c2: Fp2.mul(c2, coeff),\n            }),\n        };\n    },\n    // Sparse multiplication\n    multiplyBy014: ({ c0, c1 }, o0, o1, o4) => {\n        let t0 = Fp6.multiplyBy01(c0, o0, o1);\n        let t1 = Fp6.multiplyBy1(c1, o4);\n        return {\n            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n            // (c1 + c0) * [o0, o1+o4] - T0 - T1\n            c1: Fp6.sub(Fp6.sub(Fp6.multiplyBy01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n        };\n    },\n    multiplyByFp2: ({ c0, c1 }, rhs) => ({\n        c0: Fp6.multiplyByFp2(c0, rhs),\n        c1: Fp6.multiplyByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp6.neg(c1) }),\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   G(p) = {  Fp : ^(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: ({ c0, c1 }) => {\n        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n        const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n        const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n        const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n        let t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n        return {\n            c0: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n                c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n                c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n            }), // 2 * (T7 - c0c2)  + T7\n            c1: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n                c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n                c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n            }),\n        }; // 2 * (T6 + c1c2) + T6\n    },\n    _cyclotomicExp(num, n) {\n        let z = Fp12.ONE;\n        for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n            z = Fp12._cyclotomicSquare(z);\n            if ((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitGet)(n, i))\n                z = Fp12.mul(z, num);\n        }\n        return z;\n    },\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: (num) => {\n        const x = BLS_X;\n        // this^(q) / this\n        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n        // t0^(q) * t0\n        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n        // (t2 * t5)^(q) * (t4 * t1)^(q) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    },\n};\nconst FP12_FROBENIUS_COEFFICIENTS = [\n    [BigInt('0x1'), BigInt('0x0')],\n    [\n        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),\n        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),\n        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),\n    ],\n    [\n        BigInt('0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),\n        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3'),\n        BigInt('0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09'),\n        BigInt('0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2'),\n    ],\n    [\n        BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad'),\n        BigInt('0x0'),\n    ],\n    [\n        BigInt('0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116'),\n        BigInt('0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995'),\n    ],\n].map((n) => Fp2.fromBigTuple(n));\n// END OF CURVE FIELDS\n// HashToCurve\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__.isogenyMap)(Fp2, [\n    // xNum\n    [\n        [\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        ],\n        [\n            '0x0',\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n        ],\n        [\n            '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n            '0x0',\n        ],\n    ],\n    // xDen\n    [\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n        ],\n        [\n            '0xc',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n        [\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n            '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        ],\n        [\n            '0x0',\n            '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n        ],\n        [\n            '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n            '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n        ],\n        [\n            '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n            '0x0',\n        ],\n    ],\n    // yDen\n    [\n        [\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        ],\n        [\n            '0x0',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n        ],\n        [\n            '0x12',\n            '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n        ],\n        ['0x1', '0x0'], // LAST 1\n    ],\n].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_2__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n        '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n        '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n        '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n        '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n        '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n        '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n        '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n        '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n        '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n        '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n        '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n        '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n        '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n        '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n        '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n        '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n        '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n        '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n        '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n        '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n        '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n        '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n        '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n        '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n        '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n        '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n        '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n        '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n        '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n        '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n        '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n        '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n        '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n        '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n        '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n        '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n        '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n        '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n        '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n        '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n        '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n        '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n        '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n        '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n        '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n        '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n        '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n        '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n        '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n        '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n        '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n        '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j))));\n// SWU Map - Fp2 to G2': y = x + 240i * x + 1012 + 1012i\nconst G2_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp2, {\n    A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n    B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n    Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n    A: Fp.create(BigInt('0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d')),\n    B: Fp.create(BigInt('0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0')),\n    Z: Fp.create(BigInt(11)),\n});\n// Endomorphisms (for fast cofactor clearing)\n// (P) endomorphism\nconst ut_root = Fp6.create({ c0: Fp2.ZERO, c1: Fp2.ONE, c2: Fp2.ZERO });\nconst wsq = Fp12.create({ c0: ut_root, c1: Fp6.ZERO });\nconst wcu = Fp12.create({ c0: Fp6.ZERO, c1: ut_root });\nconst [wsq_inv, wcu_inv] = Fp12.invertBatch([wsq, wcu]);\nfunction psi(x, y) {\n    // Untwist Fp2->Fp12 && frobenius(1) && twist back\n    const x2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;\n    const y2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;\n    return [x2, y2];\n}\n//  endomorphism\nfunction G2psi(c, P) {\n    const affine = P.toAffine();\n    const p = psi(affine.x, affine.y);\n    return new c(p[0], p[1], Fp2.ONE);\n}\n// (P) endomorphism\n// 1 / F2(2)^((p-1)/3) in GF(p)\nconst PSI2_C1 = BigInt('0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac');\nfunction psi2(x, y) {\n    return [Fp2.mul(x, PSI2_C1), Fp2.neg(y)];\n}\nfunction G2psi2(c, P) {\n    const affine = P.toAffine();\n    const p = psi2(affine.x, affine.y);\n    return new c(p[0], p[1], Fp2.ONE);\n}\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n    // DST: a domain separation tag\n    // defined in section 2.2.5\n    // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n    DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n    // p: the characteristic of F\n    //    where F is a finite field of characteristic p and order q = p^m\n    p: Fp.ORDER,\n    // m: the extension degree of F, m >= 1\n    //     where F is a finite field of characteristic p and order q = p^m\n    m: 2,\n    // k: the target security level for the suite in bits\n    // defined in section 5.1\n    k: 128,\n    // option to use a message that has already been processed by\n    // expand_message_xmd\n    expand: 'xmd',\n    // Hash functions for: expand_message_xmd is appropriate for use with a\n    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256,\n});\n// Encoding utils\n// Point on G1 curve: (x, y)\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\nfunction parseMask(bytes) {\n    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n    bytes = bytes.slice();\n    const mask = bytes[0] & 224;\n    const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n    const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n    const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n    bytes[0] &= 31; // clear mask (zero first 3 bits)\n    return { compressed, infinity, sort, value: bytes };\n}\nfunction setMask(bytes, mask) {\n    if (bytes[0] & 224)\n        throw new Error('setMask: non-empty mask');\n    if (mask.compressed)\n        bytes[0] |= 128;\n    if (mask.infinity)\n        bytes[0] |= 64;\n    if (mask.sort)\n        bytes[0] |= 32;\n    return bytes;\n}\nfunction signatureG1ToRawBytes(point) {\n    point.assertValidity();\n    const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n    const { x, y } = point.toAffine();\n    if (isZero)\n        return COMPRESSED_ZERO.slice();\n    const P = Fp.ORDER;\n    const sort = Boolean((y * _2n) / P);\n    return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n}\nfunction signatureG2ToRawBytes(point) {\n    // NOTE: by some reasons it was missed in bls12-381, looks like bug\n    point.assertValidity();\n    const len = Fp.BYTES;\n    if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(_0n, len));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n    const sort = Boolean((tmp / Fp.ORDER) & _1n);\n    const z2 = x0;\n    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x1, len), { sort, compressed: true }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(z2, len));\n}\n// To verify curve parameters, see pairing-friendly-curves spec:\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11\n// Basic math is done over finite fields over p.\n// More complicated math is done over polynominal extension fields.\n// To simplify calculations in Fp12, we construct extension tower:\n// Fp = Fp => Fp\n// Fp(u) / (u - ) where  = -1\n// Fp(v) / (v - ) where  = u + 1\n// Fp(w) / (w - ) where  = v\n// Here goes constants && point encoding format\nconst bls12_381 = (0,_abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__.bls)({\n    // Fields\n    fields: {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12,\n        Fr,\n    },\n    // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where\n    // characteristic; z + (z - z + 1)(z - 1)/3\n    G1: {\n        Fp,\n        // cofactor; (z - 1)/3\n        h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n        // generator's coordinates\n        // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n        // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n        Gx: BigInt('0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'),\n        Gy: BigInt('0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'),\n        a: Fp.ZERO,\n        b: _4n,\n        htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, point) => {\n            //  endomorphism\n            const cubicRootOfUnityModP = BigInt('0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe');\n            const phi = new c(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\n            // todo: unroll\n            const xP = point.multiplyUnsafe(bls12_381.params.x).negate(); // [x]P\n            const u2P = xP.multiplyUnsafe(bls12_381.params.x); // [u2]P\n            return u2P.equals(phi);\n            // https://eprint.iacr.org/2019/814.pdf\n            // (z  1)/3\n            // const c1 = BigInt('0x396c8c005555e1560000000055555555');\n            // const P = this;\n            // const S = P.sigma();\n            // const Q = S.double();\n            // const S2 = S.sigma();\n            // // [(z  1)/3](2(P)  P  (P))  (P) = O\n            // const left = Q.subtract(P).subtract(S2).multiplyUnsafe(c1);\n            // const C = left.subtract(S2);\n            // return C.isZero();\n        },\n        // Clear cofactor of G1\n        // https://eprint.iacr.org/2019/403\n        clearCofactor: (_c, point) => {\n            // return this.multiplyUnsafe(CURVE.h);\n            return point.multiplyUnsafe(bls12_381.params.x).add(point); // x*P + P\n        },\n        mapToCurve: (scalars) => {\n            const { x, y } = G1_SWU(Fp.create(scalars[0]));\n            return isogenyMapG1(x, y);\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if (value.length === 48 && compressed) {\n                // TODO: Fp.bytes\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value);\n                // Zero\n                const x = Fp.create(compressedValue & Fp.MASK);\n                if (infinity) {\n                    if (x !== _0n)\n                        throw new Error('G1: non-empty compressed point at infinity');\n                    return { x: _0n, y: _0n };\n                }\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                if ((y * _2n) / P !== BigInt(sort))\n                    y = Fp.neg(y);\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else if (value.length === 96 && !compressed) {\n                // Check if the infinity flag is set\n                const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.subarray(0, Fp.BYTES));\n                const y = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.subarray(Fp.BYTES));\n                if (infinity) {\n                    if (x !== _0n || y !== _0n)\n                        throw new Error('G1: non-empty point at infinity');\n                    return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n                }\n                return { x: Fp.create(x), y: Fp.create(y) };\n            }\n            else {\n                throw new Error('Invalid point G1, expected 48/96 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return COMPRESSED_ZERO.slice();\n                const P = Fp.ORDER;\n                const sort = Boolean((y * _2n) / P);\n                return setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), { compressed: true, sort });\n            }\n            else {\n                if (isZero) {\n                    // 2x PUBLIC_KEY_LENGTH\n                    const x = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n                    return x;\n                }\n                else {\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x, Fp.BYTES), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y, Fp.BYTES));\n                }\n            }\n        },\n        ShortSignature: {\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signatureHex', hex, 48));\n                const P = Fp.ORDER;\n                const compressedValue = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value);\n                // Zero\n                if (infinity)\n                    return bls12_381.G1.ProjectivePoint.ZERO;\n                const x = Fp.create(compressedValue & Fp.MASK);\n                const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y = x + b\n                let y = Fp.sqrt(right);\n                if (!y)\n                    throw new Error('Invalid compressed G1 point');\n                const aflag = BigInt(sort);\n                if ((y * _2n) / P !== aflag)\n                    y = Fp.neg(y);\n                const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG1ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(signatureG1ToRawBytes(point));\n            },\n        },\n    },\n    // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),\n    // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where\n    // G - 1\n    // h2q\n    G2: {\n        Fp: Fp2,\n        // cofactor\n        h: BigInt('0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'),\n        Gx: Fp2.fromBigTuple([\n            BigInt('0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'),\n            BigInt('0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'),\n        ]),\n        // y =\n        // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n        // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n        Gy: Fp2.fromBigTuple([\n            BigInt('0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'),\n            BigInt('0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'),\n        ]),\n        a: Fp2.ZERO,\n        b: Fp2.fromBigTuple([_4n, _4n]),\n        hEff: BigInt('0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'),\n        htfDefaults: { ...htfDefaults },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        mapToCurve: (scalars) => {\n            const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n            return isogenyMapG2(x, y);\n        },\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, P) => {\n            return P.multiplyUnsafe(bls12_381.params.x).negate().equals(G2psi(c, P)); // (P) == [u](P)\n            // Older version: https://eprint.iacr.org/2019/814.pdf\n            // (P) => (P) => [z](P) where z = -x => [z](P) - (P) + P == O\n            // return P.psi2().psi().mulNegX().subtract(psi2).add(P).isZero();\n        },\n        // Maps the point into the prime-order subgroup G2.\n        // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\n        // https://eprint.iacr.org/2017/419.pdf\n        // prettier-ignore\n        clearCofactor: (c, P) => {\n            const x = bls12_381.params.x;\n            let t1 = P.multiplyUnsafe(x).negate(); // [-x]P\n            let t2 = G2psi(c, P); // (P)\n            let t3 = P.double(); // 2P\n            t3 = G2psi2(c, t3); // (2P)\n            t3 = t3.subtract(t2); // (2P) - (P)\n            t2 = t1.add(t2); // [-x]P + (P)\n            t2 = t2.multiplyUnsafe(x).negate(); // [x]P - [x](P)\n            t3 = t3.add(t2); // (2P) - (P) + [x]P - [x](P)\n            t3 = t3.subtract(t1); // (2P) - (P) + [x]P - [x](P) + [x]P\n            const Q = t3.subtract(P); // (2P) - (P) + [x]P - [x](P) + [x]P - 1P\n            return Q; // [x-x-1]P + [x-1](P) + (2P)\n        },\n        fromBytes: (bytes) => {\n            const { compressed, infinity, sort, value } = parseMask(bytes);\n            if ((!compressed && !infinity && sort) || // 00100000\n                (!compressed && infinity && sort) || // 01100000\n                (sort && infinity && compressed) // 11100000\n            ) {\n                throw new Error('Invalid encoding flag: ' + (bytes[0] & 224));\n            }\n            const L = Fp.BYTES;\n            const slc = (b, from, to) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(b.slice(from, to));\n            if (value.length === 96 && compressed) {\n                const b = bls12_381.params.G2b;\n                const P = Fp.ORDER;\n                if (infinity) {\n                    // check that all bytes are 0\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid compressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x_1 = slc(value, 0, L);\n                const x_0 = slc(value, L, 2 * L);\n                const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n                const right = Fp2.add(Fp2.pow(x, _3n), b); // y = x + 4 * (u+1) = x + b\n                let y = Fp2.sqrt(right);\n                const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n                y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n                return { x, y };\n            }\n            else if (value.length === 192 && !compressed) {\n                if (infinity) {\n                    if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n                        throw new Error('Invalid uncompressed G2 point');\n                    }\n                    return { x: Fp2.ZERO, y: Fp2.ZERO };\n                }\n                const x1 = slc(value, 0, L);\n                const x0 = slc(value, L, 2 * L);\n                const y1 = slc(value, 2 * L, 3 * L);\n                const y0 = slc(value, 3 * L, 4 * L);\n                return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n            }\n            else {\n                throw new Error('Invalid point G2, expected 96/192 bytes');\n            }\n        },\n        toBytes: (c, point, isCompressed) => {\n            const { BYTES: len, ORDER: P } = Fp;\n            const isZero = point.equals(c.ZERO);\n            const { x, y } = point.toAffine();\n            if (isCompressed) {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(COMPRESSED_ZERO, (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(_0n, len));\n                const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(setMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x.c1, len), { compressed: true, sort: flag }), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x.c0, len));\n            }\n            else {\n                if (isZero)\n                    return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n                const { re: x0, im: x1 } = Fp2.reim(x);\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(x0, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y1, len), (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE)(y0, len));\n            }\n        },\n        Signature: {\n            // TODO: Optimize, it's very slow because of sqrt.\n            fromHex(hex) {\n                const { infinity, sort, value } = parseMask((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signatureHex', hex));\n                const P = Fp.ORDER;\n                const half = value.length / 2;\n                if (half !== 48 && half !== 96)\n                    throw new Error('Invalid compressed signature length, must be 96 or 192');\n                const z1 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.slice(0, half));\n                const z2 = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE)(value.slice(half));\n                // Indicates the infinity point\n                if (infinity)\n                    return bls12_381.G2.ProjectivePoint.ZERO;\n                const x1 = Fp.create(z1 & Fp.MASK);\n                const x2 = Fp.create(z2);\n                const x = Fp2.create({ c0: x2, c1: x1 });\n                const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y = x + 4\n                // The slow part\n                let y = Fp2.sqrt(y2);\n                if (!y)\n                    throw new Error('Failed to find a square root');\n                // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n                // If y1 happens to be zero, then use the bit of y0\n                const { re: y0, im: y1 } = Fp2.reim(y);\n                const aflag1 = BigInt(sort);\n                const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n                const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n                if (isGreater || isZero)\n                    y = Fp2.neg(y);\n                const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n                point.assertValidity();\n                return point;\n            },\n            toRawBytes(point) {\n                return signatureG2ToRawBytes(point);\n            },\n            toHex(point) {\n                return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex)(signatureG2ToRawBytes(point));\n            },\n        },\n    },\n    params: {\n        x: BLS_X, // The BLS parameter x for BLS12-381\n        r: Fr.ORDER, // order; z  z + 1; CURVE.n from other curves\n    },\n    htfDefaults,\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.randomBytes,\n});\n//# sourceMappingURL=bls12-381.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/curves/esm/bls12-381.js?");

/***/ }),

/***/ "./node_modules/@noble/ed25519/lib/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/ed25519/lib/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   ExtendedPoint: () => (/* binding */ ExtendedPoint),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   curve25519: () => (/* binding */ curve25519),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"?51ea\");\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\n\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n)\n            p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\n\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nasync function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nasync function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nasync function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nconst sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nasync function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nconst curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/ed25519/lib/esm/index.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/_assert.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/_md.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/_u64.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/crypto.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/sha256.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/sha3.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/sha512.js?");

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/@noble/hashes/esm/utils.js?");

/***/ }),

/***/ "./node_modules/base58-universal/lib/baseN.js":
/*!****************************************************!*\
  !*** ./node_modules/base58-universal/lib/baseN.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/**\n * Base-N/Base-X encoding/decoding functions.\n *\n * Original implementation from base-x:\n * https://github.com/cryptocoinjs/base-x\n *\n * Which is MIT licensed:\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n// baseN alphabet indexes\nconst _reverseAlphabets = {};\n\n/**\n * BaseN-encodes a Uint8Array using the given alphabet.\n *\n * @param {Uint8Array} input - The bytes to encode in a Uint8Array.\n * @param {string} alphabet - The alphabet to use for encoding.\n * @param {number} maxline - The maximum number of encoded characters per line\n *          to use, defaults to none.\n *\n * @returns {string} The baseN-encoded output string.\n */\nfunction encode(input, alphabet, maxline) {\n  if(!(input instanceof Uint8Array)) {\n    throw new TypeError('\"input\" must be a Uint8Array.');\n  }\n  if(typeof alphabet !== 'string') {\n    throw new TypeError('\"alphabet\" must be a string.');\n  }\n  if(maxline !== undefined && typeof maxline !== 'number') {\n    throw new TypeError('\"maxline\" must be a number.');\n  }\n  if(input.length === 0) {\n    return '';\n  }\n\n  let output = '';\n\n  let i = 0;\n  const base = alphabet.length;\n  const first = alphabet.charAt(0);\n  const digits = [0];\n  for(i = 0; i < input.length; ++i) {\n    let carry = input[i];\n    for(let j = 0; j < digits.length; ++j) {\n      carry += digits[j] << 8;\n      digits[j] = carry % base;\n      carry = (carry / base) | 0;\n    }\n\n    while(carry > 0) {\n      digits.push(carry % base);\n      carry = (carry / base) | 0;\n    }\n  }\n\n  // deal with leading zeros\n  for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {\n    output += first;\n  }\n  // convert digits to a string\n  for(i = digits.length - 1; i >= 0; --i) {\n    output += alphabet[digits[i]];\n  }\n\n  if(maxline) {\n    const regex = new RegExp('.{1,' + maxline + '}', 'g');\n    output = output.match(regex).join('\\r\\n');\n  }\n\n  return output;\n}\n\n/**\n * Decodes a baseN-encoded (using the given alphabet) string to a\n * Uint8Array.\n *\n * @param {string} input - The baseN-encoded input string.\n * @param {string} alphabet - The alphabet to use for decoding.\n *\n * @returns {Uint8Array} The decoded bytes in a Uint8Array.\n */\nfunction decode(input, alphabet) {\n  if(typeof input !== 'string') {\n    throw new TypeError('\"input\" must be a string.');\n  }\n  if(typeof alphabet !== 'string') {\n    throw new TypeError('\"alphabet\" must be a string.');\n  }\n  if(input.length === 0) {\n    return new Uint8Array();\n  }\n\n  let table = _reverseAlphabets[alphabet];\n  if(!table) {\n    // compute reverse alphabet\n    table = _reverseAlphabets[alphabet] = [];\n    for(let i = 0; i < alphabet.length; ++i) {\n      table[alphabet.charCodeAt(i)] = i;\n    }\n  }\n\n  // remove whitespace characters\n  input = input.replace(/\\s/g, '');\n\n  const base = alphabet.length;\n  const first = alphabet.charAt(0);\n  const bytes = [0];\n  for(let i = 0; i < input.length; i++) {\n    const value = table[input.charCodeAt(i)];\n    if(value === undefined) {\n      return;\n    }\n\n    let carry = value;\n    for(let j = 0; j < bytes.length; ++j) {\n      carry += bytes[j] * base;\n      bytes[j] = carry & 0xff;\n      carry >>= 8;\n    }\n\n    while(carry > 0) {\n      bytes.push(carry & 0xff);\n      carry >>= 8;\n    }\n  }\n\n  // deal with leading zeros\n  for(let k = 0; input[k] === first && k < input.length - 1; ++k) {\n    bytes.push(0);\n  }\n\n  return new Uint8Array(bytes.reverse());\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base58-universal/lib/baseN.js?");

/***/ }),

/***/ "./node_modules/base58-universal/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/base58-universal/lib/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _baseN_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./baseN.js */ \"./node_modules/base58-universal/lib/baseN.js\");\n/*!\n * Copyright (c) 2019-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// base58 characters (Bitcoin alphabet)\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\nfunction encode(input, maxline) {\n  return (0,_baseN_js__WEBPACK_IMPORTED_MODULE_0__.encode)(input, alphabet, maxline);\n}\n\nfunction decode(input) {\n  return (0,_baseN_js__WEBPACK_IMPORTED_MODULE_0__.decode)(input, alphabet);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base58-universal/lib/index.js?");

/***/ }),

/***/ "./node_modules/base64url-universal/lib/base64url.js":
/*!***********************************************************!*\
  !*** ./node_modules/base64url-universal/lib/base64url.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n/**\n * Encode/Decode input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n *\n * @module base64url-universal\n */\n\nconst _alphabet =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst _alphabetIdx = [\n  62, -1, -1,\n  52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\n  -1, -1, -1, 64, -1, -1, -1,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n  13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n  -1, -1, -1, -1, 63, -1,\n  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n  39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n];\n\n/**\n * Encodes input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n *\n * @alias module:base64url-universal\n * @param {(Uint8Array | string)} input - The data to encode.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(input) {\n  if(!((input instanceof Uint8Array) || (typeof input === 'string'))) {\n    throw new TypeError('\"input\" be a string or Uint8Array.');\n  }\n  if(typeof input === 'string') {\n    // convert input to Uint8Array\n    input = new TextEncoder().encode(input);\n  }\n  let output = '';\n  let chr1;\n  let chr2;\n  let chr3;\n  let i = 0;\n  while(i < input.byteLength) {\n    chr1 = input[i++];\n    chr2 = input[i++];\n    chr3 = input[i++];\n\n    // encode 4 character group\n    output += _alphabet.charAt(chr1 >> 2);\n    output += _alphabet.charAt(((chr1 & 3) << 4) | (chr2 >> 4));\n    if(!isNaN(chr2)) {\n      output += _alphabet.charAt(((chr2 & 15) << 2) | (chr3 >> 6));\n      if(!isNaN(chr3)) {\n        output += _alphabet.charAt(chr3 & 63);\n      }\n    }\n  }\n  return output;\n}\n\n/**\n * Decodes input according to the \"Base64url Encoding\" format as specified\n * in JSON Web Signature (JWS) RFC7517. A URL safe character set is used and\n * trailing '=', line breaks, whitespace, and other characters are omitted.\n *\n * @alias module:base64url-universal\n * @param {string} input - The data to decode.\n *\n * @returns {Uint8Array} The decoded value.\n */\nfunction decode(input) {\n  let length = input.length;\n  const mod4 = length % 4;\n  if(mod4 === 1) {\n    throw new Error('Illegal base64 string.');\n  }\n  let diff = 0;\n  if(mod4 > 0) {\n    diff = 4 - mod4;\n    length += diff;\n  }\n\n  const output = new Uint8Array(length / 4 * 3 - diff);\n\n  let enc1;\n  let enc2;\n  let enc3;\n  let enc4;\n  let i = 0;\n  let j = 0;\n\n  while(i < length) {\n    enc1 = _alphabetIdx[input.charCodeAt(i++) - 45];\n    enc2 = _alphabetIdx[input.charCodeAt(i++) - 45];\n\n    output[j++] = (enc1 << 2) | (enc2 >> 4);\n    if(i < input.length) {\n      // can decode at least 2 bytes\n      enc3 = _alphabetIdx[input.charCodeAt(i++) - 45];\n      output[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);\n      if(i < input.length) {\n        // can decode 3 bytes\n        enc4 = _alphabetIdx[input.charCodeAt(i++) - 45];\n        output[j++] = ((enc3 & 3) << 6) | enc4;\n      }\n    }\n  }\n\n  return output;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base64url-universal/lib/base64url.js?");

/***/ }),

/***/ "./node_modules/base64url-universal/lib/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/base64url-universal/lib/browser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* reexport safe */ _base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode),\n/* harmony export */   encode: () => (/* reexport safe */ _base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)\n/* harmony export */ });\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/base64url-universal/lib/base64url.js\");\n/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/base64url-universal/lib/browser.js?");

/***/ }),

/***/ "./node_modules/cborg/cborg.js":
/*!*************************************!*\
  !*** ./node_modules/cborg/cborg.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* reexport safe */ _lib_token_js__WEBPACK_IMPORTED_MODULE_2__.Token),\n/* harmony export */   Tokenizer: () => (/* reexport safe */ _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.Tokeniser),\n/* harmony export */   Type: () => (/* reexport safe */ _lib_token_js__WEBPACK_IMPORTED_MODULE_2__.Type),\n/* harmony export */   decode: () => (/* reexport safe */ _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.decode),\n/* harmony export */   decodeFirst: () => (/* reexport safe */ _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.decodeFirst),\n/* harmony export */   encode: () => (/* reexport safe */ _lib_encode_js__WEBPACK_IMPORTED_MODULE_0__.encode),\n/* harmony export */   tokensToObject: () => (/* reexport safe */ _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__.tokensToObject)\n/* harmony export */ });\n/* harmony import */ var _lib_encode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode.js */ \"./node_modules/cborg/lib/encode.js\");\n/* harmony import */ var _lib_decode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/decode.js */ \"./node_modules/cborg/lib/decode.js\");\n/* harmony import */ var _lib_token_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/token.js */ \"./node_modules/cborg/lib/token.js\");\n\n\n\n\n/**\n * Export the types that were present in the original manual cborg.d.ts\n * @typedef {import('./interface').TagDecoder} TagDecoder\n * There was originally just `TypeEncoder` so don't break types by renaming or not exporting\n * @typedef {import('./interface').OptionalTypeEncoder} TypeEncoder\n * @typedef {import('./interface').DecodeOptions} DecodeOptions\n * @typedef {import('./interface').EncodeOptions} EncodeOptions\n */\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/cborg.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/0uint.js":
/*!*****************************************!*\
  !*** ./node_modules/cborg/lib/0uint.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeUint16: () => (/* binding */ decodeUint16),\n/* harmony export */   decodeUint32: () => (/* binding */ decodeUint32),\n/* harmony export */   decodeUint64: () => (/* binding */ decodeUint64),\n/* harmony export */   decodeUint8: () => (/* binding */ decodeUint8),\n/* harmony export */   encodeUint: () => (/* binding */ encodeUint),\n/* harmony export */   encodeUintValue: () => (/* binding */ encodeUintValue),\n/* harmony export */   readUint16: () => (/* binding */ readUint16),\n/* harmony export */   readUint32: () => (/* binding */ readUint32),\n/* harmony export */   readUint64: () => (/* binding */ readUint64),\n/* harmony export */   readUint8: () => (/* binding */ readUint8),\n/* harmony export */   uintBoundaries: () => (/* binding */ uintBoundaries)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* globals BigInt */\n\n\n\n\nconst uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nfunction readUint8 (data, offset, options) {\n  ;(0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nfunction readUint16 (data, offset, options) {\n  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nfunction readUint32 (data, offset, options) {\n  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nfunction readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeUint8 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeUint16 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeUint32 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeUint64 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nfunction encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/0uint.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/1negint.js":
/*!*******************************************!*\
  !*** ./node_modules/cborg/lib/1negint.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeNegint16: () => (/* binding */ decodeNegint16),\n/* harmony export */   decodeNegint32: () => (/* binding */ decodeNegint32),\n/* harmony export */   decodeNegint64: () => (/* binding */ decodeNegint64),\n/* harmony export */   decodeNegint8: () => (/* binding */ decodeNegint8),\n/* harmony export */   encodeNegint: () => (/* binding */ encodeNegint)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* eslint-env es2020 */\n\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeNegint8 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeNegint16 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeNegint32 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, -1 - _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeNegint64 (data, pos, _minor, options) {\n  const int = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < _0uint_js__WEBPACK_IMPORTED_MODULE_1__.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/1negint.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/2bytes.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/2bytes.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareBytes: () => (/* binding */ compareBytes),\n/* harmony export */   decodeBytes16: () => (/* binding */ decodeBytes16),\n/* harmony export */   decodeBytes32: () => (/* binding */ decodeBytes32),\n/* harmony export */   decodeBytes64: () => (/* binding */ decodeBytes64),\n/* harmony export */   decodeBytes8: () => (/* binding */ decodeBytes8),\n/* harmony export */   decodeBytesCompact: () => (/* binding */ decodeBytesCompact),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./byte-utils.js */ \"./node_modules/cborg/lib/byte-utils.js\");\n\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, pos, prefix + length)\n  const buf = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.slice)(data, pos + prefix, pos + prefix + length)\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nfunction decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeBytes64 (data, pos, _minor, options) {\n  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string ? (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.fromString)(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nfunction compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_3__.compare)(b1, b2)\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/2bytes.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/3string.js":
/*!*******************************************!*\
  !*** ./node_modules/cborg/lib/3string.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeString16: () => (/* binding */ decodeString16),\n/* harmony export */   decodeString32: () => (/* binding */ decodeString32),\n/* harmony export */   decodeString64: () => (/* binding */ decodeString64),\n/* harmony export */   decodeString8: () => (/* binding */ decodeString8),\n/* harmony export */   decodeStringCompact: () => (/* binding */ decodeStringCompact),\n/* harmony export */   encodeString: () => (/* binding */ encodeString)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2bytes.js */ \"./node_modules/cborg/lib/2bytes.js\");\n/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./byte-utils.js */ \"./node_modules/cborg/lib/byte-utils.js\");\n\n\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  ;(0,_common_js__WEBPACK_IMPORTED_MODULE_1__.assertEnoughData)(data, pos, totLength)\n  const tok = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string, (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_4__.toString)(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_4__.slice)(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeString64 (data, pos, _minor, options) {\n  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nconst encodeString = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.encodeBytes\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/3string.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/4array.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/4array.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeArray16: () => (/* binding */ decodeArray16),\n/* harmony export */   decodeArray32: () => (/* binding */ decodeArray32),\n/* harmony export */   decodeArray64: () => (/* binding */ decodeArray64),\n/* harmony export */   decodeArray8: () => (/* binding */ decodeArray8),\n/* harmony export */   decodeArrayCompact: () => (/* binding */ decodeArrayCompact),\n/* harmony export */   decodeArrayIndefinite: () => (/* binding */ decodeArrayIndefinite),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nfunction decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeArray64 (data, pos, _minor, options) {\n  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeArray (buf, token) {\n  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue.encodedSize(token.value)\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/4array.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/5map.js":
/*!****************************************!*\
  !*** ./node_modules/cborg/lib/5map.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeMap16: () => (/* binding */ decodeMap16),\n/* harmony export */   decodeMap32: () => (/* binding */ decodeMap32),\n/* harmony export */   decodeMap64: () => (/* binding */ decodeMap64),\n/* harmony export */   decodeMap8: () => (/* binding */ decodeMap8),\n/* harmony export */   decodeMapCompact: () => (/* binding */ decodeMapCompact),\n/* harmony export */   decodeMapIndefinite: () => (/* binding */ decodeMapIndefinite),\n/* harmony export */   encodeMap: () => (/* binding */ encodeMap)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nfunction decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeMap64 (data, pos, _minor, options) {\n  const l = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_2__.decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeMap (buf, token) {\n  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue.encodedSize(token.value)\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/5map.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/6tag.js":
/*!****************************************!*\
  !*** ./node_modules/cborg/lib/6tag.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeTag16: () => (/* binding */ decodeTag16),\n/* harmony export */   decodeTag32: () => (/* binding */ decodeTag32),\n/* harmony export */   decodeTag64: () => (/* binding */ decodeTag64),\n/* harmony export */   decodeTag8: () => (/* binding */ decodeTag8),\n/* harmony export */   decodeTagCompact: () => (/* binding */ decodeTagCompact),\n/* harmony export */   encodeTag: () => (/* binding */ encodeTag)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nfunction decodeTagCompact (_data, _pos, minor, _options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeTag8 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeTag16 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeTag32 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeTag64 (data, pos, _minor, options) {\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag, _0uint_js__WEBPACK_IMPORTED_MODULE_1__.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nfunction encodeTag (buf, token) {\n  _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue(buf, _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return _0uint_js__WEBPACK_IMPORTED_MODULE_1__.encodeUintValue.encodedSize(token.value)\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/6tag.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/7float.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/7float.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeBreak: () => (/* binding */ decodeBreak),\n/* harmony export */   decodeFloat16: () => (/* binding */ decodeFloat16),\n/* harmony export */   decodeFloat32: () => (/* binding */ decodeFloat32),\n/* harmony export */   decodeFloat64: () => (/* binding */ decodeFloat64),\n/* harmony export */   decodeUndefined: () => (/* binding */ decodeUndefined),\n/* harmony export */   encodeFloat: () => (/* binding */ encodeFloat)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\n\n\n\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.null, null, 1)\n  }\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nfunction encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_1__.decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = _0uint_js__WEBPACK_IMPORTED_MODULE_2__.encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/7float.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/bl.js":
/*!**************************************!*\
  !*** ./node_modules/cborg/lib/bl.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bl: () => (/* binding */ Bl)\n/* harmony export */ });\n/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-utils.js */ \"./node_modules/cborg/lib/byte-utils.js\");\n/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\n\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nclass Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.alloc)(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.slice)(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/bl.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/byte-utils.js":
/*!**********************************************!*\
  !*** ./node_modules/cborg/lib/byte-utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alloc: () => (/* binding */ alloc),\n/* harmony export */   asU8A: () => (/* binding */ asU8A),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   decodeCodePointsArray: () => (/* binding */ decodeCodePointsArray),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   useBuffer: () => (/* binding */ useBuffer)\n/* harmony export */ });\n// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nconst useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nfunction asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nconst toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nconst fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nconst fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nconst slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nconst concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nconst alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nconst toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nconst fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nfunction compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/byte-utils.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/common.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/common.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEnoughData: () => (/* binding */ assertEnoughData),\n/* harmony export */   decodeErrPrefix: () => (/* binding */ decodeErrPrefix),\n/* harmony export */   encodeErrPrefix: () => (/* binding */ encodeErrPrefix),\n/* harmony export */   uintMinorPrefixBytes: () => (/* binding */ uintMinorPrefixBytes)\n/* harmony export */ });\nconst decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/common.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/decode.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/decode.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tokeniser: () => (/* binding */ Tokeniser),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeFirst: () => (/* binding */ decodeFirst),\n/* harmony export */   tokensToObject: () => (/* binding */ tokensToObject)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _jump_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jump.js */ \"./node_modules/cborg/lib/jump.js\");\n\n\n\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = _jump_js__WEBPACK_IMPORTED_MODULE_2__.quick[byt]\n    if (token === undefined) {\n      const decoder = _jump_js__WEBPACK_IMPORTED_MODULE_2__.jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === _token_js__WEBPACK_IMPORTED_MODULE_1__.Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_0__.decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/decode.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/encode.js":
/*!******************************************!*\
  !*** ./node_modules/cborg/lib/encode.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ref: () => (/* binding */ Ref),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeCustom: () => (/* binding */ encodeCustom),\n/* harmony export */   makeCborEncoders: () => (/* binding */ makeCborEncoders),\n/* harmony export */   objectToTokens: () => (/* binding */ objectToTokens)\n/* harmony export */ });\n/* harmony import */ var _is_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is.js */ \"./node_modules/cborg/lib/is.js\");\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _bl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bl.js */ \"./node_modules/cborg/lib/bl.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _jump_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jump.js */ \"./node_modules/cborg/lib/jump.js\");\n/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./byte-utils.js */ \"./node_modules/cborg/lib/byte-utils.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _1negint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./1negint.js */ \"./node_modules/cborg/lib/1negint.js\");\n/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./2bytes.js */ \"./node_modules/cborg/lib/2bytes.js\");\n/* harmony import */ var _3string_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./3string.js */ \"./node_modules/cborg/lib/3string.js\");\n/* harmony import */ var _4array_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./4array.js */ \"./node_modules/cborg/lib/4array.js\");\n/* harmony import */ var _5map_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./5map.js */ \"./node_modules/cborg/lib/5map.js\");\n/* harmony import */ var _6tag_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./6tag.js */ \"./node_modules/cborg/lib/6tag.js\");\n/* harmony import */ var _7float_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./7float.js */ \"./node_modules/cborg/lib/7float.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: _jump_js__WEBPACK_IMPORTED_MODULE_4__.quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nfunction makeCborEncoders () {\n  const encoders = []\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint.major] = _0uint_js__WEBPACK_IMPORTED_MODULE_6__.encodeUint\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint.major] = _1negint_js__WEBPACK_IMPORTED_MODULE_7__.encodeNegint\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes.major] = _2bytes_js__WEBPACK_IMPORTED_MODULE_8__.encodeBytes\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.string.major] = _3string_js__WEBPACK_IMPORTED_MODULE_9__.encodeString\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array.major] = _4array_js__WEBPACK_IMPORTED_MODULE_10__.encodeArray\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map.major] = _5map_js__WEBPACK_IMPORTED_MODULE_11__.encodeMap\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.tag.major] = _6tag_js__WEBPACK_IMPORTED_MODULE_12__.encodeTag\n  encoders[_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.float.major] = _7float_js__WEBPACK_IMPORTED_MODULE_13__.encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new _bl_js__WEBPACK_IMPORTED_MODULE_2__.Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_3__.encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.null, null),\n  undefined: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.undefined, undefined),\n  true: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.true, true),\n  false: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.false, false),\n  emptyArray: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, 0),\n  emptyMap: new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.float, obj)\n    } else if (obj >= 0) {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint, obj)\n    } else {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.uint, obj)\n    } else {\n      return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, obj.length), entries, new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.break)]\n    }\n    return [new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, length), entries, new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.break)]\n    }\n    return [new _token_js__WEBPACK_IMPORTED_MODULE_1__.Token(_token_js__WEBPACK_IMPORTED_MODULE_1__.Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = (0,_is_js__WEBPACK_IMPORTED_MODULE_0__.is)(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_3__.encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new _bl_js__WEBPACK_IMPORTED_MODULE_2__.Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_5__.asU8A)(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/encode.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/is.js":
/*!**************************************!*\
  !*** ./node_modules/cborg/lib/is.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   is: () => (/* binding */ is)\n/* harmony export */ });\n// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nfunction is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/is.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/jump.js":
/*!****************************************!*\
  !*** ./node_modules/cborg/lib/jump.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jump: () => (/* binding */ jump),\n/* harmony export */   quick: () => (/* binding */ quick),\n/* harmony export */   quickEncodeToken: () => (/* binding */ quickEncodeToken)\n/* harmony export */ });\n/* harmony import */ var _token_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token.js */ \"./node_modules/cborg/lib/token.js\");\n/* harmony import */ var _0uint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./0uint.js */ \"./node_modules/cborg/lib/0uint.js\");\n/* harmony import */ var _1negint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./1negint.js */ \"./node_modules/cborg/lib/1negint.js\");\n/* harmony import */ var _2bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./2bytes.js */ \"./node_modules/cborg/lib/2bytes.js\");\n/* harmony import */ var _3string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./3string.js */ \"./node_modules/cborg/lib/3string.js\");\n/* harmony import */ var _4array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./4array.js */ \"./node_modules/cborg/lib/4array.js\");\n/* harmony import */ var _5map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./5map.js */ \"./node_modules/cborg/lib/5map.js\");\n/* harmony import */ var _6tag_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./6tag.js */ \"./node_modules/cborg/lib/6tag.js\");\n/* harmony import */ var _7float_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./7float.js */ \"./node_modules/cborg/lib/7float.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./common.js */ \"./node_modules/cborg/lib/common.js\");\n/* harmony import */ var _byte_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./byte-utils.js */ \"./node_modules/cborg/lib/byte-utils.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_9__.decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${_common_js__WEBPACK_IMPORTED_MODULE_9__.decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nconst jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = _0uint_js__WEBPACK_IMPORTED_MODULE_1__.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = _1negint_js__WEBPACK_IMPORTED_MODULE_2__.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytesCompact\n}\njump[0x58] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = _2bytes_js__WEBPACK_IMPORTED_MODULE_3__.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeStringCompact\n}\njump[0x78] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = _3string_js__WEBPACK_IMPORTED_MODULE_4__.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArrayCompact\n}\njump[0x98] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = _4array_js__WEBPACK_IMPORTED_MODULE_5__.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMapCompact\n}\njump[0xb8] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = _5map_js__WEBPACK_IMPORTED_MODULE_6__.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTagCompact\n}\njump[0xd8] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag8\njump[0xd9] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag16\njump[0xda] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag32\njump[0xdb] = _6tag_js__WEBPACK_IMPORTED_MODULE_7__.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = _7float_js__WEBPACK_IMPORTED_MODULE_8__.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nconst quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string, '', 1)\n// empty list\nquick[0x80] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array, 0, 1)\n// empty map\nquick[0xa0] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map, 0, 1)\n// false\nquick[0xf4] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.false, false, 1)\n// true\nquick[0xf5] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.true, true, 1)\n// null\nquick[0xf6] = new _token_js__WEBPACK_IMPORTED_MODULE_0__.Token(_token_js__WEBPACK_IMPORTED_MODULE_0__.Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nfunction quickEncodeToken (token) {\n  switch (token.type) {\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.false:\n      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0xf4])\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.true:\n      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0xf5])\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.null:\n      return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0xf6])\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.bytes:\n      if (!token.value.length) {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0x40])\n      }\n      return\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.string:\n      if (token.value === '') {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0x60])\n      }\n      return\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.array:\n      if (token.value === 0) {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.map:\n      if (token.value === 0) {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.uint:\n      if (token.value < 24) {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([Number(token.value)])\n      }\n      return\n    case _token_js__WEBPACK_IMPORTED_MODULE_0__.Type.negint:\n      if (token.value >= -24) {\n        return (0,_byte_utils_js__WEBPACK_IMPORTED_MODULE_10__.fromArray)([31 - Number(token.value)])\n      }\n  }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/jump.js?");

/***/ }),

/***/ "./node_modules/cborg/lib/token.js":
/*!*****************************************!*\
  !*** ./node_modules/cborg/lib/token.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   Type: () => (/* binding */ Type)\n/* harmony export */ });\nclass Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/cborg/lib/token.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/CryptoLD.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-ld/lib/CryptoLD.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CryptoLD: () => (/* binding */ CryptoLD)\n/* harmony export */ });\n/*!\n * Copyright (c) 2020-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * General purpose key generation driver for Linked Data cryptographic key\n * pairs.\n *\n * @param {Map} [suites] - Optional map of supported suites, by suite id.\n */\nclass CryptoLD {\n  constructor({suites} = {}) {\n    this.suites = suites || new Map();\n  }\n\n  /**\n   * Installs support for a key type (suite).\n   *\n   * @param {LDKeyPair} keyPairLib - Conforming key pair library for a suite.\n   */\n  use(keyPairLib) {\n    this.suites.set(keyPairLib.suite, keyPairLib);\n  }\n\n  /**\n   * Generates a public/private LDKeyPair.\n   *\n   * @param {object} options - Suite-specific key options.\n   * @param {string} options.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   * @param {string} [options.controller] - Controller DID or URL for the\n   *   generated key pair. If present, used to auto-initialize the key.id.\n   *\n   * @returns {Promise<LDKeyPair>} Generated key pair.\n   */\n  async generate(options = {}) {\n    const Suite = this._suiteForType(options);\n    return Suite.generate(options);\n  }\n\n  /**\n   * Imports a public/private key pair from serialized data.\n   *\n   * @param {object} serialized - Serialized key object.\n   *\n   * @throws {Error} - On missing or invalid serialized key data.\n   *\n   * @returns {Promise<LDKeyPair>} Imported key pair.\n   */\n  async from(serialized = {}) {\n    const Suite = this._suiteForType(serialized);\n\n    if(serialized['@context']) {\n      // presume this may be an untrusted (fetched, etc) key document\n      return Suite.fromKeyDocument({document: serialized});\n    }\n\n    return Suite.from(serialized);\n  }\n\n  /**\n   * Imports a key pair instance from a provided externally fetched key\n   * document (fetched via a secure JSON-LD `documentLoader` or via\n   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required\n   * context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.document - Externally fetched key document.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair\n   *   instance.\n   */\n  async fromKeyDocument({\n    document, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!document) {\n      throw new TypeError('The \"document\" parameter is required.');\n    }\n    const Suite = this._suiteForType(document);\n\n    return Suite.fromKeyDocument({document, checkContext, checkRevoked});\n  }\n\n  /**\n   * Imports a key pair instance via the provided `documentLoader` function,\n   * optionally checking it for revocation and required context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.id - Key ID or URI.\n   * @param {Function} options.documentLoader - JSON-LD Document Loader.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the appropriate key pair\n   *   instance.\n   */\n  async fromKeyId({\n    id, documentLoader, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!id) {\n      throw new TypeError('The \"id\" parameter is required.');\n    }\n    if(!documentLoader) {\n      throw new TypeError('The \"documentLoader\" parameter is required.');\n    }\n    let keyDocument;\n    try {\n      ({document: keyDocument} = await documentLoader(id));\n      // the supplied documentLoader may not be properly implemented\n      if(!keyDocument) {\n        throw new Error(\n          'The \"documentLoader\" function must return a \"document\" object.');\n      }\n    } catch(e) {\n      const error = new Error('Error fetching document: ' + e.message);\n      error.cause = e;\n      throw error;\n    }\n    const fetchedType = keyDocument.type;\n    if(!fetchedType) {\n      throw new Error('Key suite type not found in fetched document.');\n    }\n    const keySuite = this.suites.get(fetchedType);\n    if(!keySuite) {\n      throw new Error(`Support for suite \"${fetchedType}\" is not installed.`);\n    }\n\n    return keySuite.fromKeyDocument({document: keyDocument, checkContext,\n      checkRevoked});\n  }\n\n  /**\n   * Tests if a given key type is currently installed.\n   *\n   * @param {string} [type] - Key suite id ('Ed25519VerificationKey2020').\n   * @private\n   *\n   * @returns {boolean} True if key type installed.\n   */\n  _installed({type}) {\n    return this.suites.has(type);\n  }\n\n  /**\n   * Returns the installed crypto suite class for a given document's type.\n   *\n   * @param {object} document - A serialized key document (or options document).\n   * @param {string} document.type - Key suite id (for example,\n   *   'Ed25519VerificationKey2020').\n   *\n   * @returns {object} LDKeyPair (crypto suite) class.\n   */\n  _suiteForType(document) {\n    const type = document && document.type;\n\n    if(!type) {\n      throw new TypeError('Missing key type.');\n    }\n    if(!this._installed({type})) {\n      throw new Error(`Support for key type \"${type}\" is not installed.`);\n    }\n\n    return this.suites.get(type);\n  }\n}\n\n/**\n * @typedef LDKeyPair\n */\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/CryptoLD.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/LDKeyPair.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-ld/lib/LDKeyPair.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LDKeyPair: () => (/* binding */ LDKeyPair)\n/* harmony export */ });\n/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n/**\n * When adding support for a new suite type for `crypto-ld`, developers should\n * do the following:\n *\n * 1. Create their own npm package / github repo, such as `example-key-pair`.\n * 2. Subclass LDKeyPair.\n * 3. Override relevant methods (such as `export()` and `fingerprint()`).\n * 4. Add to the key type table in the `crypto-ld` README.md (that's this repo).\n */\nclass LDKeyPair {\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Creates a public/private key pair instance. This is an abstract base class,\n   * actual key material and suite-specific methods are handled in the subclass.\n   *\n   * To generate or import a key pair, use the `cryptoLd` instance.\n   *\n   * @see CryptoLD.js\n   *\n   * @param {object} options - The options to use.\n   * @param {string} options.id - The key id, typically composed of controller\n   *   URL and key fingerprint as hash fragment.\n   * @param {string} options.controller - DID/URL of the person/entity\n   *   controlling this key.\n   * @param {string} [options.revoked] - Timestamp of when the key has been\n   *   revoked, in RFC3339 format. If not present, the key itself is\n   *   considered not revoked. (Note that this mechanism is slightly different\n   *   than DID Document key revocation, where a DID controller can revoke a\n   *   key from that DID by removing it from the DID Document.)\n   */\n  /* eslint-enable */\n  constructor({id, controller, revoked} = {}) {\n    this.id = id;\n    this.controller = controller;\n    this.revoked = revoked;\n    // this.type is set in subclass constructor\n  }\n\n  /* eslint-disable jsdoc/check-param-names */\n  /**\n   * Generates a new public/private key pair instance.\n   * Note that this method is not typically called directly by client code,\n   * but instead is used through a `cryptoLd` instance.\n   *\n   * @param {object} options - Suite-specific options for the KeyPair. For\n   *   common options, see the `LDKeyPair.constructor()` docstring.\n   *\n   * @returns {Promise<LDKeyPair>} An LDKeyPair instance.\n   */\n  /* eslint-enable */\n  static async generate(/* options */) {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /**\n   * Imports a key pair instance from a provided externally fetched key\n   * document (fetched via a secure JSON-LD `documentLoader` or via\n   * `cryptoLd.fromKeyId()`), optionally checking it for revocation and required\n   * context.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.document - Externally fetched key document.\n   * @param {boolean} [options.checkContext=true] - Whether to check that the\n   *   fetched key document contains the context required by the key's crypto\n   *   suite.\n   * @param {boolean} [options.checkRevoked=true] - Whether to check the key\n   *   object for the presence of the `revoked` timestamp.\n   *\n   * @returns {Promise<LDKeyPair>} Resolves with the resulting key pair\n   *   instance.\n   */\n  static async fromKeyDocument({\n    document, checkContext = true, checkRevoked = true\n  } = {}) {\n    if(!document) {\n      throw new TypeError('The \"document\" parameter is required.');\n    }\n\n    if(checkContext) {\n      const fetchedDocContexts = [].concat(document['@context']);\n      if(!fetchedDocContexts.includes(this.SUITE_CONTEXT)) {\n        throw new Error('Key document does not contain required context \"' +\n          this.SUITE_CONTEXT + '\".');\n      }\n    }\n    if(checkRevoked && document.revoked) {\n      throw new Error(`Key has been revoked since: \"${document.revoked}\".`);\n    }\n    return this.from(document);\n  }\n\n  /* eslint-disable jsdoc/check-param-names */\n  /**\n   * Generates a KeyPair from some options.\n   *\n   * @param {object} options  - Will generate a key pair in multiple different\n   *   formats.\n   * @example\n   * > const options = {\n   *    type: 'Ed25519VerificationKey2020'\n   *   };\n   * > const edKeyPair = await LDKeyPair.from(options);\n   *\n   * @returns {Promise<LDKeyPair>} A LDKeyPair.\n   * @throws Unsupported Key Type.\n   */\n  /* eslint-enable */\n  static async from(/* options */) {\n    throw new Error('Abstract method from() must be implemented in subclass.');\n  }\n\n  /**\n   * Exports the serialized representation of the KeyPair\n   * and other information that json-ld Signatures can use to form a proof.\n   *\n   * NOTE: Subclasses MUST override this method (and add the exporting of\n   * their public and private key material).\n   *\n   * @param {object} [options={}] - Options hashmap.\n   * @param {boolean} [options.publicKey] - Export public key material?\n   * @param {boolean} [options.privateKey] - Export private key material?\n   *\n   * @returns {object} A public key object\n   *   information used in verification methods by signatures.\n   */\n  export({publicKey = false, privateKey = false} = {}) {\n    if(!publicKey && !privateKey) {\n      throw new Error(\n        'Export requires specifying either \"publicKey\" or \"privateKey\".');\n    }\n    const key = {\n      id: this.id,\n      type: this.type,\n      controller: this.controller\n    };\n    if(this.revoked) {\n      key.revoked = this.revoked;\n    }\n\n    return key;\n  }\n\n  /**\n   * Returns the public key fingerprint, multibase+multicodec encoded. The\n   * specific fingerprint method is determined by the key suite, and is often\n   * either a hash of the public key material (such as with RSA), or the\n   * full encoded public key (for key types with sufficiently short\n   * representations, such as ed25519).\n   * This is frequently used in initializing the key id, or generating some\n   * types of cryptonym DIDs.\n   *\n   * @returns {string} The fingerprint.\n   */\n  fingerprint() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /* eslint-disable jsdoc/check-param-names */\n  /**\n   * Verifies that a given key fingerprint matches the public key material\n   * belonging to this key pair.\n   *\n   * @param {string} fingerprint - Public key fingerprint.\n   *\n   * @returns {{verified: boolean}} An object with verified flag.\n   */\n  /* eslint-enable */\n  verifyFingerprint(/* {fingerprint} */) {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a signer object for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * NOTE: Applies only to verifier type keys (like ed25519).\n   *\n   * @example\n   * > const signer = keyPair.signer();\n   * > signer\n   * { sign: [AsyncFunction: sign] }\n   * > signer.sign({data});\n   *\n   * @returns {{sign: Function}} A signer for json-ld usage.\n   */\n  /* eslint-enable */\n  signer() {\n    return {\n      async sign({/* data */}) {\n        throw new Error('Abstract method, must be implemented in subclass.');\n      }\n    };\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a verifier object for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * NOTE: Applies only to verifier type keys (like ed25519).\n   *\n   * @example\n   * > const verifier = keyPair.verifier();\n   * > verifier\n   * { verify: [AsyncFunction: verify] }\n   * > verifier.verify(key);\n   *\n   * @returns {{verify: Function}} Used to verify jsonld-signatures.\n   */\n  /* eslint-enable */\n  verifier() {\n    return {\n      async verify({/* data, signature */}) {\n        throw new Error('Abstract method, must be implemented in subclass.');\n      }\n    };\n  }\n}\n\n// Implementers must override this in subclasses\nLDKeyPair.SUITE_CONTEXT = 'INVALID LDKeyPair CONTEXT';\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/LDKeyPair.js?");

/***/ }),

/***/ "./node_modules/crypto-ld/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-ld/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CryptoLD: () => (/* reexport safe */ _CryptoLD_js__WEBPACK_IMPORTED_MODULE_0__.CryptoLD),\n/* harmony export */   LDKeyPair: () => (/* reexport safe */ _LDKeyPair_js__WEBPACK_IMPORTED_MODULE_1__.LDKeyPair)\n/* harmony export */ });\n/* harmony import */ var _CryptoLD_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CryptoLD.js */ \"./node_modules/crypto-ld/lib/CryptoLD.js\");\n/* harmony import */ var _LDKeyPair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LDKeyPair.js */ \"./node_modules/crypto-ld/lib/LDKeyPair.js\");\n/*\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/crypto-ld/lib/index.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/index.js":
/*!*************************************************!*\
  !*** ./node_modules/jose/dist/browser/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompactEncrypt: () => (/* reexport safe */ _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_9__.CompactEncrypt),\n/* harmony export */   CompactSign: () => (/* reexport safe */ _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_11__.CompactSign),\n/* harmony export */   EmbeddedJWK: () => (/* reexport safe */ _jwk_embedded_js__WEBPACK_IMPORTED_MODULE_17__.EmbeddedJWK),\n/* harmony export */   EncryptJWT: () => (/* reexport safe */ _jwt_encrypt_js__WEBPACK_IMPORTED_MODULE_15__.EncryptJWT),\n/* harmony export */   FlattenedEncrypt: () => (/* reexport safe */ _jwe_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_10__.FlattenedEncrypt),\n/* harmony export */   FlattenedSign: () => (/* reexport safe */ _jws_flattened_sign_js__WEBPACK_IMPORTED_MODULE_12__.FlattenedSign),\n/* harmony export */   GeneralEncrypt: () => (/* reexport safe */ _jwe_general_encrypt_js__WEBPACK_IMPORTED_MODULE_3__.GeneralEncrypt),\n/* harmony export */   GeneralSign: () => (/* reexport safe */ _jws_general_sign_js__WEBPACK_IMPORTED_MODULE_13__.GeneralSign),\n/* harmony export */   SignJWT: () => (/* reexport safe */ _jwt_sign_js__WEBPACK_IMPORTED_MODULE_14__.SignJWT),\n/* harmony export */   UnsecuredJWT: () => (/* reexport safe */ _jwt_unsecured_js__WEBPACK_IMPORTED_MODULE_20__.UnsecuredJWT),\n/* harmony export */   base64url: () => (/* reexport module object */ _util_base64url_js__WEBPACK_IMPORTED_MODULE_28__),\n/* harmony export */   calculateJwkThumbprint: () => (/* reexport safe */ _jwk_thumbprint_js__WEBPACK_IMPORTED_MODULE_16__.calculateJwkThumbprint),\n/* harmony export */   calculateJwkThumbprintUri: () => (/* reexport safe */ _jwk_thumbprint_js__WEBPACK_IMPORTED_MODULE_16__.calculateJwkThumbprintUri),\n/* harmony export */   compactDecrypt: () => (/* reexport safe */ _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.compactDecrypt),\n/* harmony export */   compactVerify: () => (/* reexport safe */ _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_4__.compactVerify),\n/* harmony export */   createLocalJWKSet: () => (/* reexport safe */ _jwks_local_js__WEBPACK_IMPORTED_MODULE_18__.createLocalJWKSet),\n/* harmony export */   createRemoteJWKSet: () => (/* reexport safe */ _jwks_remote_js__WEBPACK_IMPORTED_MODULE_19__.createRemoteJWKSet),\n/* harmony export */   cryptoRuntime: () => (/* reexport safe */ _util_runtime_js__WEBPACK_IMPORTED_MODULE_29__[\"default\"]),\n/* harmony export */   decodeJwt: () => (/* reexport safe */ _util_decode_jwt_js__WEBPACK_IMPORTED_MODULE_24__.decodeJwt),\n/* harmony export */   decodeProtectedHeader: () => (/* reexport safe */ _util_decode_protected_header_js__WEBPACK_IMPORTED_MODULE_23__.decodeProtectedHeader),\n/* harmony export */   errors: () => (/* reexport module object */ _util_errors_js__WEBPACK_IMPORTED_MODULE_25__),\n/* harmony export */   exportJWK: () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_21__.exportJWK),\n/* harmony export */   exportPKCS8: () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_21__.exportPKCS8),\n/* harmony export */   exportSPKI: () => (/* reexport safe */ _key_export_js__WEBPACK_IMPORTED_MODULE_21__.exportSPKI),\n/* harmony export */   flattenedDecrypt: () => (/* reexport safe */ _jwe_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_1__.flattenedDecrypt),\n/* harmony export */   flattenedVerify: () => (/* reexport safe */ _jws_flattened_verify_js__WEBPACK_IMPORTED_MODULE_5__.flattenedVerify),\n/* harmony export */   generalDecrypt: () => (/* reexport safe */ _jwe_general_decrypt_js__WEBPACK_IMPORTED_MODULE_2__.generalDecrypt),\n/* harmony export */   generalVerify: () => (/* reexport safe */ _jws_general_verify_js__WEBPACK_IMPORTED_MODULE_6__.generalVerify),\n/* harmony export */   generateKeyPair: () => (/* reexport safe */ _key_generate_key_pair_js__WEBPACK_IMPORTED_MODULE_26__.generateKeyPair),\n/* harmony export */   generateSecret: () => (/* reexport safe */ _key_generate_secret_js__WEBPACK_IMPORTED_MODULE_27__.generateSecret),\n/* harmony export */   importJWK: () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_22__.importJWK),\n/* harmony export */   importPKCS8: () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_22__.importPKCS8),\n/* harmony export */   importSPKI: () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_22__.importSPKI),\n/* harmony export */   importX509: () => (/* reexport safe */ _key_import_js__WEBPACK_IMPORTED_MODULE_22__.importX509),\n/* harmony export */   jwtDecrypt: () => (/* reexport safe */ _jwt_decrypt_js__WEBPACK_IMPORTED_MODULE_8__.jwtDecrypt),\n/* harmony export */   jwtVerify: () => (/* reexport safe */ _jwt_verify_js__WEBPACK_IMPORTED_MODULE_7__.jwtVerify)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jwe/compact/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/decrypt.js\");\n/* harmony import */ var _jwe_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jwe/flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _jwe_general_decrypt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jwe/general/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/general/decrypt.js\");\n/* harmony import */ var _jwe_general_encrypt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jwe/general/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/general/encrypt.js\");\n/* harmony import */ var _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jws/compact/verify.js */ \"./node_modules/jose/dist/browser/jws/compact/verify.js\");\n/* harmony import */ var _jws_flattened_verify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jws/flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _jws_general_verify_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./jws/general/verify.js */ \"./node_modules/jose/dist/browser/jws/general/verify.js\");\n/* harmony import */ var _jwt_verify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./jwt/verify.js */ \"./node_modules/jose/dist/browser/jwt/verify.js\");\n/* harmony import */ var _jwt_decrypt_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./jwt/decrypt.js */ \"./node_modules/jose/dist/browser/jwt/decrypt.js\");\n/* harmony import */ var _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./jwe/compact/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/encrypt.js\");\n/* harmony import */ var _jwe_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./jwe/flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n/* harmony import */ var _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./jws/compact/sign.js */ \"./node_modules/jose/dist/browser/jws/compact/sign.js\");\n/* harmony import */ var _jws_flattened_sign_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./jws/flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n/* harmony import */ var _jws_general_sign_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./jws/general/sign.js */ \"./node_modules/jose/dist/browser/jws/general/sign.js\");\n/* harmony import */ var _jwt_sign_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./jwt/sign.js */ \"./node_modules/jose/dist/browser/jwt/sign.js\");\n/* harmony import */ var _jwt_encrypt_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./jwt/encrypt.js */ \"./node_modules/jose/dist/browser/jwt/encrypt.js\");\n/* harmony import */ var _jwk_thumbprint_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./jwk/thumbprint.js */ \"./node_modules/jose/dist/browser/jwk/thumbprint.js\");\n/* harmony import */ var _jwk_embedded_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./jwk/embedded.js */ \"./node_modules/jose/dist/browser/jwk/embedded.js\");\n/* harmony import */ var _jwks_local_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./jwks/local.js */ \"./node_modules/jose/dist/browser/jwks/local.js\");\n/* harmony import */ var _jwks_remote_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./jwks/remote.js */ \"./node_modules/jose/dist/browser/jwks/remote.js\");\n/* harmony import */ var _jwt_unsecured_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./jwt/unsecured.js */ \"./node_modules/jose/dist/browser/jwt/unsecured.js\");\n/* harmony import */ var _key_export_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./key/export.js */ \"./node_modules/jose/dist/browser/key/export.js\");\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _util_decode_protected_header_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./util/decode_protected_header.js */ \"./node_modules/jose/dist/browser/util/decode_protected_header.js\");\n/* harmony import */ var _util_decode_jwt_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./util/decode_jwt.js */ \"./node_modules/jose/dist/browser/util/decode_jwt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _key_generate_key_pair_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./key/generate_key_pair.js */ \"./node_modules/jose/dist/browser/key/generate_key_pair.js\");\n/* harmony import */ var _key_generate_secret_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./key/generate_secret.js */ \"./node_modules/jose/dist/browser/key/generate_secret.js\");\n/* harmony import */ var _util_base64url_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./util/base64url.js */ \"./node_modules/jose/dist/browser/util/base64url.js\");\n/* harmony import */ var _util_runtime_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./util/runtime.js */ \"./node_modules/jose/dist/browser/util/runtime.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/index.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/compact/decrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/compact/decrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compactDecrypt: () => (/* binding */ compactDecrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\n\n\nasync function compactDecrypt(jwe, key, options) {\n    if (jwe instanceof Uint8Array) {\n        jwe = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.decoder.decode(jwe);\n    }\n    if (typeof jwe !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('Compact JWE must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length, } = jwe.split('.');\n    if (length !== 5) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('Invalid Compact JWE');\n    }\n    const decrypted = await (0,_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.flattenedDecrypt)({\n        ciphertext,\n        iv: iv || undefined,\n        protected: protectedHeader,\n        tag: tag || undefined,\n        encrypted_key: encryptedKey || undefined,\n    }, key, options);\n    const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/compact/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/compact/encrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/compact/encrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompactEncrypt: () => (/* binding */ CompactEncrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n\nclass CompactEncrypt {\n    constructor(plaintext) {\n        this._flattened = new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(plaintext);\n    }\n    setContentEncryptionKey(cek) {\n        this._flattened.setContentEncryptionKey(cek);\n        return this;\n    }\n    setInitializationVector(iv) {\n        this._flattened.setInitializationVector(iv);\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        this._flattened.setKeyManagementParameters(parameters);\n        return this;\n    }\n    async encrypt(key, options) {\n        const jwe = await this._flattened.encrypt(key, options);\n        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join('.');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/compact/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/flattened/decrypt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/flattened/decrypt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flattenedDecrypt: () => (/* binding */ flattenedDecrypt)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/decrypt.js */ \"./node_modules/jose/dist/browser/runtime/decrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_decrypt_key_management_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/decrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/decrypt_key_management.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n/* harmony import */ var _lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../lib/validate_algorithms.js */ \"./node_modules/jose/dist/browser/lib/validate_algorithms.js\");\n\n\n\n\n\n\n\n\n\n\nasync function flattenedDecrypt(jwe, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwe)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Flattened JWE must be an object');\n    }\n    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JOSE Header missing');\n    }\n    if (jwe.iv !== undefined && typeof jwe.iv !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Initialization Vector incorrect type');\n    }\n    if (typeof jwe.ciphertext !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Ciphertext missing or incorrect type');\n    }\n    if (jwe.tag !== undefined && typeof jwe.tag !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Authentication Tag incorrect type');\n    }\n    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Protected Header incorrect type');\n    }\n    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Encrypted Key incorrect type');\n    }\n    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE AAD incorrect type');\n    }\n    if (jwe.header !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwe.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Shared Unprotected Header incorrect type');\n    }\n    if (jwe.unprotected !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwe.unprotected)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');\n    }\n    let parsedProt;\n    if (jwe.protected) {\n        try {\n            const protectedHeader = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.protected);\n            parsedProt = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__.decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Protected Header is invalid');\n        }\n    }\n    if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(parsedProt, jwe.header, jwe.unprotected)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jwe.header,\n        ...jwe.unprotected,\n    };\n    (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid, new Map(), options?.crit, parsedProt, joseHeader);\n    if (joseHeader.zip !== undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n    }\n    const { alg, enc } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');\n    }\n    if (typeof enc !== 'string' || !enc) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');\n    }\n    const keyManagementAlgorithms = options && (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])('keyManagementAlgorithms', options.keyManagementAlgorithms);\n    const contentEncryptionAlgorithms = options &&\n        (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);\n    if ((keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) ||\n        (!keyManagementAlgorithms && alg.startsWith('PBES2'))) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSEAlgNotAllowed('\"enc\" (Encryption Algorithm) Header Parameter value not allowed');\n    }\n    let encryptedKey;\n    if (jwe.encrypted_key !== undefined) {\n        try {\n            encryptedKey = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.encrypted_key);\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Failed to base64url decode the encrypted_key');\n        }\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jwe);\n        resolvedKey = true;\n    }\n    let cek;\n    try {\n        cek = await (0,_lib_decrypt_key_management_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(alg, key, encryptedKey, joseHeader, options);\n    }\n    catch (err) {\n        if (err instanceof TypeError || err instanceof _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid || err instanceof _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported) {\n            throw err;\n        }\n        cek = (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(enc);\n    }\n    let iv;\n    let tag;\n    if (jwe.iv !== undefined) {\n        try {\n            iv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.iv);\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Failed to base64url decode the iv');\n        }\n    }\n    if (jwe.tag !== undefined) {\n        try {\n            tag = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.tag);\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Failed to base64url decode the tag');\n        }\n    }\n    const protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__.encoder.encode(jwe.protected ?? '');\n    let additionalData;\n    if (jwe.aad !== undefined) {\n        additionalData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__.encoder.encode('.'), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_6__.encoder.encode(jwe.aad));\n    }\n    else {\n        additionalData = protectedHeader;\n    }\n    let ciphertext;\n    try {\n        ciphertext = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.ciphertext);\n    }\n    catch {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Failed to base64url decode the ciphertext');\n    }\n    const plaintext = await (0,_runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, cek, ciphertext, iv, tag, additionalData);\n    const result = { plaintext };\n    if (jwe.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jwe.aad !== undefined) {\n        try {\n            result.additionalAuthenticatedData = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwe.aad);\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWEInvalid('Failed to base64url decode the aad');\n        }\n    }\n    if (jwe.unprotected !== undefined) {\n        result.sharedUnprotectedHeader = jwe.unprotected;\n    }\n    if (jwe.header !== undefined) {\n        result.unprotectedHeader = jwe.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/flattened/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/flattened/encrypt.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/flattened/encrypt.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlattenedEncrypt: () => (/* binding */ FlattenedEncrypt),\n/* harmony export */   unprotected: () => (/* binding */ unprotected)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/encrypt.js */ \"./node_modules/jose/dist/browser/runtime/encrypt.js\");\n/* harmony import */ var _lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/encrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/encrypt_key_management.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\nconst unprotected = Symbol();\nclass FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid, new Map(), options?.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (this._cek && (alg === 'dir' || alg === 'ECDH-ES')) {\n            throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${alg}`);\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await (0,_lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else if (!this._protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                }\n                else {\n                    this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                }\n            }\n        }\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(this._aad);\n            additionalData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.encoder.encode('.'), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        const { ciphertext, tag, iv } = await (0,_runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, this._plaintext, cek, this._iv, additionalData);\n        const jwe = {\n            ciphertext: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(ciphertext),\n        };\n        if (iv) {\n            jwe.iv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(iv);\n        }\n        if (tag) {\n            jwe.tag = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(tag);\n        }\n        if (encryptedKey) {\n            jwe.encrypted_key = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_5__.decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/flattened/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/general/decrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/general/decrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generalDecrypt: () => (/* binding */ generalDecrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/decrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nasync function generalDecrypt(jwe, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(jwe)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('General JWE must be an object');\n    }\n    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Recipients missing or incorrect type');\n    }\n    if (!jwe.recipients.length) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Recipients has no members');\n    }\n    for (const recipient of jwe.recipients) {\n        try {\n            return await (0,_flattened_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.flattenedDecrypt)({\n                aad: jwe.aad,\n                ciphertext: jwe.ciphertext,\n                encrypted_key: recipient.encrypted_key,\n                header: recipient.header,\n                iv: jwe.iv,\n                protected: jwe.protected,\n                tag: jwe.tag,\n                unprotected: jwe.unprotected,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEDecryptionFailed();\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/general/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwe/general/encrypt.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwe/general/encrypt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeneralEncrypt: () => (/* binding */ GeneralEncrypt)\n/* harmony export */ });\n/* harmony import */ var _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/flattened/encrypt.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/encrypt_key_management.js */ \"./node_modules/jose/dist/browser/lib/encrypt_key_management.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nclass GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options?.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt() {\n        if (!this._recipients.length) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('at least one recipient must be added');\n        }\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options });\n            const jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n            }\n        }\n        const cek = (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(enc);\n        const jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new _flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    [_flattened_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await (0,_lib_encrypt_key_management_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(recipient.unprotectedHeader?.alg ||\n                this._protectedHeader?.alg ||\n                this._unprotectedHeader?.alg, enc, recipient.key, cek, { p2c });\n            target.encrypted_key = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_5__.encode)(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwe/general/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwk/embedded.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwk/embedded.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmbeddedJWK: () => (/* binding */ EmbeddedJWK)\n/* harmony export */ });\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function EmbeddedJWK(protectedHeader, token) {\n    const joseHeader = {\n        ...protectedHeader,\n        ...token?.header,\n    };\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(joseHeader.jwk)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a JSON object');\n    }\n    const key = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_0__.importJWK)({ ...joseHeader.jwk, ext: true }, joseHeader.alg);\n    if (key instanceof Uint8Array || key.type !== 'public') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('\"jwk\" (JSON Web Key) Header Parameter must be a public key');\n    }\n    return key;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwk/embedded.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwk/thumbprint.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwk/thumbprint.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateJwkThumbprint: () => (/* binding */ calculateJwkThumbprint),\n/* harmony export */   calculateJwkThumbprintUri: () => (/* binding */ calculateJwkThumbprintUri)\n/* harmony export */ });\n/* harmony import */ var _runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/digest.js */ \"./node_modules/jose/dist/browser/runtime/digest.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\nconst check = (value, description) => {\n    if (typeof value !== 'string' || !value) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWKInvalid(`${description} missing or invalid`);\n    }\n};\nasync function calculateJwkThumbprint(jwk, digestAlgorithm) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    digestAlgorithm ?? (digestAlgorithm = 'sha256');\n    if (digestAlgorithm !== 'sha256' &&\n        digestAlgorithm !== 'sha384' &&\n        digestAlgorithm !== 'sha512') {\n        throw new TypeError('digestAlgorithm must one of \"sha256\", \"sha384\", or \"sha512\"');\n    }\n    let components;\n    switch (jwk.kty) {\n        case 'EC':\n            check(jwk.crv, '\"crv\" (Curve) Parameter');\n            check(jwk.x, '\"x\" (X Coordinate) Parameter');\n            check(jwk.y, '\"y\" (Y Coordinate) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };\n            break;\n        case 'OKP':\n            check(jwk.crv, '\"crv\" (Subtype of Key Pair) Parameter');\n            check(jwk.x, '\"x\" (Public Key) Parameter');\n            components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };\n            break;\n        case 'RSA':\n            check(jwk.e, '\"e\" (Exponent) Parameter');\n            check(jwk.n, '\"n\" (Modulus) Parameter');\n            components = { e: jwk.e, kty: jwk.kty, n: jwk.n };\n            break;\n        case 'oct':\n            check(jwk.k, '\"k\" (Key Value) Parameter');\n            components = { k: jwk.k, kty: jwk.kty };\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSENotSupported('\"kty\" (Key Type) Parameter missing or unsupported');\n    }\n    const data = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(JSON.stringify(components));\n    return (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_1__.encode)(await (0,_runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(digestAlgorithm, data));\n}\nasync function calculateJwkThumbprintUri(jwk, digestAlgorithm) {\n    digestAlgorithm ?? (digestAlgorithm = 'sha256');\n    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);\n    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwk/thumbprint.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwks/local.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwks/local.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalJWKSet: () => (/* binding */ LocalJWKSet),\n/* harmony export */   createLocalJWKSet: () => (/* binding */ createLocalJWKSet)\n/* harmony export */ });\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nfunction getKtyFromAlg(alg) {\n    switch (typeof alg === 'string' && alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            return 'RSA';\n        case 'ES':\n            return 'EC';\n        case 'Ed':\n            return 'OKP';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Unsupported \"alg\" value for a JSON Web Key Set');\n    }\n}\nfunction isJWKSLike(jwks) {\n    return (jwks &&\n        typeof jwks === 'object' &&\n        Array.isArray(jwks.keys) &&\n        jwks.keys.every(isJWKLike));\n}\nfunction isJWKLike(key) {\n    return (0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key);\n}\nfunction clone(obj) {\n    if (typeof structuredClone === 'function') {\n        return structuredClone(obj);\n    }\n    return JSON.parse(JSON.stringify(obj));\n}\nclass LocalJWKSet {\n    constructor(jwks) {\n        this._cached = new WeakMap();\n        if (!isJWKSLike(jwks)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWKSInvalid('JSON Web Key Set malformed');\n        }\n        this._jwks = clone(jwks);\n    }\n    async getKey(protectedHeader, token) {\n        const { alg, kid } = { ...protectedHeader, ...token?.header };\n        const kty = getKtyFromAlg(alg);\n        const candidates = this._jwks.keys.filter((jwk) => {\n            let candidate = kty === jwk.kty;\n            if (candidate && typeof kid === 'string') {\n                candidate = kid === jwk.kid;\n            }\n            if (candidate && typeof jwk.alg === 'string') {\n                candidate = alg === jwk.alg;\n            }\n            if (candidate && typeof jwk.use === 'string') {\n                candidate = jwk.use === 'sig';\n            }\n            if (candidate && Array.isArray(jwk.key_ops)) {\n                candidate = jwk.key_ops.includes('verify');\n            }\n            if (candidate && alg === 'EdDSA') {\n                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';\n            }\n            if (candidate) {\n                switch (alg) {\n                    case 'ES256':\n                        candidate = jwk.crv === 'P-256';\n                        break;\n                    case 'ES256K':\n                        candidate = jwk.crv === 'secp256k1';\n                        break;\n                    case 'ES384':\n                        candidate = jwk.crv === 'P-384';\n                        break;\n                    case 'ES512':\n                        candidate = jwk.crv === 'P-521';\n                        break;\n                }\n            }\n            return candidate;\n        });\n        const { 0: jwk, length } = candidates;\n        if (length === 0) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWKSNoMatchingKey();\n        }\n        if (length !== 1) {\n            const error = new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWKSMultipleMatchingKeys();\n            const { _cached } = this;\n            error[Symbol.asyncIterator] = async function* () {\n                for (const jwk of candidates) {\n                    try {\n                        yield await importWithAlgCache(_cached, jwk, alg);\n                    }\n                    catch { }\n                }\n            };\n            throw error;\n        }\n        return importWithAlgCache(this._cached, jwk, alg);\n    }\n}\nasync function importWithAlgCache(cache, jwk, alg) {\n    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);\n    if (cached[alg] === undefined) {\n        const key = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_0__.importJWK)({ ...jwk, ext: true }, alg);\n        if (key instanceof Uint8Array || key.type !== 'public') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWKSInvalid('JSON Web Key Set members must be public keys');\n        }\n        cached[alg] = key;\n    }\n    return cached[alg];\n}\nfunction createLocalJWKSet(jwks) {\n    const set = new LocalJWKSet(jwks);\n    const localJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(localJWKSet, {\n        jwks: {\n            value: () => clone(set._jwks),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return localJWKSet;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwks/local.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwks/remote.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwks/remote.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRemoteJWKSet: () => (/* binding */ createRemoteJWKSet)\n/* harmony export */ });\n/* harmony import */ var _runtime_fetch_jwks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/fetch_jwks.js */ \"./node_modules/jose/dist/browser/runtime/fetch_jwks.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _local_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local.js */ \"./node_modules/jose/dist/browser/jwks/local.js\");\n\n\n\nfunction isCloudflareWorkers() {\n    return (typeof WebSocketPair !== 'undefined' ||\n        (typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers') ||\n        (typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel'));\n}\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'jose';\n    const VERSION = 'v5.3.0';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nclass RemoteJWKSet {\n    constructor(url, options) {\n        if (!(url instanceof URL)) {\n            throw new TypeError('url must be an instance of URL');\n        }\n        this._url = new URL(url.href);\n        this._options = { agent: options?.agent, headers: options?.headers };\n        this._timeoutDuration =\n            typeof options?.timeoutDuration === 'number' ? options?.timeoutDuration : 5000;\n        this._cooldownDuration =\n            typeof options?.cooldownDuration === 'number' ? options?.cooldownDuration : 30000;\n        this._cacheMaxAge = typeof options?.cacheMaxAge === 'number' ? options?.cacheMaxAge : 600000;\n    }\n    coolingDown() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cooldownDuration\n            : false;\n    }\n    fresh() {\n        return typeof this._jwksTimestamp === 'number'\n            ? Date.now() < this._jwksTimestamp + this._cacheMaxAge\n            : false;\n    }\n    async getKey(protectedHeader, token) {\n        if (!this._local || !this.fresh()) {\n            await this.reload();\n        }\n        try {\n            return await this._local(protectedHeader, token);\n        }\n        catch (err) {\n            if (err instanceof _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWKSNoMatchingKey) {\n                if (this.coolingDown() === false) {\n                    await this.reload();\n                    return this._local(protectedHeader, token);\n                }\n            }\n            throw err;\n        }\n    }\n    async reload() {\n        if (this._pendingFetch && isCloudflareWorkers()) {\n            this._pendingFetch = undefined;\n        }\n        const headers = new Headers(this._options.headers);\n        if (USER_AGENT && !headers.has('User-Agent')) {\n            headers.set('User-Agent', USER_AGENT);\n            this._options.headers = Object.fromEntries(headers.entries());\n        }\n        this._pendingFetch || (this._pendingFetch = (0,_runtime_fetch_jwks_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._url, this._timeoutDuration, this._options)\n            .then((json) => {\n            this._local = (0,_local_js__WEBPACK_IMPORTED_MODULE_2__.createLocalJWKSet)(json);\n            this._jwksTimestamp = Date.now();\n            this._pendingFetch = undefined;\n        })\n            .catch((err) => {\n            this._pendingFetch = undefined;\n            throw err;\n        }));\n        await this._pendingFetch;\n    }\n}\nfunction createRemoteJWKSet(url, options) {\n    const set = new RemoteJWKSet(url, options);\n    const remoteJWKSet = async (protectedHeader, token) => set.getKey(protectedHeader, token);\n    Object.defineProperties(remoteJWKSet, {\n        coolingDown: {\n            get: () => set.coolingDown(),\n            enumerable: true,\n            configurable: false,\n        },\n        fresh: {\n            get: () => set.fresh(),\n            enumerable: true,\n            configurable: false,\n        },\n        reload: {\n            value: () => set.reload(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n        reloading: {\n            get: () => !!set._pendingFetch,\n            enumerable: true,\n            configurable: false,\n        },\n        jwks: {\n            value: () => set._local?.jwks(),\n            enumerable: true,\n            configurable: false,\n            writable: false,\n        },\n    });\n    return remoteJWKSet;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwks/remote.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/compact/sign.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/compact/sign.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompactSign: () => (/* binding */ CompactSign)\n/* harmony export */ });\n/* harmony import */ var _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n\nclass CompactSign {\n    constructor(payload) {\n        this._flattened = new _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/compact/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/compact/verify.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/compact/verify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compactVerify: () => (/* binding */ compactVerify)\n/* harmony export */ });\n/* harmony import */ var _flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\n\n\nasync function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await (0,_flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__.flattenedVerify)({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/compact/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/flattened/sign.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/flattened/sign.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlattenedSign: () => (/* binding */ FlattenedSign)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_sign_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/sign.js */ \"./node_modules/jose/dist/browser/runtime/sign.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n\n\n\n\n\n\n\nclass FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this._protectedHeader, this._unprotectedHeader)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid, new Map([['b64', true]]), options?.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        (0,_lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode((0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode('');\n        }\n        const data = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.concat)(protectedHeader, _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.encoder.encode('.'), payload);\n        const signature = await (0,_runtime_sign_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alg, key, data);\n        const jws = {\n            signature: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode)(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_4__.decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/flattened/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/flattened/verify.js":
/*!****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/flattened/verify.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flattenedVerify: () => (/* binding */ flattenedVerify)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_verify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../runtime/verify.js */ \"./node_modules/jose/dist/browser/runtime/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/is_disjoint.js */ \"./node_modules/jose/dist/browser/lib/is_disjoint.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/validate_crit.js */ \"./node_modules/jose/dist/browser/lib/validate_crit.js\");\n/* harmony import */ var _lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../lib/validate_algorithms.js */ \"./node_modules/jose/dist/browser/lib/validate_algorithms.js\");\n\n\n\n\n\n\n\n\n\nasync function flattenedVerify(jws, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jws)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(jws.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.protected);\n            parsedProt = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!(0,_lib_is_disjoint_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(parsedProt, jws.header)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = (0,_lib_validate_crit_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(_util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && (0,_lib_validate_algorithms_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    (0,_lib_check_key_type_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(alg, key, 'verify');\n    const data = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.concat)(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(jws.protected ?? ''), _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode('.'), typeof jws.payload === 'string' ? _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.signature);\n    }\n    catch {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await (0,_runtime_verify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alg, key, signature, data);\n    if (!verified) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jws.payload);\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_3__.encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/flattened/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/general/sign.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/general/sign.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeneralSign: () => (/* binding */ GeneralSign)\n/* harmony export */ });\n/* harmony import */ var _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/sign.js */ \"./node_modules/jose/dist/browser/jws/flattened/sign.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nclass GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new _flattened_sign_js__WEBPACK_IMPORTED_MODULE_0__.FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('inconsistent use of JWS Unencoded Payload (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/general/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jws/general/verify.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/jws/general/verify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generalVerify: () => (/* binding */ generalVerify)\n/* harmony export */ });\n/* harmony import */ var _flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flattened/verify.js */ \"./node_modules/jose/dist/browser/jws/flattened/verify.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nasync function generalVerify(jws, key, options) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(jws)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('General JWS must be an object');\n    }\n    if (!Array.isArray(jws.signatures) || !jws.signatures.every(_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSInvalid('JWS Signatures missing or incorrect type');\n    }\n    for (const signature of jws.signatures) {\n        try {\n            return await (0,_flattened_verify_js__WEBPACK_IMPORTED_MODULE_0__.flattenedVerify)({\n                header: signature.header,\n                payload: jws.payload,\n                protected: signature.protected,\n                signature: signature.signature,\n            }, key, options);\n        }\n        catch {\n        }\n    }\n    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWSSignatureVerificationFailed();\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jws/general/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/decrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/decrypt.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jwtDecrypt: () => (/* binding */ jwtDecrypt)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jwe/compact/decrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/decrypt.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function jwtDecrypt(jwt, key, options) {\n    const decrypted = await (0,_jwe_compact_decrypt_js__WEBPACK_IMPORTED_MODULE_0__.compactDecrypt)(jwt, key, options);\n    const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(decrypted.protectedHeader, decrypted.plaintext, options);\n    const { protectedHeader } = decrypted;\n    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"iss\" claim header parameter mismatch', 'iss', 'mismatch');\n    }\n    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"sub\" claim header parameter mismatch', 'sub', 'mismatch');\n    }\n    if (protectedHeader.aud !== undefined &&\n        JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTClaimValidationFailed('replicated \"aud\" claim header parameter mismatch', 'aud', 'mismatch');\n    }\n    const result = { payload, protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: decrypted.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/encrypt.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/encrypt.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptJWT: () => (/* binding */ EncryptJWT)\n/* harmony export */ });\n/* harmony import */ var _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jwe/compact/encrypt.js */ \"./node_modules/jose/dist/browser/jwe/compact/encrypt.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\nclass EncryptJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_2__.ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    replicateIssuerAsHeader() {\n        this._replicateIssuerAsHeader = true;\n        return this;\n    }\n    replicateSubjectAsHeader() {\n        this._replicateSubjectAsHeader = true;\n        return this;\n    }\n    replicateAudienceAsHeader() {\n        this._replicateAudienceAsHeader = true;\n        return this;\n    }\n    async encrypt(key, options) {\n        const enc = new _jwe_compact_encrypt_js__WEBPACK_IMPORTED_MODULE_0__.CompactEncrypt(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.encoder.encode(JSON.stringify(this._payload)));\n        if (this._replicateIssuerAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };\n        }\n        if (this._replicateSubjectAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };\n        }\n        if (this._replicateAudienceAsHeader) {\n            this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };\n        }\n        enc.setProtectedHeader(this._protectedHeader);\n        if (this._iv) {\n            enc.setInitializationVector(this._iv);\n        }\n        if (this._cek) {\n            enc.setContentEncryptionKey(this._cek);\n        }\n        if (this._keyManagementParameters) {\n            enc.setKeyManagementParameters(this._keyManagementParameters);\n        }\n        return enc.encrypt(key, options);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/produce.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/produce.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProduceJWT: () => (/* binding */ ProduceJWT)\n/* harmony export */ });\n/* harmony import */ var _lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/epoch.js */ \"./node_modules/jose/dist/browser/lib/epoch.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _lib_secs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/secs.js */ \"./node_modules/jose/dist/browser/lib/secs.js\");\n\n\n\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nclass ProduceJWT {\n    constructor(payload = {}) {\n        if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) + (0,_lib_secs_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, exp: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) + (0,_lib_secs_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) };\n        }\n        else if (typeof input === 'string') {\n            this._payload = {\n                ...this._payload,\n                iat: validateInput('setIssuedAt', (0,_lib_epoch_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Date()) + (0,_lib_secs_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input)),\n            };\n        }\n        else {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', input) };\n        }\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/produce.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/sign.js":
/*!****************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/sign.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignJWT: () => (/* binding */ SignJWT)\n/* harmony export */ });\n/* harmony import */ var _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jws/compact/sign.js */ \"./node_modules/jose/dist/browser/jws/compact/sign.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\n\nclass SignJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_3__.ProduceJWT {\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new _jws_compact_sign_js__WEBPACK_IMPORTED_MODULE_0__.CompactSign(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_2__.encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray(this._protectedHeader?.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/unsecured.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/unsecured.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnsecuredJWT: () => (/* binding */ UnsecuredJWT)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _produce_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./produce.js */ \"./node_modules/jose/dist/browser/jwt/produce.js\");\n\n\n\n\n\nclass UnsecuredJWT extends _produce_js__WEBPACK_IMPORTED_MODULE_4__.ProduceJWT {\n    encode() {\n        const header = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode(JSON.stringify({ alg: 'none' }));\n        const payload = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode(JSON.stringify(this._payload));\n        return `${header}.${payload}.`;\n    }\n    static decode(jwt, options) {\n        if (typeof jwt !== 'string') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Unsecured JWT must be a string');\n        }\n        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');\n        if (length !== 3 || signature !== '') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Invalid Unsecured JWT');\n        }\n        let header;\n        try {\n            header = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode(encodedHeader)));\n            if (header.alg !== 'none')\n                throw new Error();\n        }\n        catch {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('Invalid Unsecured JWT');\n        }\n        const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(header, _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode(encodedPayload), options);\n        return { payload, header };\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/unsecured.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/jwt/verify.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/jwt/verify.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jwtVerify: () => (/* binding */ jwtVerify)\n/* harmony export */ });\n/* harmony import */ var _jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../jws/compact/verify.js */ \"./node_modules/jose/dist/browser/jws/compact/verify.js\");\n/* harmony import */ var _lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/jwt_claims_set.js */ \"./node_modules/jose/dist/browser/lib/jwt_claims_set.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\nasync function jwtVerify(jwt, key, options) {\n    const verified = await (0,_jws_compact_verify_js__WEBPACK_IMPORTED_MODULE_0__.compactVerify)(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_2__.JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = (0,_lib_jwt_claims_set_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/jwt/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/export.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/export.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportJWK: () => (/* binding */ exportJWK),\n/* harmony export */   exportPKCS8: () => (/* binding */ exportPKCS8),\n/* harmony export */   exportSPKI: () => (/* binding */ exportSPKI)\n/* harmony export */ });\n/* harmony import */ var _runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/asn1.js */ \"./node_modules/jose/dist/browser/runtime/asn1.js\");\n/* harmony import */ var _runtime_key_to_jwk_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/key_to_jwk.js */ \"./node_modules/jose/dist/browser/runtime/key_to_jwk.js\");\n\n\n\nasync function exportSPKI(key) {\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__.toSPKI)(key);\n}\nasync function exportPKCS8(key) {\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_0__.toPKCS8)(key);\n}\nasync function exportJWK(key) {\n    return (0,_runtime_key_to_jwk_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/export.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/generate_key_pair.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/generate_key_pair.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair)\n/* harmony export */ });\n/* harmony import */ var _runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/generate.js */ \"./node_modules/jose/dist/browser/runtime/generate.js\");\n\nasync function generateKeyPair(alg, options) {\n    return (0,_runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__.generateKeyPair)(alg, options);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/generate_key_pair.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/generate_secret.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/generate_secret.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateSecret: () => (/* binding */ generateSecret)\n/* harmony export */ });\n/* harmony import */ var _runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/generate.js */ \"./node_modules/jose/dist/browser/runtime/generate.js\");\n\nasync function generateSecret(alg, options) {\n    return (0,_runtime_generate_js__WEBPACK_IMPORTED_MODULE_0__.generateSecret)(alg, options);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/generate_secret.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/key/import.js":
/*!******************************************************!*\
  !*** ./node_modules/jose/dist/browser/key/import.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   importJWK: () => (/* binding */ importJWK),\n/* harmony export */   importPKCS8: () => (/* binding */ importPKCS8),\n/* harmony export */   importSPKI: () => (/* binding */ importSPKI),\n/* harmony export */   importX509: () => (/* binding */ importX509)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/asn1.js */ \"./node_modules/jose/dist/browser/runtime/asn1.js\");\n/* harmony import */ var _runtime_jwk_to_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/jwk_to_key.js */ \"./node_modules/jose/dist/browser/runtime/jwk_to_key.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\nasync function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromSPKI)(spki, alg, options);\n}\nasync function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromX509)(x509, alg, options);\n}\nasync function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return (0,_runtime_asn1_js__WEBPACK_IMPORTED_MODULE_1__.fromPKCS8)(pkcs8, alg, options);\n}\nasync function importJWK(jwk, alg) {\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return (0,_runtime_jwk_to_key_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({ ...jwk, alg });\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_3__.JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/key/import.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/aesgcmkw.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/aesgcmkw.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/encrypt.js */ \"./node_modules/jose/dist/browser/runtime/encrypt.js\");\n/* harmony import */ var _runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/decrypt.js */ \"./node_modules/jose/dist/browser/runtime/decrypt.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n\n\n\nasync function wrap(alg, key, cek, iv) {\n    const jweAlgorithm = alg.slice(0, 7);\n    const wrapped = await (0,_runtime_encrypt_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(jweAlgorithm, cek, key, iv, new Uint8Array(0));\n    return {\n        encryptedKey: wrapped.ciphertext,\n        iv: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(wrapped.iv),\n        tag: (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(wrapped.tag),\n    };\n}\nasync function unwrap(alg, key, encryptedKey, iv, tag) {\n    const jweAlgorithm = alg.slice(0, 7);\n    return (0,_runtime_decrypt_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/aesgcmkw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/buffer_utils.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/buffer_utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   concatKdf: () => (/* binding */ concatKdf),\n/* harmony export */   decoder: () => (/* binding */ decoder),\n/* harmony export */   encoder: () => (/* binding */ encoder),\n/* harmony export */   lengthAndInput: () => (/* binding */ lengthAndInput),\n/* harmony export */   p2s: () => (/* binding */ p2s),\n/* harmony export */   uint32be: () => (/* binding */ uint32be),\n/* harmony export */   uint64be: () => (/* binding */ uint64be)\n/* harmony export */ });\n/* harmony import */ var _runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/digest.js */ \"./node_modules/jose/dist/browser/runtime/digest.js\");\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nfunction concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nfunction uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nfunction uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nfunction lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nasync function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await (0,_runtime_digest_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/buffer_utils.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/cek.js":
/*!***************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/cek.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _runtime_random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\nfunction bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n            return 128;\n        case 'A192GCM':\n            return 192;\n        case 'A256GCM':\n        case 'A128CBC-HS256':\n            return 256;\n        case 'A192CBC-HS384':\n            return 384;\n        case 'A256CBC-HS512':\n            return 512;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg) => (0,_runtime_random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Uint8Array(bitLength(alg) >> 3)));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/cek.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_iv_length.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_iv_length.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _iv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iv.js */ \"./node_modules/jose/dist/browser/lib/iv.js\");\n\n\nconst checkIvLength = (enc, iv) => {\n    if (iv.length << 3 !== (0,_iv_js__WEBPACK_IMPORTED_MODULE_1__.bitLength)(enc)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid('Invalid Initialization Vector length');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkIvLength);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_iv_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_key_type.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_key_type.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\nconst symmetricTypeCheck = (alg, key) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (!(0,_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key)) {\n        throw new TypeError((0,_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__.withAlg)(alg, key, ..._runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types, 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (!(0,_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key)) {\n        throw new TypeError((0,_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_0__.withAlg)(alg, key, ..._runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${_runtime_is_key_like_js__WEBPACK_IMPORTED_MODULE_1__.types.join(' or ')} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nconst checkKeyType = (alg, key, usage) => {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkKeyType);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_key_type.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/check_p2s.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/check_p2s.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ checkP2s)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction checkP2s(p2s) {\n    if (!(p2s instanceof Uint8Array) || p2s.length < 8) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid('PBES2 Salt Input must be 8 or more octets');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/check_p2s.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/crypto_key.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/crypto_key.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkEncCryptoKey: () => (/* binding */ checkEncCryptoKey),\n/* harmony export */   checkSigCryptoKey: () => (/* binding */ checkSigCryptoKey)\n/* harmony export */ });\nfunction unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nfunction checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nfunction checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/crypto_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/decrypt_key_management.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/decrypt_key_management.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/ecdhes.js */ \"./node_modules/jose/dist/browser/runtime/ecdhes.js\");\n/* harmony import */ var _runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/pbes2kw.js */ \"./node_modules/jose/dist/browser/runtime/pbes2kw.js\");\n/* harmony import */ var _runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runtime/rsaes.js */ \"./node_modules/jose/dist/browser/runtime/rsaes.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _key_import_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../key/import.js */ \"./node_modules/jose/dist/browser/key/import.js\");\n/* harmony import */ var _check_key_type_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _is_object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _aesgcmkw_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./aesgcmkw.js */ \"./node_modules/jose/dist/browser/lib/aesgcmkw.js\");\n\n\n\n\n\n\n\n\n\n\n\nasync function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {\n    (0,_check_key_type_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(alg, key, 'decrypt');\n    switch (alg) {\n        case 'dir': {\n            if (encryptedKey !== undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Encountered unexpected JWE Encrypted Key');\n            return key;\n        }\n        case 'ECDH-ES':\n            if (encryptedKey !== undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Encountered unexpected JWE Encrypted Key');\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!(0,_is_object_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(joseHeader.epk))\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"epk\" (Ephemeral Public Key) missing or invalid`);\n            if (!_runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.ecdhAllowed(key))\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            const epk = await (0,_key_import_js__WEBPACK_IMPORTED_MODULE_7__.importJWK)(joseHeader.epk, alg);\n            let partyUInfo;\n            let partyVInfo;\n            if (joseHeader.apu !== undefined) {\n                if (typeof joseHeader.apu !== 'string')\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"apu\" (Agreement PartyUInfo) invalid`);\n                try {\n                    partyUInfo = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.apu);\n                }\n                catch {\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Failed to base64url decode the apu');\n                }\n            }\n            if (joseHeader.apv !== undefined) {\n                if (typeof joseHeader.apv !== 'string')\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"apv\" (Agreement PartyVInfo) invalid`);\n                try {\n                    partyVInfo = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.apv);\n                }\n                catch {\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Failed to base64url decode the apv');\n                }\n            }\n            const sharedSecret = await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_6__.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);\n            if (alg === 'ECDH-ES')\n                return sharedSecret;\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__.decrypt)(alg, key, encryptedKey);\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.p2c !== 'number')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) missing or invalid`);\n            const p2cLimit = options?.maxPBES2Count || 10000;\n            if (joseHeader.p2c > p2cLimit)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"p2c\" (PBES2 Count) out is of acceptable bounds`);\n            if (typeof joseHeader.p2s !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"p2s\" (PBES2 Salt) missing or invalid`);\n            let p2s;\n            try {\n                p2s = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.p2s);\n            }\n            catch {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Failed to base64url decode the p2s');\n            }\n            return (0,_runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__.decrypt)(alg, key, encryptedKey, joseHeader.p2c, p2s);\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            return (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.unwrap)(alg, key, encryptedKey);\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            if (encryptedKey === undefined)\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('JWE Encrypted Key missing');\n            if (typeof joseHeader.iv !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"iv\" (Initialization Vector) missing or invalid`);\n            if (typeof joseHeader.tag !== 'string')\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid(`JOSE Header \"tag\" (Authentication Tag) missing or invalid`);\n            let iv;\n            try {\n                iv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.iv);\n            }\n            catch {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Failed to base64url decode the iv');\n            }\n            let tag;\n            try {\n                tag = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.decode)(joseHeader.tag);\n            }\n            catch {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JWEInvalid('Failed to base64url decode the tag');\n            }\n            return (0,_aesgcmkw_js__WEBPACK_IMPORTED_MODULE_10__.unwrap)(alg, key, encryptedKey, iv, tag);\n        }\n        default: {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_5__.JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (decryptKeyManagement);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/decrypt_key_management.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/encrypt_key_management.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/encrypt_key_management.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/ecdhes.js */ \"./node_modules/jose/dist/browser/runtime/ecdhes.js\");\n/* harmony import */ var _runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../runtime/pbes2kw.js */ \"./node_modules/jose/dist/browser/runtime/pbes2kw.js\");\n/* harmony import */ var _runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../runtime/rsaes.js */ \"./node_modules/jose/dist/browser/runtime/rsaes.js\");\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_cek_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/cek.js */ \"./node_modules/jose/dist/browser/lib/cek.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _key_export_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../key/export.js */ \"./node_modules/jose/dist/browser/key/export.js\");\n/* harmony import */ var _check_key_type_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./check_key_type.js */ \"./node_modules/jose/dist/browser/lib/check_key_type.js\");\n/* harmony import */ var _aesgcmkw_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./aesgcmkw.js */ \"./node_modules/jose/dist/browser/lib/aesgcmkw.js\");\n\n\n\n\n\n\n\n\n\n\nasync function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {\n    let encryptedKey;\n    let parameters;\n    let cek;\n    (0,_check_key_type_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(alg, key, 'encrypt');\n    switch (alg) {\n        case 'dir': {\n            cek = key;\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            if (!_runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.ecdhAllowed(key)) {\n                throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_6__.JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');\n            }\n            const { apu, apv } = providedParameters;\n            let { epk: ephemeralKey } = providedParameters;\n            ephemeralKey || (ephemeralKey = (await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.generateEpk(key)).privateKey);\n            const { x, y, crv, kty } = await (0,_key_export_js__WEBPACK_IMPORTED_MODULE_7__.exportJWK)(ephemeralKey);\n            const sharedSecret = await _runtime_ecdhes_js__WEBPACK_IMPORTED_MODULE_1__.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);\n            parameters = { epk: { x, crv, kty } };\n            if (kty === 'EC')\n                parameters.epk.y = y;\n            if (apu)\n                parameters.apu = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.encode)(apu);\n            if (apv)\n                parameters.apv = (0,_runtime_base64url_js__WEBPACK_IMPORTED_MODULE_4__.encode)(apv);\n            if (alg === 'ECDH-ES') {\n                cek = sharedSecret;\n                break;\n            }\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const kwAlg = alg.slice(-6);\n            encryptedKey = await (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(kwAlg, sharedSecret, cek);\n            break;\n        }\n        case 'RSA1_5':\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            encryptedKey = await (0,_runtime_rsaes_js__WEBPACK_IMPORTED_MODULE_3__.encrypt)(alg, key, cek);\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const { p2c, p2s } = providedParameters;\n            ({ encryptedKey, ...parameters } = await (0,_runtime_pbes2kw_js__WEBPACK_IMPORTED_MODULE_2__.encrypt)(alg, key, cek, p2c, p2s));\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            encryptedKey = await (0,_runtime_aeskw_js__WEBPACK_IMPORTED_MODULE_0__.wrap)(alg, key, cek);\n            break;\n        }\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW': {\n            cek = providedCek || (0,_lib_cek_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(enc);\n            const { iv } = providedParameters;\n            ({ encryptedKey, ...parameters } = await (0,_aesgcmkw_js__WEBPACK_IMPORTED_MODULE_9__.wrap)(alg, key, cek, iv));\n            break;\n        }\n        default: {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_6__.JOSENotSupported('Invalid or unsupported \"alg\" (JWE Algorithm) header value');\n        }\n    }\n    return { cek, encryptedKey, parameters };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encryptKeyManagement);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/encrypt_key_management.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/epoch.js":
/*!*****************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/epoch.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((date) => Math.floor(date.getTime() / 1000));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/epoch.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/format_pem.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/format_pem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/format_pem.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/invalid_key_input.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/invalid_key_input.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   withAlg: () => (/* binding */ withAlg)\n/* harmony export */ });\nfunction message(msg, actual, ...types) {\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n});\nfunction withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/invalid_key_input.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/is_disjoint.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/is_disjoint.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isDisjoint);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/is_disjoint.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/is_object.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/is_object.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isObject)\n/* harmony export */ });\nfunction isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/is_object.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/iv.js":
/*!**************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/iv.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitLength: () => (/* binding */ bitLength),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _runtime_random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../runtime/random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\nfunction bitLength(alg) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A128GCMKW':\n        case 'A192GCM':\n        case 'A192GCMKW':\n        case 'A256GCM':\n        case 'A256GCMKW':\n            return 96;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            return 128;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg) => (0,_runtime_random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(new Uint8Array(bitLength(alg) >> 3)));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/iv.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/jwt_claims_set.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/jwt_claims_set.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _epoch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./epoch.js */ \"./node_modules/jose/dist/browser/lib/epoch.js\");\n/* harmony import */ var _secs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./secs.js */ \"./node_modules/jose/dist/browser/lib/secs.js\");\n/* harmony import */ var _is_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\n\n\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((protectedHeader, encodedPayload, options = {}) => {\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"typ\" JWT header value', 'typ', 'check_failed');\n    }\n    let payload;\n    try {\n        payload = JSON.parse(_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!(0,_is_object_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(payload)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed(`missing required \"${claim}\" claim`, claim, 'missing');\n        }\n    }\n    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"iss\" claim value', 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"sub\" claim value', 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('unexpected \"aud\" claim value', 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = (0,_secs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = (0,_epoch_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"iat\" claim must be a number', 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"nbf\" claim must be a number', 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"exp\" claim must be a number', 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTExpired('\"exp\" claim timestamp check failed', 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : (0,_secs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');\n        }\n    }\n    return payload;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/jwt_claims_set.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/secs.js":
/*!****************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/secs.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/secs.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/validate_algorithms.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/validate_algorithms.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateAlgorithms);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/validate_algorithms.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/lib/validate_crit.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/lib/validate_crit.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateCrit);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/lib/validate_crit.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/aeskw.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/aeskw.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _bogus_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bogus.js */ \"./node_modules/jose/dist/browser/runtime/bogus.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\nfunction checkKeySize(key, alg) {\n    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {\n        throw new TypeError(`Invalid key size for alg: ${alg}`);\n    }\n}\nfunction getCryptoKey(key, alg, usage) {\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('raw', key, 'AES-KW', true, [usage]);\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types, 'Uint8Array'));\n}\nconst wrap = async (alg, key, cek) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.importKey('raw', cek, ..._bogus_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));\n};\nconst unwrap = async (alg, key, encryptedKey) => {\n    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');\n    checkKeySize(cryptoKey, alg);\n    const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ..._bogus_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.exportKey('raw', cryptoKeyCek));\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/aeskw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/asn1.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/asn1.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromPKCS8: () => (/* binding */ fromPKCS8),\n/* harmony export */   fromSPKI: () => (/* binding */ fromSPKI),\n/* harmony export */   fromX509: () => (/* binding */ fromX509),\n/* harmony export */   toPKCS8: () => (/* binding */ toPKCS8),\n/* harmony export */   toSPKI: () => (/* binding */ toSPKI)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _lib_format_pem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/format_pem.js */ \"./node_modules/jose/dist/browser/lib/format_pem.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_5__.types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return (0,_lib_format_pem_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encodeBase64)(new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nconst toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nconst toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n    if (from === 0) {\n        oid.unshift(oid.length);\n        oid.unshift(0x06);\n    }\n    const i = keyData.indexOf(oid[0], from);\n    if (i === -1)\n        return false;\n    const sub = keyData.subarray(i, i + oid.length);\n    if (sub.length !== oid.length)\n        return false;\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = (keyData) => {\n    switch (true) {\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n            return 'P-256';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n            return 'P-384';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n            return 'P-521';\n        case findOid(keyData, [0x2b, 0x65, 0x6e]):\n            return 'X25519';\n        case findOid(keyData, [0x2b, 0x65, 0x6f]):\n            return 'X448';\n        case findOid(keyData, [0x2b, 0x65, 0x70]):\n            return 'Ed25519';\n        case findOid(keyData, [0x2b, 0x65, 0x71]):\n            return 'Ed448';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            const namedCurve = getNamedCurve(keyData);\n            algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'EdDSA':\n            algorithm = { name: getNamedCurve(keyData) };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? false, keyUsages);\n};\nconst fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nconst fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\nfunction getElement(seq) {\n    const result = [];\n    let next = 0;\n    while (next < seq.length) {\n        const nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            if (length > bytes.byteLength) {\n                throw new TypeError('invalid indefinite form length');\n            }\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    else {\n        const numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.decodeBase64)(pem);\n    return (0,_lib_format_pem_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(spkiFromX509(raw), 'PUBLIC KEY');\n}\nconst fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = getSPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(spki, alg, options);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/asn1.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/base64url.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/base64url.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n\nconst encodeBase64 = (input) => {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.encoder.encode(unencoded);\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n};\nconst encode = (input) => {\n    return encodeBase64(input).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n};\nconst decodeBase64 = (encoded) => {\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n};\nconst decode = (input) => {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, '');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/base64url.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/bogus.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/bogus.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst bogusWebCrypto = [\n    { hash: 'SHA-256', name: 'HMAC' },\n    true,\n    ['sign'],\n];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bogusWebCrypto);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/bogus.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/check_cek_length.js":
/*!********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/check_cek_length.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nconst checkCekLength = (cek, expected) => {\n    const actual = cek.byteLength << 3;\n    if (actual !== expected) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (checkCekLength);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/check_cek_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/check_key_length.js":
/*!********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/check_key_length.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((alg, key) => {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n});\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/check_key_length.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/decrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/decrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/check_iv_length.js */ \"./node_modules/jose/dist/browser/lib/check_iv_length.js\");\n/* harmony import */ var _check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_cek_length.js */ \"./node_modules/jose/dist/browser/runtime/check_cek_length.js\");\n/* harmony import */ var _timing_safe_equal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timing_safe_equal.js */ \"./node_modules/jose/dist/browser/runtime/timing_safe_equal.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\n\nasync function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);\n    const macKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const macData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(aad, iv, ciphertext, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint64be)(aad.length << 3));\n    const expectedTag = new Uint8Array((await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    let macCheckPassed;\n    try {\n        macCheckPassed = (0,_timing_safe_equal_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(tag, expectedTag);\n    }\n    catch {\n    }\n    if (!macCheckPassed) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n    let plaintext;\n    try {\n        plaintext = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.decrypt({ iv, name: 'AES-CBC' }, encKey, ciphertext));\n    }\n    catch {\n    }\n    if (!plaintext) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n    return plaintext;\n}\nasync function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);\n    }\n    else {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__.checkEncCryptoKey)(cek, enc, 'decrypt');\n        encKey = cek;\n    }\n    try {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.decrypt({\n            additionalData: aad,\n            iv,\n            name: 'AES-GCM',\n            tagLength: 128,\n        }, encKey, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(ciphertext, tag)));\n    }\n    catch {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEDecryptionFailed();\n    }\n}\nconst decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_5__.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(cek, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_8__.types, 'Uint8Array'));\n    }\n    if (!iv) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEInvalid('JWE Initialization Vector missing');\n    }\n    if (!tag) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JWEInvalid('JWE Authentication Tag missing');\n    }\n    (0,_lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, iv);\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.slice(-3), 10));\n            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array)\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.slice(1, 4), 10));\n            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_4__.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (decrypt);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/decrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/digest.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/digest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\nconst digest = async (algorithm, data) => {\n    const subtleDigest = `SHA-${algorithm.slice(-3)}`;\n    return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.digest(subtleDigest, data));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (digest);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/digest.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/ecdhes.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/ecdhes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveKey: () => (/* binding */ deriveKey),\n/* harmony export */   ecdhAllowed: () => (/* binding */ ecdhAllowed),\n/* harmony export */   generateEpk: () => (/* binding */ generateEpk)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\nasync function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(publicKey)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(publicKey, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(publicKey, 'ECDH');\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(privateKey)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(privateKey, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_2__.checkEncCryptoKey)(privateKey, 'ECDH', 'deriveBits');\n    const value = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)((0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.encoder.encode(algorithm)), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(apu), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.lengthAndInput)(apv), (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint32be)(keyLength));\n    let length;\n    if (publicKey.algorithm.name === 'X25519') {\n        length = 256;\n    }\n    else if (publicKey.algorithm.name === 'X448') {\n        length = 448;\n    }\n    else {\n        length =\n            Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;\n    }\n    const sharedSecret = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.deriveBits({\n        name: publicKey.algorithm.name,\n        public: publicKey,\n    }, privateKey, length));\n    return (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatKdf)(sharedSecret, keyLength, value);\n}\nasync function generateEpk(key) {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types));\n    }\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.generateKey(key.algorithm, true, ['deriveBits']);\n}\nfunction ecdhAllowed(key) {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_1__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_4__.types));\n    }\n    return (['P-256', 'P-384', 'P-521'].includes(key.algorithm.namedCurve) ||\n        key.algorithm.name === 'X25519' ||\n        key.algorithm.name === 'X448');\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/ecdhes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/encrypt.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/encrypt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/check_iv_length.js */ \"./node_modules/jose/dist/browser/lib/check_iv_length.js\");\n/* harmony import */ var _check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_cek_length.js */ \"./node_modules/jose/dist/browser/runtime/check_cek_length.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _lib_iv_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/iv.js */ \"./node_modules/jose/dist/browser/lib/iv.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\n\nasync function cbcEncrypt(enc, plaintext, cek, iv, aad) {\n    if (!(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(cek, 'Uint8Array'));\n    }\n    const keySize = parseInt(enc.slice(1, 4), 10);\n    const encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['encrypt']);\n    const macKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek.subarray(0, keySize >> 3), {\n        hash: `SHA-${keySize << 1}`,\n        name: 'HMAC',\n    }, false, ['sign']);\n    const ciphertext = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.encrypt({\n        iv,\n        name: 'AES-CBC',\n    }, encKey, plaintext));\n    const macData = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.concat)(aad, iv, ciphertext, (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_0__.uint64be)(aad.length << 3));\n    const tag = new Uint8Array((await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));\n    return { ciphertext, tag, iv };\n}\nasync function gcmEncrypt(enc, plaintext, cek, iv, aad) {\n    let encKey;\n    if (cek instanceof Uint8Array) {\n        encKey = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.importKey('raw', cek, 'AES-GCM', false, ['encrypt']);\n    }\n    else {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_4__.checkEncCryptoKey)(cek, enc, 'encrypt');\n        encKey = cek;\n    }\n    const encrypted = new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].subtle.encrypt({\n        additionalData: aad,\n        iv,\n        name: 'AES-GCM',\n        tagLength: 128,\n    }, encKey, plaintext));\n    const tag = encrypted.slice(-16);\n    const ciphertext = encrypted.slice(0, -16);\n    return { ciphertext, tag, iv };\n}\nconst encrypt = async (enc, plaintext, cek, iv, aad) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_3__.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(cek, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_8__.types, 'Uint8Array'));\n    }\n    if (iv) {\n        (0,_lib_check_iv_length_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(enc, iv);\n    }\n    else {\n        iv = (0,_lib_iv_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(enc);\n    }\n    switch (enc) {\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            if (cek instanceof Uint8Array) {\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.slice(-3), 10));\n            }\n            return cbcEncrypt(enc, plaintext, cek, iv, aad);\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            if (cek instanceof Uint8Array) {\n                (0,_check_cek_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(cek, parseInt(enc.slice(1, 4), 10));\n            }\n            return gcmEncrypt(enc, plaintext, cek, iv, aad);\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_7__.JOSENotSupported('Unsupported JWE Content Encryption Algorithm');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encrypt);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/encrypt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/fetch_jwks.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/fetch_jwks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nconst fetchJwks = async (url, timeout, options) => {\n    let controller;\n    let id;\n    let timedOut = false;\n    if (typeof AbortController === 'function') {\n        controller = new AbortController();\n        id = setTimeout(() => {\n            timedOut = true;\n            controller.abort();\n        }, timeout);\n    }\n    const response = await fetch(url.href, {\n        signal: controller ? controller.signal : undefined,\n        redirect: 'manual',\n        headers: options.headers,\n    }).catch((err) => {\n        if (timedOut)\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JWKSTimeout();\n        throw err;\n    });\n    if (id !== undefined)\n        clearTimeout(id);\n    if (response.status !== 200) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSEError('Expected 200 OK from the JSON Web Key Set HTTP response');\n    }\n    try {\n        return await response.json();\n    }\n    catch {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSEError('Failed to parse the JSON Web Key Set HTTP response as JSON');\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetchJwks);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/fetch_jwks.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/generate.js":
/*!************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/generate.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generateSecret: () => (/* binding */ generateSecret)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n\n\n\nasync function generateSecret(alg, options) {\n    let length;\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            length = parseInt(alg.slice(-3), 10);\n            algorithm = { name: 'HMAC', hash: `SHA-${length}`, length };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'A128CBC-HS256':\n        case 'A192CBC-HS384':\n        case 'A256CBC-HS512':\n            length = parseInt(alg.slice(-3), 10);\n            return (0,_random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(new Uint8Array(length >> 3));\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-KW', length };\n            keyUsages = ['wrapKey', 'unwrapKey'];\n            break;\n        case 'A128GCMKW':\n        case 'A192GCMKW':\n        case 'A256GCMKW':\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM':\n            length = parseInt(alg.slice(1, 4), 10);\n            algorithm = { name: 'AES-GCM', length };\n            keyUsages = ['encrypt', 'decrypt'];\n            break;\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages);\n}\nfunction getModulusLengthOption(options) {\n    const modulusLength = options?.modulusLength ?? 2048;\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');\n    }\n    return modulusLength;\n}\nasync function generateKeyPair(alg, options) {\n    let algorithm;\n    let keyUsages;\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = {\n                name: 'RSA-PSS',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: `SHA-${alg.slice(-3)}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n                publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n                modulusLength: getModulusLengthOption(options),\n            };\n            keyUsages = ['decrypt', 'unwrapKey', 'encrypt', 'wrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = ['sign', 'verify'];\n            break;\n        case 'EdDSA': {\n            keyUsages = ['sign', 'verify'];\n            const crv = options?.crv ?? 'Ed25519';\n            switch (crv) {\n                case 'Ed25519':\n                case 'Ed448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported crv option provided');\n            }\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            keyUsages = ['deriveKey', 'deriveBits'];\n            const crv = options?.crv ?? 'P-256';\n            switch (crv) {\n                case 'P-256':\n                case 'P-384':\n                case 'P-521': {\n                    algorithm = { name: 'ECDH', namedCurve: crv };\n                    break;\n                }\n                case 'X25519':\n                case 'X448':\n                    algorithm = { name: crv };\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');\n            }\n            break;\n        }\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n    }\n    return (_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.generateKey(algorithm, options?.extractable ?? false, keyUsages));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/generate.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getCryptoKey)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\nfunction getCryptoKey(alg, key, usage) {\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_1__.checkSigCryptoKey)(key, alg, usage);\n        return key;\n    }\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types));\n        }\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types, 'Uint8Array'));\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/is_key_like.js":
/*!***************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/is_key_like.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((key) => {\n    return (0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key);\n});\nconst types = ['CryptoKey'];\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/is_key_like.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/jwk_to_key.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/jwk_to_key.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'EdDSA':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_1__.JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nconst parse = async (jwk) => {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const rest = [\n        algorithm,\n        jwk.ext ?? false,\n        jwk.key_ops ?? keyUsages,\n    ];\n    const keyData = { ...jwk };\n    delete keyData.alg;\n    delete keyData.use;\n    return _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.importKey('jwk', keyData, ...rest);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/jwk_to_key.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/key_to_jwk.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/key_to_jwk.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\nconst keyToJWK = async (key) => {\n    if (key instanceof Uint8Array) {\n        return {\n            kty: 'oct',\n            k: (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(key),\n        };\n    }\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_3__.types, 'Uint8Array'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');\n    }\n    const { ext, key_ops, alg, use, ...jwk } = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].subtle.exportKey('jwk', key);\n    return jwk;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keyToJWK);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/key_to_jwk.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/pbes2kw.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/pbes2kw.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   encrypt: () => (/* binding */ encrypt)\n/* harmony export */ });\n/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random.js */ \"./node_modules/jose/dist/browser/runtime/random.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n/* harmony import */ var _aeskw_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aeskw.js */ \"./node_modules/jose/dist/browser/runtime/aeskw.js\");\n/* harmony import */ var _lib_check_p2s_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/check_p2s.js */ \"./node_modules/jose/dist/browser/lib/check_p2s.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\n\n\nfunction getCryptoKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.importKey('raw', key, 'PBKDF2', false, ['deriveBits']);\n    }\n    if ((0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_5__.isCryptoKey)(key)) {\n        (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_6__.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');\n        return key;\n    }\n    throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_8__.types, 'Uint8Array'));\n}\nasync function deriveKey(p2s, alg, p2c, key) {\n    (0,_lib_check_p2s_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(p2s);\n    const salt = (0,_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.p2s)(alg, p2s);\n    const keylen = parseInt(alg.slice(13, 16), 10);\n    const subtleAlg = {\n        hash: `SHA-${alg.slice(8, 11)}`,\n        iterations: p2c,\n        name: 'PBKDF2',\n        salt,\n    };\n    const wrapAlg = {\n        length: keylen,\n        name: 'AES-KW',\n    };\n    const cryptoKey = await getCryptoKey(key, alg);\n    if (cryptoKey.usages.includes('deriveBits')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.deriveBits(subtleAlg, cryptoKey, keylen));\n    }\n    if (cryptoKey.usages.includes('deriveKey')) {\n        return _webcrypto_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ['wrapKey', 'unwrapKey']);\n    }\n    throw new TypeError('PBKDF2 key \"usages\" must include \"deriveBits\" or \"deriveKey\"');\n}\nconst encrypt = async (alg, key, cek, p2c = 2048, p2s = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(new Uint8Array(16))) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    const encryptedKey = await (0,_aeskw_js__WEBPACK_IMPORTED_MODULE_3__.wrap)(alg.slice(-6), derived, cek);\n    return { encryptedKey, p2c, p2s: (0,_base64url_js__WEBPACK_IMPORTED_MODULE_2__.encode)(p2s) };\n};\nconst decrypt = async (alg, key, encryptedKey, p2c, p2s) => {\n    const derived = await deriveKey(p2s, alg, p2c, key);\n    return (0,_aeskw_js__WEBPACK_IMPORTED_MODULE_3__.unwrap)(alg.slice(-6), derived, encryptedKey);\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/pbes2kw.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/random.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/random.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getRandomValues.bind(_webcrypto_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]));\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/random.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/rsaes.js":
/*!*********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/rsaes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   encrypt: () => (/* binding */ encrypt)\n/* harmony export */ });\n/* harmony import */ var _subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_rsaes.js */ \"./node_modules/jose/dist/browser/runtime/subtle_rsaes.js\");\n/* harmony import */ var _bogus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bogus.js */ \"./node_modules/jose/dist/browser/runtime/bogus.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/crypto_key.js */ \"./node_modules/jose/dist/browser/lib/crypto_key.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/invalid_key_input.js */ \"./node_modules/jose/dist/browser/lib/invalid_key_input.js\");\n/* harmony import */ var _is_key_like_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is_key_like.js */ \"./node_modules/jose/dist/browser/runtime/is_key_like.js\");\n\n\n\n\n\n\n\nconst encrypt = async (alg, key, cek) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_2__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_6__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__.checkEncCryptoKey)(key, alg, 'encrypt', 'wrapKey');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(alg, key);\n    if (key.usages.includes('encrypt')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.encrypt((0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), key, cek));\n    }\n    if (key.usages.includes('wrapKey')) {\n        const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.importKey('raw', cek, ..._bogus_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.wrapKey('raw', cryptoKeyCek, key, (0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg)));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"encrypt\" or \"wrapKey\" for this operation');\n};\nconst decrypt = async (alg, key, encryptedKey) => {\n    if (!(0,_webcrypto_js__WEBPACK_IMPORTED_MODULE_2__.isCryptoKey)(key)) {\n        throw new TypeError((0,_lib_invalid_key_input_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(key, ..._is_key_like_js__WEBPACK_IMPORTED_MODULE_6__.types));\n    }\n    (0,_lib_crypto_key_js__WEBPACK_IMPORTED_MODULE_3__.checkEncCryptoKey)(key, alg, 'decrypt', 'unwrapKey');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(alg, key);\n    if (key.usages.includes('decrypt')) {\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.decrypt((0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), key, encryptedKey));\n    }\n    if (key.usages.includes('unwrapKey')) {\n        const cryptoKeyCek = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.unwrapKey('raw', encryptedKey, key, (0,_subtle_rsaes_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg), ..._bogus_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n        return new Uint8Array(await _webcrypto_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].subtle.exportKey('raw', cryptoKeyCek));\n    }\n    throw new TypeError('RSA-OAEP key \"usages\" must include \"decrypt\" or \"unwrapKey\" for this operation');\n};\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/rsaes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/runtime.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/runtime.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('WebCryptoAPI');\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/sign.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/sign.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_dsa.js */ \"./node_modules/jose/dist/browser/runtime/subtle_dsa.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get_sign_verify_key.js */ \"./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js\");\n\n\n\n\nconst sign = async (alg, key, data) => {\n    const cryptoKey = await (0,_get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(alg, key, 'sign');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(alg, cryptoKey);\n    const signature = await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.sign((0,_subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sign);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/sign.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/subtle_dsa.js":
/*!**************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/subtle_dsa.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ subtleDsa)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction subtleDsa(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: alg.slice(-3) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'EdDSA':\n            return { name: algorithm.name };\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/subtle_dsa.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/subtle_rsaes.js":
/*!****************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/subtle_rsaes.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ subtleRsaEs)\n/* harmony export */ });\n/* harmony import */ var _util_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\nfunction subtleRsaEs(alg) {\n    switch (alg) {\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            return 'RSA-OAEP';\n        default:\n            throw new _util_errors_js__WEBPACK_IMPORTED_MODULE_0__.JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/subtle_rsaes.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/timing_safe_equal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/timing_safe_equal.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst timingSafeEqual = (a, b) => {\n    if (!(a instanceof Uint8Array)) {\n        throw new TypeError('First argument must be a buffer');\n    }\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('Second argument must be a buffer');\n    }\n    if (a.length !== b.length) {\n        throw new TypeError('Input buffers must have the same length');\n    }\n    const len = a.length;\n    let out = 0;\n    let i = -1;\n    while (++i < len) {\n        out |= a[i] ^ b[i];\n    }\n    return out === 0;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (timingSafeEqual);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/timing_safe_equal.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/verify.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/verify.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./subtle_dsa.js */ \"./node_modules/jose/dist/browser/runtime/subtle_dsa.js\");\n/* harmony import */ var _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webcrypto.js */ \"./node_modules/jose/dist/browser/runtime/webcrypto.js\");\n/* harmony import */ var _check_key_length_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./check_key_length.js */ \"./node_modules/jose/dist/browser/runtime/check_key_length.js\");\n/* harmony import */ var _get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get_sign_verify_key.js */ \"./node_modules/jose/dist/browser/runtime/get_sign_verify_key.js\");\n\n\n\n\nconst verify = async (alg, key, signature, data) => {\n    const cryptoKey = await (0,_get_sign_verify_key_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(alg, key, 'verify');\n    (0,_check_key_length_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(alg, cryptoKey);\n    const algorithm = (0,_subtle_dsa_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(alg, cryptoKey.algorithm);\n    try {\n        return await _webcrypto_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].subtle.verify(algorithm, cryptoKey, signature, data);\n    }\n    catch {\n        return false;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (verify);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/verify.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/runtime/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/jose/dist/browser/runtime/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   isCryptoKey: () => (/* binding */ isCryptoKey)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (crypto);\nconst isCryptoKey = (key) => key instanceof CryptoKey;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/runtime/webcrypto.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/base64url.js":
/*!**********************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/base64url.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/base64url.js */ \"./node_modules/jose/dist/browser/runtime/base64url.js\");\n\nconst encode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.encode;\nconst decode = _runtime_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode;\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/base64url.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/decode_jwt.js":
/*!***********************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/decode_jwt.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeJwt: () => (/* binding */ decodeJwt)\n/* harmony export */ });\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/util/base64url.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/jose/dist/browser/util/errors.js\");\n\n\n\n\nfunction decodeJwt(jwt) {\n    if (typeof jwt !== 'string')\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('JWTs must use Compact JWS serialization, JWT must be a string');\n    const { 1: payload, length } = jwt.split('.');\n    if (length === 5)\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('Only JWTs using Compact JWS serialization can be decoded');\n    if (length !== 3)\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('Invalid JWT');\n    if (!payload)\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('JWTs must contain a payload');\n    let decoded;\n    try {\n        decoded = (0,_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(payload);\n    }\n    catch {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('Failed to base64url decode the payload');\n    }\n    let result;\n    try {\n        result = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode(decoded));\n    }\n    catch {\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('Failed to parse the decoded payload as JSON');\n    }\n    if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(result))\n        throw new _errors_js__WEBPACK_IMPORTED_MODULE_3__.JWTInvalid('Invalid JWT Claims Set');\n    return result;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/decode_jwt.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/decode_protected_header.js":
/*!************************************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/decode_protected_header.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeProtectedHeader: () => (/* binding */ decodeProtectedHeader)\n/* harmony export */ });\n/* harmony import */ var _base64url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url.js */ \"./node_modules/jose/dist/browser/util/base64url.js\");\n/* harmony import */ var _lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/buffer_utils.js */ \"./node_modules/jose/dist/browser/lib/buffer_utils.js\");\n/* harmony import */ var _lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/is_object.js */ \"./node_modules/jose/dist/browser/lib/is_object.js\");\n\n\n\nfunction decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(_lib_buffer_utils_js__WEBPACK_IMPORTED_MODULE_1__.decoder.decode((0,_base64url_js__WEBPACK_IMPORTED_MODULE_0__.decode)(protectedB64u)));\n        if (!(0,_lib_is_object_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/decode_protected_header.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JOSEAlgNotAllowed: () => (/* binding */ JOSEAlgNotAllowed),\n/* harmony export */   JOSEError: () => (/* binding */ JOSEError),\n/* harmony export */   JOSENotSupported: () => (/* binding */ JOSENotSupported),\n/* harmony export */   JWEDecryptionFailed: () => (/* binding */ JWEDecryptionFailed),\n/* harmony export */   JWEInvalid: () => (/* binding */ JWEInvalid),\n/* harmony export */   JWKInvalid: () => (/* binding */ JWKInvalid),\n/* harmony export */   JWKSInvalid: () => (/* binding */ JWKSInvalid),\n/* harmony export */   JWKSMultipleMatchingKeys: () => (/* binding */ JWKSMultipleMatchingKeys),\n/* harmony export */   JWKSNoMatchingKey: () => (/* binding */ JWKSNoMatchingKey),\n/* harmony export */   JWKSTimeout: () => (/* binding */ JWKSTimeout),\n/* harmony export */   JWSInvalid: () => (/* binding */ JWSInvalid),\n/* harmony export */   JWSSignatureVerificationFailed: () => (/* binding */ JWSSignatureVerificationFailed),\n/* harmony export */   JWTClaimValidationFailed: () => (/* binding */ JWTClaimValidationFailed),\n/* harmony export */   JWTExpired: () => (/* binding */ JWTExpired),\n/* harmony export */   JWTInvalid: () => (/* binding */ JWTInvalid)\n/* harmony export */ });\nclass JOSEError extends Error {\n    static get code() {\n        return 'ERR_JOSE_GENERIC';\n    }\n    constructor(message) {\n        super(message);\n        this.code = 'ERR_JOSE_GENERIC';\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nclass JWTClaimValidationFailed extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nclass JWTExpired extends JOSEError {\n    static get code() {\n        return 'ERR_JWT_EXPIRED';\n    }\n    constructor(message, claim = 'unspecified', reason = 'unspecified') {\n        super(message);\n        this.code = 'ERR_JWT_EXPIRED';\n        this.claim = claim;\n        this.reason = reason;\n    }\n}\nclass JOSEAlgNotAllowed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n    static get code() {\n        return 'ERR_JOSE_ALG_NOT_ALLOWED';\n    }\n}\nclass JOSENotSupported extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JOSE_NOT_SUPPORTED';\n    }\n    static get code() {\n        return 'ERR_JOSE_NOT_SUPPORTED';\n    }\n}\nclass JWEDecryptionFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_DECRYPTION_FAILED';\n        this.message = 'decryption operation failed';\n    }\n    static get code() {\n        return 'ERR_JWE_DECRYPTION_FAILED';\n    }\n}\nclass JWEInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWE_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWE_INVALID';\n    }\n}\nclass JWSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWS_INVALID';\n    }\n}\nclass JWTInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWT_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWT_INVALID';\n    }\n}\nclass JWKInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWK_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWK_INVALID';\n    }\n}\nclass JWKSInvalid extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_INVALID';\n    }\n    static get code() {\n        return 'ERR_JWKS_INVALID';\n    }\n}\nclass JWKSNoMatchingKey extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_NO_MATCHING_KEY';\n        this.message = 'no applicable key found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_NO_MATCHING_KEY';\n    }\n}\nclass JWKSMultipleMatchingKeys extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n        this.message = 'multiple matching keys found in the JSON Web Key Set';\n    }\n    static get code() {\n        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    }\n}\nSymbol.asyncIterator;\nclass JWKSTimeout extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWKS_TIMEOUT';\n        this.message = 'request timed out';\n    }\n    static get code() {\n        return 'ERR_JWKS_TIMEOUT';\n    }\n}\nclass JWSSignatureVerificationFailed extends JOSEError {\n    constructor() {\n        super(...arguments);\n        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n        this.message = 'signature verification failed';\n    }\n    static get code() {\n        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    }\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/errors.js?");

/***/ }),

/***/ "./node_modules/jose/dist/browser/util/runtime.js":
/*!********************************************************!*\
  !*** ./node_modules/jose/dist/browser/util/runtime.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../runtime/runtime.js */ \"./node_modules/jose/dist/browser/runtime/runtime.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_runtime_runtime_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/jose/dist/browser/util/runtime.js?");

/***/ }),

/***/ "./node_modules/klona/dist/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/klona/dist/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   klona: () => (/* binding */ klona)\n/* harmony export */ });\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar k, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\tif (x.constructor !== Object && typeof x.constructor === 'function') {\n\t\t\ttmp = new x.constructor();\n\t\t\tfor (k in x) {\n\t\t\t\tif (x.hasOwnProperty(k) && tmp[k] !== x[k]) {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = {}; // null\n\t\t\tfor (k in x) {\n\t\t\t\tif (k === '__proto__') {\n\t\t\t\t\tObject.defineProperty(tmp, k, {\n\t\t\t\t\t\tvalue: klona(x[k]),\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Array]') {\n\t\tk = x.length;\n\t\tfor (tmp=Array(k); k--;) {\n\t\t\ttmp[k] = klona(x[k]);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Date]') {\n\t\treturn new Date(+x);\n\t}\n\n\tif (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t\ttmp.lastIndex = x.lastIndex;\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object DataView]') {\n\t\treturn new x.constructor( klona(x.buffer) );\n\t}\n\n\tif (str === '[object ArrayBuffer]') {\n\t\treturn x.slice(0);\n\t}\n\n\t// ArrayBuffer.isView(x)\n\t// ~> `new` bcuz `Buffer.slice` => ref\n\tif (str.slice(-6) === 'Array]') {\n\t\treturn new x.constructor(x);\n\t}\n\n\treturn x;\n}\n\n\n//# sourceURL=webpack://respec-vc/./node_modules/klona/dist/index.mjs?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/bases/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/multiformats/dist/src/bases/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Codec: () => (/* binding */ Codec),\n/* harmony export */   baseX: () => (/* binding */ baseX),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   rfc4648: () => (/* binding */ rfc4648)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"./node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/base-x.js */ \"./node_modules/multiformats/dist/src/vendor/base-x.js\");\n\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n    name;\n    prefix;\n    baseEncode;\n    constructor(name, prefix, baseEncode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n    }\n    encode(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return `${this.prefix}${this.baseEncode(bytes)}`;\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n        }\n    }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n    name;\n    prefix;\n    baseDecode;\n    prefixCodePoint;\n    constructor(name, prefix, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        /* c8 ignore next 3 */\n        if (prefix.codePointAt(0) === undefined) {\n            throw new Error('Invalid prefix character');\n        }\n        this.prefixCodePoint = prefix.codePointAt(0);\n        this.baseDecode = baseDecode;\n    }\n    decode(text) {\n        if (typeof text === 'string') {\n            if (text.codePointAt(0) !== this.prefixCodePoint) {\n                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n            }\n            return this.baseDecode(text.slice(this.prefix.length));\n        }\n        else {\n            throw Error('Can only multibase decode strings');\n        }\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n}\nclass ComposedDecoder {\n    decoders;\n    constructor(decoders) {\n        this.decoders = decoders;\n    }\n    or(decoder) {\n        return or(this, decoder);\n    }\n    decode(input) {\n        const prefix = input[0];\n        const decoder = this.decoders[prefix];\n        if (decoder != null) {\n            return decoder.decode(input);\n        }\n        else {\n            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n        }\n    }\n}\nfunction or(left, right) {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    return new ComposedDecoder({\n        ...(left.decoders ?? { [left.prefix]: left }),\n        ...(right.decoders ?? { [right.prefix]: right })\n    });\n}\nclass Codec {\n    name;\n    prefix;\n    baseEncode;\n    baseDecode;\n    encoder;\n    decoder;\n    constructor(name, prefix, baseEncode, baseDecode) {\n        this.name = name;\n        this.prefix = prefix;\n        this.baseEncode = baseEncode;\n        this.baseDecode = baseDecode;\n        this.encoder = new Encoder(name, prefix, baseEncode);\n        this.decoder = new Decoder(name, prefix, baseDecode);\n    }\n    encode(input) {\n        return this.encoder.encode(input);\n    }\n    decode(input) {\n        return this.decoder.decode(input);\n    }\n}\nfunction from({ name, prefix, encode, decode }) {\n    return new Codec(name, prefix, encode, decode);\n}\nfunction baseX({ name, prefix, alphabet }) {\n    const { encode, decode } = (0,_vendor_base_x_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(alphabet, name);\n    return from({\n        prefix,\n        name,\n        encode,\n        decode: (text) => (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(decode(text))\n    });\n}\nfunction decode(string, alphabet, bitsPerChar, name) {\n    // Build the character lookup table:\n    const codes = {};\n    for (let i = 0; i < alphabet.length; ++i) {\n        codes[alphabet[i]] = i;\n    }\n    // Count the padding bytes:\n    let end = string.length;\n    while (string[end - 1] === '=') {\n        --end;\n    }\n    // Allocate the output:\n    const out = new Uint8Array((end * bitsPerChar / 8) | 0);\n    // Parse the data:\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    let written = 0; // Next byte to write\n    for (let i = 0; i < end; ++i) {\n        // Read one character from the string:\n        const value = codes[string[i]];\n        if (value === undefined) {\n            throw new SyntaxError(`Non-${name} character`);\n        }\n        // Append the bits to the buffer:\n        buffer = (buffer << bitsPerChar) | value;\n        bits += bitsPerChar;\n        // Write out some bits if the buffer has a byte's worth:\n        if (bits >= 8) {\n            bits -= 8;\n            out[written++] = 0xff & (buffer >> bits);\n        }\n    }\n    // Verify that we have received just enough bits:\n    if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n        throw new SyntaxError('Unexpected end of data');\n    }\n    return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n    const pad = alphabet[alphabet.length - 1] === '=';\n    const mask = (1 << bitsPerChar) - 1;\n    let out = '';\n    let bits = 0; // Number of bits currently in the buffer\n    let buffer = 0; // Bits waiting to be written out, MSB first\n    for (let i = 0; i < data.length; ++i) {\n        // Slurp data into the buffer:\n        buffer = (buffer << 8) | data[i];\n        bits += 8;\n        // Write out as much as we can:\n        while (bits > bitsPerChar) {\n            bits -= bitsPerChar;\n            out += alphabet[mask & (buffer >> bits)];\n        }\n    }\n    // Partial character:\n    if (bits !== 0) {\n        out += alphabet[mask & (buffer << (bitsPerChar - bits))];\n    }\n    // Add padding characters until we hit a byte boundary:\n    if (pad) {\n        while (((out.length * bitsPerChar) & 7) !== 0) {\n            out += '=';\n        }\n    }\n    return out;\n}\n/**\n * RFC4648 Factory\n */\nfunction rfc4648({ name, prefix, bitsPerChar, alphabet }) {\n    return from({\n        prefix,\n        name,\n        encode(input) {\n            return encode(input, alphabet, bitsPerChar);\n        },\n        decode(input) {\n            return decode(input, alphabet, bitsPerChar, name);\n        }\n    });\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/bases/base.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/bases/base16.js":
/*!************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/bases/base16.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base16upper: () => (/* binding */ base16upper)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base16 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'f',\n    name: 'base16',\n    alphabet: '0123456789abcdef',\n    bitsPerChar: 4\n});\nconst base16upper = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'F',\n    name: 'base16upper',\n    alphabet: '0123456789ABCDEF',\n    bitsPerChar: 4\n});\n//# sourceMappingURL=base16.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/bases/base16.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/bases/base58.js":
/*!************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/bases/base58.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base58btc: () => (/* binding */ base58btc),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base58btc = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    name: 'base58btc',\n    prefix: 'z',\n    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nconst base58flickr = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.baseX)({\n    name: 'base58flickr',\n    prefix: 'Z',\n    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});\n//# sourceMappingURL=base58.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/bases/base58.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/bases/base64.js":
/*!************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/bases/base64.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64pad: () => (/* binding */ base64pad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlpad: () => (/* binding */ base64urlpad)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/multiformats/dist/src/bases/base.js\");\n\nconst base64 = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'm',\n    name: 'base64',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    bitsPerChar: 6\n});\nconst base64pad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'M',\n    name: 'base64pad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    bitsPerChar: 6\n});\nconst base64url = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'u',\n    name: 'base64url',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n    bitsPerChar: 6\n});\nconst base64urlpad = (0,_base_js__WEBPACK_IMPORTED_MODULE_0__.rfc4648)({\n    prefix: 'U',\n    name: 'base64urlpad',\n    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n    bitsPerChar: 6\n});\n//# sourceMappingURL=base64.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/bases/base64.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/multiformats/dist/src/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   equals: () => (/* binding */ equals),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isBinary: () => (/* binding */ isBinary),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\nconst empty = new Uint8Array(0);\nfunction toHex(d) {\n    return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\n}\nfunction fromHex(hex) {\n    const hexes = hex.match(/../g);\n    return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n}\nfunction equals(aa, bb) {\n    if (aa === bb)\n        return true;\n    if (aa.byteLength !== bb.byteLength) {\n        return false;\n    }\n    for (let ii = 0; ii < aa.byteLength; ii++) {\n        if (aa[ii] !== bb[ii]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction coerce(o) {\n    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n        return o;\n    if (o instanceof ArrayBuffer)\n        return new Uint8Array(o);\n    if (ArrayBuffer.isView(o)) {\n        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n    }\n    throw new Error('Unknown type, must be binary type');\n}\nfunction isBinary(o) {\n    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);\n}\nfunction fromString(str) {\n    return new TextEncoder().encode(str);\n}\nfunction toString(b) {\n    return new TextDecoder().decode(b);\n}\n//# sourceMappingURL=bytes.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/bytes.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/hashes/digest.js":
/*!*************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/hashes/digest.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Digest: () => (/* binding */ Digest),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   equals: () => (/* binding */ equals)\n/* harmony export */ });\n/* harmony import */ var _bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bytes.js */ \"./node_modules/multiformats/dist/src/bytes.js\");\n/* harmony import */ var _varint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../varint.js */ \"./node_modules/multiformats/dist/src/varint.js\");\n\n\n/**\n * Creates a multihash digest.\n */\nfunction create(code, digest) {\n    const size = digest.byteLength;\n    const sizeOffset = _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(code);\n    const digestOffset = sizeOffset + _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodingLength(size);\n    const bytes = new Uint8Array(digestOffset + size);\n    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(code, bytes, 0);\n    _varint_js__WEBPACK_IMPORTED_MODULE_1__.encodeTo(size, bytes, sizeOffset);\n    bytes.set(digest, digestOffset);\n    return new Digest(code, size, digest, bytes);\n}\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nfunction decode(multihash) {\n    const bytes = (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.coerce)(multihash);\n    const [code, sizeOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes);\n    const [size, digestOffset] = _varint_js__WEBPACK_IMPORTED_MODULE_1__.decode(bytes.subarray(sizeOffset));\n    const digest = bytes.subarray(sizeOffset + digestOffset);\n    if (digest.byteLength !== size) {\n        throw new Error('Incorrect length');\n    }\n    return new Digest(code, size, digest, bytes);\n}\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    else {\n        const data = b;\n        return (a.code === data.code &&\n            a.size === data.size &&\n            data.bytes instanceof Uint8Array &&\n            (0,_bytes_js__WEBPACK_IMPORTED_MODULE_0__.equals)(a.bytes, data.bytes));\n    }\n}\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nclass Digest {\n    code;\n    size;\n    digest;\n    bytes;\n    /**\n     * Creates a multihash digest.\n     */\n    constructor(code, size, digest, bytes) {\n        this.code = code;\n        this.size = size;\n        this.digest = digest;\n        this.bytes = bytes;\n    }\n}\n//# sourceMappingURL=digest.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/hashes/digest.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/hashes/hasher.js":
/*!*************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/hashes/hasher.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hasher: () => (/* binding */ Hasher),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var _digest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./digest.js */ \"./node_modules/multiformats/dist/src/hashes/digest.js\");\n\nfunction from({ name, code, encode }) {\n    return new Hasher(name, code, encode);\n}\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nclass Hasher {\n    name;\n    code;\n    encode;\n    constructor(name, code, encode) {\n        this.name = name;\n        this.code = code;\n        this.encode = encode;\n    }\n    digest(input) {\n        if (input instanceof Uint8Array) {\n            const result = this.encode(input);\n            return result instanceof Uint8Array\n                ? _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, result)\n                /* c8 ignore next 1 */\n                : result.then(digest => _digest_js__WEBPACK_IMPORTED_MODULE_0__.create(this.code, digest));\n        }\n        else {\n            throw Error('Unknown type, must be binary type');\n            /* c8 ignore next 1 */\n        }\n    }\n}\n//# sourceMappingURL=hasher.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/hashes/hasher.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/varint.js":
/*!******************************************************!*\
  !*** ./node_modules/multiformats/dist/src/varint.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encodeTo: () => (/* binding */ encodeTo),\n/* harmony export */   encodingLength: () => (/* binding */ encodingLength)\n/* harmony export */ });\n/* harmony import */ var _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/varint.js */ \"./node_modules/multiformats/dist/src/vendor/varint.js\");\n\nfunction decode(data, offset = 0) {\n    const code = _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(data, offset);\n    return [code, _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode.bytes];\n}\nfunction encodeTo(int, target, offset = 0) {\n    _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encode(int, target, offset);\n    return target;\n}\nfunction encodingLength(int) {\n    return _vendor_varint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].encodingLength(int);\n}\n//# sourceMappingURL=varint.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/varint.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/vendor/base-x.js":
/*!*************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/vendor/base-x.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base(ALPHABET, name) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError('Alphabet too long');\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for (var j = 0; j < BASE_MAP.length; j++) {\n        BASE_MAP[j] = 255;\n    }\n    for (var i = 0; i < ALPHABET.length; i++) {\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + ' is ambiguous');\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n    /**\n     * @param {any[] | Iterable<number>} source\n     */\n    function encode(source) {\n        // @ts-ignore\n        if (source instanceof Uint8Array)\n            ;\n        else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        }\n        else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError('Expected Uint8Array');\n        }\n        if (source.length === 0) {\n            return '';\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while (pbegin !== pend) {\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n                carry += (256 * b58[it1]) >>> 0;\n                b58[it1] = (carry % BASE) >>> 0;\n                carry = (carry / BASE) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while (it2 !== size && b58[it2] === 0) {\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    /**\n     * @param {string | string[]} source\n     */\n    function decodeUnsafe(source) {\n        if (typeof source !== 'string') {\n            throw new TypeError('Expected String');\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip leading spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while (source[psz]) {\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n                carry += (BASE * b256[it3]) >>> 0;\n                b256[it3] = (carry % 256) >>> 0;\n                carry = (carry / 256) >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error('Non-zero carry');\n            }\n            length = i;\n            psz++;\n        }\n        // Skip trailing spaces.\n        if (source[psz] === ' ') {\n            return;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while (it4 !== size && b256[it4] === 0) {\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while (it4 !== size) {\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    /**\n     * @param {string | string[]} string\n     */\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(`Non-${name} character`);\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp__multiformats_scope_baseX);\n//# sourceMappingURL=base-x.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/vendor/base-x.js?");

/***/ }),

/***/ "./node_modules/multiformats/dist/src/vendor/varint.js":
/*!*************************************************************!*\
  !*** ./node_modules/multiformats/dist/src/vendor/varint.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable */\nvar encode_1 = encode;\nvar MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n    out = out || [];\n    offset = offset || 0;\n    var oldOffset = offset;\n    while (num >= INT) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num /= 128;\n    }\n    while (num & MSBALL) {\n        out[offset++] = (num & 0xFF) | MSB;\n        num >>>= 7;\n    }\n    out[offset] = num | 0;\n    // @ts-ignore\n    encode.bytes = offset - oldOffset + 1;\n    return out;\n}\nvar decode = read;\nvar MSB$1 = 0x80, REST$1 = 0x7F;\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n    do {\n        if (counter >= l) {\n            // @ts-ignore\n            read.bytes = 0;\n            throw new RangeError('Could not decode varint');\n        }\n        b = buf[counter++];\n        res += shift < 28\n            ? (b & REST$1) << shift\n            : (b & REST$1) * Math.pow(2, shift);\n        shift += 7;\n    } while (b >= MSB$1);\n    // @ts-ignore\n    read.bytes = counter - offset;\n    return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (/** @type {number} */ value) {\n    return (value < N1 ? 1\n        : value < N2 ? 2\n            : value < N3 ? 3\n                : value < N4 ? 4\n                    : value < N5 ? 5\n                        : value < N6 ? 6\n                            : value < N7 ? 7\n                                : value < N8 ? 8\n                                    : value < N9 ? 9\n                                        : 10);\n};\nvar varint = {\n    encode: encode_1,\n    decode: decode,\n    encodingLength: length\n};\nvar _brrp_varint = varint;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_brrp_varint);\n//# sourceMappingURL=varint.js.map\n\n//# sourceURL=webpack://respec-vc/./node_modules/multiformats/dist/src/vendor/varint.js?");

/***/ }),

/***/ "./contexts/credentials/examples/v2.json":
/*!***********************************************!*\
  !*** ./contexts/credentials/examples/v2.json ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"@context\":{\"@vocab\":\"https://www.w3.org/ns/credentials/examples#\"}}');\n\n//# sourceURL=webpack://respec-vc/./contexts/credentials/examples/v2.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;